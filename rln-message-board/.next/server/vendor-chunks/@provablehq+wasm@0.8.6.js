"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@provablehq+wasm@0.8.6";
exports.ids = ["vendor-chunks/@provablehq+wasm@0.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/aleo_wasm.wasm":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/aleo_wasm.wasm ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/aleo_wasm.9f2fe9e5.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js ***!
  \*******************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   BHP1024: () => (/* binding */ BHP1024),\n/* harmony export */   BHP256: () => (/* binding */ BHP256),\n/* harmony export */   BHP512: () => (/* binding */ BHP512),\n/* harmony export */   BHP768: () => (/* binding */ BHP768),\n/* harmony export */   Ciphertext: () => (/* binding */ Ciphertext),\n/* harmony export */   ComputeKey: () => (/* binding */ ComputeKey),\n/* harmony export */   Execution: () => (/* binding */ Execution),\n/* harmony export */   ExecutionResponse: () => (/* binding */ ExecutionResponse),\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   GraphKey: () => (/* binding */ GraphKey),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   KeyPair: () => (/* binding */ KeyPair),\n/* harmony export */   Metadata: () => (/* binding */ Metadata),\n/* harmony export */   OfflineQuery: () => (/* binding */ OfflineQuery),\n/* harmony export */   Pedersen128: () => (/* binding */ Pedersen128),\n/* harmony export */   Pedersen64: () => (/* binding */ Pedersen64),\n/* harmony export */   Plaintext: () => (/* binding */ Plaintext),\n/* harmony export */   Poseidon2: () => (/* binding */ Poseidon2),\n/* harmony export */   Poseidon4: () => (/* binding */ Poseidon4),\n/* harmony export */   Poseidon8: () => (/* binding */ Poseidon8),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyCiphertext: () => (/* binding */ PrivateKeyCiphertext),\n/* harmony export */   Program: () => (/* binding */ Program),\n/* harmony export */   ProgramManager: () => (/* binding */ ProgramManager),\n/* harmony export */   ProvingKey: () => (/* binding */ ProvingKey),\n/* harmony export */   RecordCiphertext: () => (/* binding */ RecordCiphertext),\n/* harmony export */   RecordPlaintext: () => (/* binding */ RecordPlaintext),\n/* harmony export */   Scalar: () => (/* binding */ Scalar),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   Transition: () => (/* binding */ Transition),\n/* harmony export */   VerifyingKey: () => (/* binding */ VerifyingKey),\n/* harmony export */   ViewKey: () => (/* binding */ ViewKey),\n/* harmony export */   initSync: () => (/* binding */ initSync),\n/* harmony export */   initThreadPool: () => (/* binding */ initThreadPool),\n/* harmony export */   runRayonThread: () => (/* binding */ runRayonThread),\n/* harmony export */   verifyFunctionExecution: () => (/* binding */ verifyFunctionExecution)\n/* harmony export */ });\nfunction spawnWorker(url, module, memory, address) {\n        return new Promise((resolve) => {\n            const worker = new Worker(url, {\n                type: \"module\",\n            });\n\n            worker.addEventListener(\"message\", (event) => {\n                // This is needed in Node to wait one extra tick, so that way\n                // the Worker can fully initialize before we return.\n                setTimeout(() => {\n                    resolve(worker);\n\n                    // When running in Node, this allows the process to exit\n                    // even though the Worker is still running.\n                    if (worker.unref) {\n                        worker.unref();\n                    }\n                }, 0);\n            }, {\n                capture: true,\n                once: true,\n            });\n\n            worker.postMessage({\n                module,\n                memory,\n                address,\n            });\n        });\n    }\n\nlet wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.buffer !== wasm.memory.buffer) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().slice(ptr, ptr + len));\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_1(addHeapObject(e));\n    }\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n};\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => {\n    wasm.__wbindgen_export_5.get(state.dtor)(state.a, state.b);\n});\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_5.get(state.dtor)(a, state.b);\n                CLOSURE_DTORS.unregister(state);\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Verify an execution with a single function and a single transition. Executions with multiple\n * transitions or functions will fail to verify. Also, this does not verify that the state root of\n * the execution is included in the Aleo Network ledger.\n *\n * @param {Execution} execution The function execution to verify\n * @param {VerifyingKey} verifying_key The verifying key for the function\n * @param {Program} program The program that the function execution belongs to\n * @param {String} function_id The name of the function that was executed\n * @returns {boolean} True if the execution is valid, false otherwise\n * @param {Execution} execution\n * @param {VerifyingKey} verifying_key\n * @param {Program} program\n * @param {string} function_id\n * @returns {boolean}\n */\nfunction verifyFunctionExecution(execution, verifying_key, program, function_id) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(execution, Execution);\n        _assertClass(verifying_key, VerifyingKey);\n        _assertClass(program, Program);\n        const ptr0 = passStringToWasm0(function_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.verifyFunctionExecution(retptr, execution.__wbg_ptr, verifying_key.__wbg_ptr, program.__wbg_ptr, ptr0, len0);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n * @param {number} receiver\n */\nfunction runRayonThread(receiver) {\n    wasm.runRayonThread(receiver);\n}\n\n/**\n * @param {URL} url\n * @param {number} num_threads\n * @returns {Promise<void>}\n */\nfunction initThreadPool$1(url, num_threads) {\n    const ret = wasm.initThreadPool(addHeapObject(url), num_threads);\n    return takeObject(ret);\n}\n\nfunction __wbg_adapter_40(arg0, arg1, arg2) {\n    wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction __wbg_adapter_491(arg0, arg1, arg2, arg3) {\n    wasm.__wbindgen_export_7(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\nconst __wbindgen_enum_RequestCredentials = [\"omit\", \"same-origin\", \"include\"];\n\nconst __wbindgen_enum_RequestMode = [\"same-origin\", \"no-cors\", \"cors\", \"navigate\"];\n\nconst AddressFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_address_free(ptr >>> 0, 1));\n/**\n * Public address of an Aleo account\n */\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n        AddressFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AddressFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr, 0);\n    }\n    /**\n     * Derive an Aleo address from a private key\n     *\n     * @param {PrivateKey} private_key The private key to derive the address from\n     * @returns {Address} Address corresponding to the private key\n     * @param {PrivateKey} private_key\n     * @returns {Address}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.address_from_private_key(private_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Derive an Aleo address from a view key\n     *\n     * @param {ViewKey} view_key The view key to derive the address from\n     * @returns {Address} Address corresponding to the view key\n     * @param {ViewKey} view_key\n     * @returns {Address}\n     */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.address_from_view_key(view_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Derive an Aleo address from a compute key.\n     *\n     * @param {ComputeKey} compute_key The compute key to derive the address from\n     * @param {ComputeKey} compute_key\n     * @returns {Address}\n     */\n    static from_compute_key(compute_key) {\n        _assertClass(compute_key, ComputeKey);\n        const ret = wasm.address_from_compute_key(compute_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Create an aleo address object from a string representation of an address\n     *\n     * @param {string} address String representation of an addressm\n     * @returns {Address} Address\n     * @param {string} address\n     * @returns {Address}\n     */\n    static from_string(address) {\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.address_from_string(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get a string representation of an Aleo address object\n     *\n     * @param {Address} Address\n     * @returns {string} String representation of the address\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Verify a signature for a message signed by the address\n     *\n     * @param {Uint8Array} Byte array representing a message signed by the address\n     * @returns {boolean} Boolean representing whether or not the signature is valid\n     * @param {Uint8Array} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Signature);\n        const ret = wasm.address_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst BHP1024Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp1024_free(ptr >>> 0, 1));\n\nclass BHP1024 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP1024.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP1024Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP1024Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp1024_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 1024 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp1024_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP1024Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 1024 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP1024}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp1024_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP1024.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 1024 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp1024_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 1024 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp1024_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 1024 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp1024_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 1024 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp1024_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP256Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp256_free(ptr >>> 0, 1));\n\nclass BHP256 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP256.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP256Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP256Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp256_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 256 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp256_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP256Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 256 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP256}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp256_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP256.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 256 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp256_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 256 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp256_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 256 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp256_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 256 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp256_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP512Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp512_free(ptr >>> 0, 1));\n\nclass BHP512 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP512.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP512Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP512Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp512_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 512 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp512_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP512Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 512 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP512}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp512_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP512.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 512 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp512_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 512 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp512_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 512 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp512_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 512 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp512_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst BHP768Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_bhp768_free(ptr >>> 0, 1));\n\nclass BHP768 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(BHP768.prototype);\n        obj.__wbg_ptr = ptr;\n        BHP768Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BHP768Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bhp768_free(ptr, 0);\n    }\n    /**\n     * Create a BHP hasher with an input size of 768 bits.\n     */\n    constructor() {\n        const ret = wasm.bhp768_new();\n        this.__wbg_ptr = ret >>> 0;\n        BHP768Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a BHP hasher with an input size of 768 bits with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {BHP768}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.bhp768_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BHP768.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the BHP hash with an input hasher of 768 bits.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp768_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP hash with an input hasher of 768 bits.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bhp768_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 768 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp768_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a BHP commitment with an input hasher of 768 bits and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.bhp768_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst CiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ciphertext_free(ptr >>> 0, 1));\n/**\n * SnarkVM Ciphertext object. A Ciphertext represents an symmetrically encrypted plaintext. This\n * object provides decryption methods to recover the plaintext from the ciphertext (given the\n * api consumer has the proper decryption materials).\n *\n * @example\n */\nclass Ciphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Ciphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        CiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        CiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ciphertext_free(ptr, 0);\n    }\n    /**\n     * Decrypt the ciphertext using the given view key.\n     *\n     * @param {ViewKey} The view key of the account that encrypted the ciphertext.\n     * @param {Group} The nonce used to encrypt the ciphertext.\n     *\n     * @returns {Plaintext} The decrypted plaintext.\n     * @param {ViewKey} view_key\n     * @param {Group} nonce\n     * @returns {Plaintext}\n     */\n    decrypt(view_key, nonce) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            var ptr0 = view_key.__destroy_into_raw();\n            _assertClass(nonce, Group);\n            var ptr1 = nonce.__destroy_into_raw();\n            wasm.ciphertext_decrypt(retptr, this.__wbg_ptr, ptr0, ptr1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypt a ciphertext using the view key of the transition signer, transition public key, and\n     * (program, function, index) tuple.\n     * @param {ViewKey} view_key\n     * @param {Group} transition_public_key\n     * @param {string} program\n     * @param {string} function_name\n     * @param {number} index\n     * @returns {Plaintext}\n     */\n    decrypt_with_transition_info(view_key, transition_public_key, program, function_name, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            var ptr0 = view_key.__destroy_into_raw();\n            _assertClass(transition_public_key, Group);\n            var ptr1 = transition_public_key.__destroy_into_raw();\n            const ptr2 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len2 = WASM_VECTOR_LEN;\n            const ptr3 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len3 = WASM_VECTOR_LEN;\n            wasm.ciphertext_decrypt_with_transition_info(retptr, this.__wbg_ptr, ptr0, ptr1, ptr2, len2, ptr3, len3, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypt a ciphertext using the transition view key and a (program, function, index) tuple.\n     * @param {Field} transition_view_key\n     * @param {string} program\n     * @param {string} function_name\n     * @param {number} index\n     * @returns {Plaintext}\n     */\n    decrypt_with_transition_view_key(transition_view_key, program, function_name, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            var ptr0 = transition_view_key.__destroy_into_raw();\n            const ptr1 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.ciphertext_decrypt_with_transition_view_key(retptr, this.__wbg_ptr, ptr0, ptr1, len1, ptr2, len2, index);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypts a ciphertext into plaintext using the given ciphertext view key.\n     *\n     * @param {Field} transition_view_key The transition view key that was used to encrypt the ciphertext.\n     *\n     * @returns {Plaintext} The decrypted plaintext.\n     * @param {Field} transition_view_key\n     * @returns {Plaintext}\n     */\n    decryptSymmetric(transition_view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            var ptr0 = transition_view_key.__destroy_into_raw();\n            wasm.ciphertext_decryptSymmetric(retptr, this.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Deserialize a left endian byte array into a Ciphertext.\n     *\n     * @param {Uint8Array} bytes The byte array representing the Ciphertext.\n     *\n     * @returns {Ciphertext} The Ciphertext object.\n     * @param {Uint8Array} bytes\n     * @returns {Ciphertext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Deserialize a Ciphertext string into a Ciphertext object.\n     *\n     * @param {string} ciphertext A string representation of the ciphertext.\n     *\n     * @returns {Ciphertext} The Ciphertext object.\n     * @param {string} ciphertext\n     * @returns {Ciphertext}\n     */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialize a Ciphertext object into a byte array.\n     *\n     * @returns {Uint8Array} The serialized Ciphertext.\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Serialize a Ciphertext into a js string.\n     *\n     * @returns {string} The serialized Ciphertext.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst ComputeKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_computekey_free(ptr >>> 0, 1));\n\nclass ComputeKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ComputeKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ComputeKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ComputeKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_computekey_free(ptr, 0);\n    }\n    /**\n     * Create a new compute key from a private key.\n     *\n     * @param {PrivateKey} private_key Private key\n     *\n     * @returns {ComputeKey} Compute key\n     * @param {PrivateKey} private_key\n     * @returns {ComputeKey}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.computekey_from_private_key(private_key.__wbg_ptr);\n        return ComputeKey.__wrap(ret);\n    }\n    /**\n     * Get the address from the compute key.\n     *\n     * @returns {Address}\n     * @returns {Address}\n     */\n    address() {\n        const ret = wasm.address_from_compute_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the sk_prf of the compute key.\n     *\n     * @returns {Scalar} sk_prf\n     * @returns {Scalar}\n     */\n    sk_prf() {\n        const ret = wasm.computekey_sk_prf(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the pr_tag of the compute key.\n     *\n     * @returns {Group} pr_tag\n     * @returns {Group}\n     */\n    pk_sig() {\n        const ret = wasm.computekey_pk_sig(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the pr_sig of the compute key.\n     *\n     * @returns {Group} pr_sig\n     * @returns {Group}\n     */\n    pr_sig() {\n        const ret = wasm.computekey_pr_sig(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n}\n\nconst ExecutionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_execution_free(ptr >>> 0, 1));\n/**\n * Execution of an Aleo program.\n */\nclass Execution {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Execution.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_execution_free(ptr, 0);\n    }\n    /**\n     * Returns the string representation of the execution.\n     *\n     * @returns {string} The string representation of the execution.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Creates an execution object from a string representation of an execution.\n     *\n     * @returns {Execution | Error} The wasm representation of an execution object.\n     * @param {string} execution\n     * @returns {Execution}\n     */\n    static fromString(execution) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(execution, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.execution_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Execution.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the global state root of the execution.\n     *\n     * @returns {Execution | Error} The global state root used in the execution.\n     * @returns {string}\n     */\n    globalStateRoot() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_globalStateRoot(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the proof of the execution.\n     *\n     * @returns {string} The execution proof.\n     * @returns {string}\n     */\n    proof() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.execution_proof(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the transitions present in the execution.\n     *\n     * @returns Array<Transition> the array of transitions present in the execution.\n     * @returns {Array<any>}\n     */\n    transitions() {\n        const ret = wasm.execution_transitions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst ExecutionResponseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_executionresponse_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo function execution response\n *\n * This object is returned by the execution of an Aleo function off-chain. It provides methods for\n * retrieving the outputs of the function execution.\n */\nclass ExecutionResponse {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutionResponse.prototype);\n        obj.__wbg_ptr = ptr;\n        ExecutionResponseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ExecutionResponseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executionresponse_free(ptr, 0);\n    }\n    /**\n     * Get the outputs of the executed function\n     *\n     * @returns {Array} Array of strings representing the outputs of the function\n     * @returns {Array<any>}\n     */\n    getOutputs() {\n        const ret = wasm.executionresponse_getOutputs(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Returns the execution object if present, null if otherwise.\n     *\n     * @returns {Execution | undefined} The execution object if present, null if otherwise\n     * @returns {Execution | undefined}\n     */\n    getExecution() {\n        const ret = wasm.executionresponse_getExecution(this.__wbg_ptr);\n        return ret === 0 ? undefined : Execution.__wrap(ret);\n    }\n    /**\n     * Returns the program keys if present\n     * @returns {KeyPair}\n     */\n    getKeys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getKeys(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KeyPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the proving_key if the proving key was cached in the Execution response.\n     * Note the proving key is removed from the response object after the first call to this\n     * function. Subsequent calls will return null.\n     *\n     * @returns {ProvingKey | undefined} The proving key\n     * @returns {ProvingKey | undefined}\n     */\n    getProvingKey() {\n        const ret = wasm.executionresponse_getProvingKey(this.__wbg_ptr);\n        return ret === 0 ? undefined : ProvingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying_key associated with the program\n     *\n     * @returns {VerifyingKey} The verifying key\n     * @returns {VerifyingKey}\n     */\n    getVerifyingKey() {\n        const ret = wasm.executionresponse_getVerifyingKey(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the function identifier\n     * @returns {string}\n     */\n    getFunctionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.executionresponse_getFunctionId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the program\n     * @returns {Program}\n     */\n    getProgram() {\n        const ret = wasm.executionresponse_getProgram(this.__wbg_ptr);\n        return Program.__wrap(ret);\n    }\n}\n\nconst FieldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_field_free(ptr >>> 0, 1));\n/**\n * Field element.\n */\nclass Field {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Field.prototype);\n        obj.__wbg_ptr = ptr;\n        FieldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    static __unwrap(jsValue) {\n        if (!(jsValue instanceof Field)) {\n            return 0;\n        }\n        return jsValue.__destroy_into_raw();\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FieldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_field_free(ptr, 0);\n    }\n    /**\n     * Creates a field object from a string representation of a field element.\n     * @param {string} field\n     * @returns {Field}\n     */\n    static fromString(field) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(field, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.field_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the field element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a field element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Field}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the field element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a field element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Field}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.field_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the field element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.field_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Create a plaintext from the field element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.field_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the field element.\n     * @returns {Field}\n     */\n    clone() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Generate a random field element.\n     * @returns {Field}\n     */\n    static random() {\n        const ret = wasm.field_random();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Add two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    add(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Subtract two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    subtract(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Multiply two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    multiply(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_multiply(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Divide two field elements.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    divide(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_divide(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Power of a field element.\n     * @param {Field} other\n     * @returns {Field}\n     */\n    pow(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_pow(this.__wbg_ptr, other.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Invert the field element.\n     * @returns {Field}\n     */\n    inverse() {\n        const ret = wasm.field_inverse(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the additive identity element of the field.\n     * @returns {Field}\n     */\n    static zero() {\n        const ret = wasm.field_zero();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the multiplicative identity of the field.\n     * @returns {Field}\n     */\n    static one() {\n        const ret = wasm.field_one();\n        return Field.__wrap(ret);\n    }\n    /**\n     * Double the field element.\n     * @returns {Field}\n     */\n    double() {\n        const ret = wasm.field_double(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Check if one field element equals another.\n     * @param {Field} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Field);\n        const ret = wasm.field_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst GraphKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_graphkey_free(ptr >>> 0, 1));\n\nclass GraphKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GraphKey.prototype);\n        obj.__wbg_ptr = ptr;\n        GraphKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GraphKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_graphkey_free(ptr, 0);\n    }\n    /**\n     * Create a new graph key from a view key.\n     *\n     * @param {ViewKey} view_key View key\n     * @returns {GraphKey} Graph key\n     * @param {ViewKey} view_key\n     * @returns {GraphKey}\n     */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.graphkey_from_view_key(view_key.__wbg_ptr);\n        return GraphKey.__wrap(ret);\n    }\n    /**\n     * Create a new graph key from a string representation of a graph key\n     *\n     * @param {string} graph_key String representation of a graph key\n     * @returns {GraphKey} Graph key\n     * @param {string} graph_key\n     * @returns {GraphKey}\n     */\n    static from_string(graph_key) {\n        const ptr0 = passStringToWasm0(graph_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.graphkey_from_string(ptr0, len0);\n        return GraphKey.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a graph key\n     *\n     * @returns {string} String representation of a graph key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.graphkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the sk_tag of the graph key. Used to determine ownership of records.\n     * @returns {Field}\n     */\n    sk_tag() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n}\n\nconst GroupFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_group_free(ptr >>> 0, 1));\n/**\n * Elliptic curve element.\n */\nclass Group {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Group.prototype);\n        obj.__wbg_ptr = ptr;\n        GroupFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GroupFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_group_free(ptr, 0);\n    }\n    /**\n     * Creates a group object from a string representation of a group element.\n     * @param {string} group\n     * @returns {Group}\n     */\n    static fromString(group) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(group, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.group_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the group element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a group element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Group}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the group element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a group element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Group}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.group_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the group element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.group_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the x-coordinate of the group element.\n     * @returns {Field}\n     */\n    toXCoordinate() {\n        const ret = wasm.group_toXCoordinate(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Create a plaintext element from a group element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.group_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the group element.\n     * @returns {Group}\n     */\n    clone() {\n        const ret = wasm.group_clone(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Generate a random group element.\n     * @returns {Group}\n     */\n    static random() {\n        const ret = wasm.group_random();\n        return Group.__wrap(ret);\n    }\n    /**\n     * Add two group elements.\n     * @param {Group} other\n     * @returns {Group}\n     */\n    add(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Subtract two group elements (equivalently: add the inverse of an element).\n     * @param {Group} other\n     * @returns {Group}\n     */\n    subtract(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Multiply a group element by a scalar element.\n     * @param {Scalar} scalar\n     * @returns {Group}\n     */\n    scalarMultiply(scalar) {\n        _assertClass(scalar, Scalar);\n        const ret = wasm.group_scalarMultiply(this.__wbg_ptr, scalar.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Double the group element.\n     * @returns {Group}\n     */\n    double() {\n        const ret = wasm.group_double(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the inverse of the group element. This is the reflection of the point about the axis\n     * of symmetry i.e. (x,y) -> (x, -y).\n     * @returns {Group}\n     */\n    inverse() {\n        const ret = wasm.group_inverse(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Check if one group element equals another.\n     * @param {Group} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Group);\n        const ret = wasm.group_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the group identity element under the group operation (i.e. the point at infinity.)\n     * @returns {Group}\n     */\n    static zero() {\n        const ret = wasm.group_zero();\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the generator of the group.\n     * @returns {Group}\n     */\n    static generator() {\n        const ret = wasm.group_generator();\n        return Group.__wrap(ret);\n    }\n}\n\nconst KeyPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_keypair_free(ptr >>> 0, 1));\n/**\n * Key pair object containing both the function proving and verifying keys\n */\nclass KeyPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeyPair.prototype);\n        obj.__wbg_ptr = ptr;\n        KeyPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        KeyPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keypair_free(ptr, 0);\n    }\n    /**\n     * Create new key pair from proving and verifying keys\n     *\n     * @param {ProvingKey} proving_key Proving key corresponding to a function in an Aleo program\n     * @param {VerifyingKey} verifying_key Verifying key corresponding to a function in an Aleo program\n     * @returns {KeyPair} Key pair object containing both the function proving and verifying keys\n     * @param {ProvingKey} proving_key\n     * @param {VerifyingKey} verifying_key\n     */\n    constructor(proving_key, verifying_key) {\n        _assertClass(proving_key, ProvingKey);\n        var ptr0 = proving_key.__destroy_into_raw();\n        _assertClass(verifying_key, VerifyingKey);\n        var ptr1 = verifying_key.__destroy_into_raw();\n        const ret = wasm.keypair_new(ptr0, ptr1);\n        this.__wbg_ptr = ret >>> 0;\n        KeyPairFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get the proving key. This method will remove the proving key from the key pair\n     *\n     * @returns {ProvingKey}\n     * @returns {ProvingKey}\n     */\n    provingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_provingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the verifying key. This method will remove the verifying key from the key pair\n     *\n     * @returns {VerifyingKey}\n     * @returns {VerifyingKey}\n     */\n    verifyingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst MetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0, 1));\n\nclass Metadata {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Metadata.prototype);\n        obj.__wbg_ptr = ptr;\n        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MetadataFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadata_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_name(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set name(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get locator() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_locator(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set locator(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_locator(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get prover() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_prover(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set prover(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_prover(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get verifier() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_verifier(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set verifier(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_verifier(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    get verifyingKey() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.__wbg_get_metadata_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set verifyingKey(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_metadata_verifyingKey(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @returns {string}\n     */\n    static baseUrl() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadata_baseUrl(retptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static bond_public() {\n        const ret = wasm.metadata_bond_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static bond_validator() {\n        const ret = wasm.metadata_bond_validator();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static claim_unbond_public() {\n        const ret = wasm.metadata_claim_unbond_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static fee_private() {\n        const ret = wasm.metadata_fee_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static fee_public() {\n        const ret = wasm.metadata_fee_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static inclusion() {\n        const ret = wasm.metadata_inclusion();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static join() {\n        const ret = wasm.metadata_join();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static set_validator_state() {\n        const ret = wasm.metadata_set_validator_state();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static split() {\n        const ret = wasm.metadata_split();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_private() {\n        const ret = wasm.metadata_transfer_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_private_to_public() {\n        const ret = wasm.metadata_transfer_private_to_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public() {\n        const ret = wasm.metadata_transfer_public();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public_as_signer() {\n        const ret = wasm.metadata_transfer_public_as_signer();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static transfer_public_to_private() {\n        const ret = wasm.metadata_transfer_public_to_private();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static unbond_public() {\n        const ret = wasm.metadata_unbond_public();\n        return Metadata.__wrap(ret);\n    }\n}\n\nconst OfflineQueryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_offlinequery_free(ptr >>> 0, 1));\n/**\n * An offline query object used to insert the global state root and state paths needed to create\n * a valid inclusion proof offline.\n */\nclass OfflineQuery {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OfflineQuery.prototype);\n        obj.__wbg_ptr = ptr;\n        OfflineQueryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OfflineQueryFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_offlinequery_free(ptr, 0);\n    }\n    /**\n     * Creates a new offline query object. The state root is required to be passed in as a string\n     * @param {number} block_height\n     * @param {string} state_root\n     */\n    constructor(block_height, state_root) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(state_root, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_new(retptr, block_height, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            OfflineQueryFinalization.register(this, this.__wbg_ptr, this);\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Add a new block height to the offline query object.\n     * @param {number} block_height\n     */\n    addBlockHeight(block_height) {\n        wasm.offlinequery_addBlockHeight(this.__wbg_ptr, block_height);\n    }\n    /**\n     * Add a new state path to the offline query object.\n     *\n     * @param {string} commitment: The commitment corresponding to a record inpout\n     * @param {string} state_path: The state path corresponding to the commitment\n     * @param {string} commitment\n     * @param {string} state_path\n     */\n    addStatePath(commitment, state_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(commitment, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(state_path, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.offlinequery_addStatePath(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a json string representation of the offline query object\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.offlinequery_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create an offline query object from a json string representation\n     * @param {string} s\n     * @returns {OfflineQuery}\n     */\n    static fromString(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.offlinequery_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return OfflineQuery.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Pedersen128Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pedersen128_free(ptr >>> 0, 1));\n\nclass Pedersen128 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Pedersen128.prototype);\n        obj.__wbg_ptr = ptr;\n        Pedersen128Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Pedersen128Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pedersen128_free(ptr, 0);\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 128-bit input.\n     */\n    constructor() {\n        const ret = wasm.pedersen128_new();\n        this.__wbg_ptr = ret >>> 0;\n        Pedersen128Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 128-bit input with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Pedersen128}\n     */\n    static setup(domain_separator) {\n        const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.pedersen128_setup(ptr0, len0);\n        return Pedersen128.__wrap(ret);\n    }\n    /**\n     * Returns the Pedersen hash for a given (up to) 128-bit input.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pedersen128_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 128-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen128_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 128-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen128_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Pedersen64Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pedersen64_free(ptr >>> 0, 1));\n\nclass Pedersen64 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Pedersen64.prototype);\n        obj.__wbg_ptr = ptr;\n        Pedersen64Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Pedersen64Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pedersen64_free(ptr, 0);\n    }\n    /**\n     * Create a Pedersen hasher for a given (up to) 64-bit input.\n     */\n    constructor() {\n        const ret = wasm.pedersen64_new();\n        this.__wbg_ptr = ret >>> 0;\n        Pedersen64Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Pedersen64 hasher for a given (up to) 64-bit input with a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Pedersen64}\n     */\n    static setup(domain_separator) {\n        const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.pedersen64_setup(ptr0, len0);\n        return Pedersen64.__wrap(ret);\n    }\n    /**\n     * Returns the Pedersen hash for a given (up to) 64-bit input.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pedersen64_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 64-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Field}\n     */\n    commit(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen64_commit(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns a Pedersen commitment for the given (up to) 64-bit input and randomizer.\n     * @param {Array<any>} input\n     * @param {Scalar} randomizer\n     * @returns {Group}\n     */\n    commitToGroup(input, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(randomizer, Scalar);\n            var ptr0 = randomizer.__destroy_into_raw();\n            wasm.pedersen64_commitToGroup(retptr, this.__wbg_ptr, addHeapObject(input), ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PlaintextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_plaintext_free(ptr >>> 0, 1));\n/**\n * SnarkVM Plaintext object. Plaintext is a fundamental monadic type used to represent Aleo\n * primitive types (boolean, field, group, i8, i16, i32, i64, i128, u8, u16, u32, u64, u128,\n * scalar, and signature), struct types, and array types.\n *\n * In the context of a web or NodeJS application, this type is useful for turning an Aleo type into\n * a JS value, object, or array that might be necessary for performing computations within the\n * application.\n *\n * @example\n * // Get the bond state of an existing address.\n * const bondState = await fetch(https://api.explorer.provable.com/v1/mainnet/program/credits.aleo/mapping/bond_state/aleo12zlythl7htjdtjjjz3ahdj4vl6wk3zuzm37s80l86qpx8fyx95fqnxcn2f);\n * // Convert the bond state to a Plaintext object.\n * const bondStatePlaintext = Plaintext.fromString(bond_state);\n * // Convert the Plaintext object to a JS object.\n * const bondStateObject = bond_state_plaintext.toObject();\n * // Check if the bond state matches the expected object.\n * const expectedObject = { validator: \"aleo12zlythl7htjdtjjjz3ahdj4vl6wk3zuzm37s80l86qpx8fyx95fqnxcn2f\", microcredits: 100000000u64 };\n * assert( JSON.stringify(bondStateObject) === JSON.stringify(expectedObject) );\n */\nclass Plaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Plaintext.prototype);\n        obj.__wbg_ptr = ptr;\n        PlaintextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PlaintextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plaintext_free(ptr, 0);\n    }\n    /**\n     * Find plaintext member if the plaintext is a struct. Returns `null` if the plaintext is not\n     * a struct or the member does not exist.\n     *\n     * @param {string} name The name of the plaintext member to find.\n     *\n     * @returns {Plaintext} The plaintext member.\n     * @param {string} name\n     * @returns {Plaintext}\n     */\n    find(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plaintext_find(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt a plaintext with an address and randomizer.\n     * @param {Address} address\n     * @param {Scalar} randomizer\n     * @returns {Ciphertext}\n     */\n    encrypt(address, randomizer) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            _assertClass(randomizer, Scalar);\n            wasm.plaintext_encrypt(retptr, this.__wbg_ptr, address.__wbg_ptr, randomizer.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt a plaintext with a transition view key.\n     * @param {Field} transition_view_key\n     * @returns {Ciphertext}\n     */\n    encryptSymmetric(transition_view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(transition_view_key, Field);\n            wasm.plaintext_encryptSymmetric(retptr, this.__wbg_ptr, transition_view_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Ciphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Creates a plaintext object from a string representation of a plaintext.\n     *\n     * @param {string} plaintext The string representation of the plaintext.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {string} plaintext\n     * @returns {Plaintext}\n     */\n    static fromString(plaintext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.plaintext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a plaintext object from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the plaintext.\n     *\n     * @returns {Plaintext} The plaintext object.\n     * @param {Uint8Array} bytes\n     * @returns {Plaintext}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Generate a random plaintext element from a series of bytes.\n     *\n     * @param {Uint8Array} bytes A left endian byte array representing the plaintext.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the plaintext.\n     *\n     * @returns {string} The string representation of the plaintext.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Gives the type of the plaintext.\n     *\n     * @returns {string} The type of the plaintext.\n     * @returns {string}\n     */\n    plaintextType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_plaintextType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Attempt to convert the plaintext to a JS object.\n     *\n     * @returns {Object} The JS object representation of the plaintext.\n     * @returns {any}\n     */\n    toObject() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plaintext_toObject(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon2Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon2_free(ptr >>> 0, 1));\n\nclass Poseidon2 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon2.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon2Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon2Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon2_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 2.\n     */\n    constructor() {\n        const ret = wasm.poseidon2_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon2Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 2 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon2}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon2_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon2.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 2.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 2 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon2_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon4Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon4_free(ptr >>> 0, 1));\n\nclass Poseidon4 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon4.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon4Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon4Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon4_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 4.\n     */\n    constructor() {\n        const ret = wasm.poseidon4_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon4Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 4 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon4}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon4_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon4.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 4.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 4 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon4_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Poseidon8Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_poseidon8_free(ptr >>> 0, 1));\n\nclass Poseidon8 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Poseidon8.prototype);\n        obj.__wbg_ptr = ptr;\n        Poseidon8Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Poseidon8Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poseidon8_free(ptr, 0);\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 8.\n     */\n    constructor() {\n        const ret = wasm.poseidon8_new();\n        this.__wbg_ptr = ret >>> 0;\n        Poseidon8Finalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a Poseidon hasher with an input rate of 8 and a custom domain separator.\n     * @param {string} domain_separator\n     * @returns {Poseidon8}\n     */\n    static setup(domain_separator) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(domain_separator, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.poseidon8_setup(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Poseidon8.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8.\n     * @param {Array<any>} input\n     * @returns {Field}\n     */\n    hash(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hash(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the extended Poseidon hash with an input rate of 8.\n     * @param {Array<any>} input\n     * @param {number} num_outputs\n     * @returns {Array<any>}\n     */\n    hashMany(input, num_outputs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashMany(retptr, this.__wbg_ptr, addHeapObject(input), num_outputs);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8 on the scalar field.\n     * @param {Array<any>} input\n     * @returns {Scalar}\n     */\n    hashToScalar(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashToScalar(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the Poseidon hash with an input rate of 8 on the affine curve.\n     * @param {Array<any>} input\n     * @returns {Group}\n     */\n    hashToGroup(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poseidon8_hashToGroup(retptr, this.__wbg_ptr, addHeapObject(input));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Group.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_privatekey_free(ptr >>> 0, 1));\n/**\n * Private key of an Aleo account\n */\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n        PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PrivateKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr, 0);\n    }\n    /**\n     * Generate a new private key using a cryptographically secure random number generator\n     *\n     * @returns {PrivateKey}\n     */\n    constructor() {\n        const ret = wasm.privatekey_new();\n        this.__wbg_ptr = ret >>> 0;\n        PrivateKeyFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get a private key from a series of unchecked bytes\n     *\n     * @param {Uint8Array} seed Unchecked 32 byte long Uint8Array acting as the seed for the private key\n     * @returns {PrivateKey}\n     * @param {Uint8Array} seed\n     * @returns {PrivateKey}\n     */\n    static from_seed_unchecked(seed) {\n        const ptr0 = passArray8ToWasm0(seed, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_from_seed_unchecked(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n     * Get a private key from a string representation of a private key\n     *\n     * @param {string} seed String representation of a private key\n     * @returns {PrivateKey}\n     * @param {string} private_key\n     * @returns {PrivateKey}\n     */\n    static from_string(private_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(private_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_string(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the private key. This function should be used very carefully\n     * as it exposes the private key plaintext\n     *\n     * @returns {string} String representation of a private key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the view key corresponding to the private key\n     *\n     * @returns {ViewKey}\n     * @returns {ViewKey}\n     */\n    to_view_key() {\n        const ret = wasm.privatekey_to_view_key(this.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Get the address corresponding to the private key\n     *\n     * @returns {Address}\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.privatekey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Sign a message with the private key\n     *\n     * @param {Uint8Array} Byte array representing a message signed by the address\n     * @returns {Signature} Signature generated by signing the message with the address\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get a new randomly generated private key ciphertext using a secret. The secret is sensitive\n     * and will be needed to decrypt the private key later, so it should be stored securely\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKeyCiphertext} Ciphertext representation of the private key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    static newEncrypted(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_newEncrypted(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Encrypt an existing private key with a secret. The secret is sensitive and will be needed to\n     * decrypt the private key later, so it should be stored securely\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKeyCiphertext} Ciphertext representation of the private key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    toCiphertext(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get private key from a private key ciphertext and secret originally used to encrypt it\n     *\n     * @param {PrivateKeyCiphertext} ciphertext Ciphertext representation of the private key\n     * @param {string} secret Secret originally used to encrypt the private key\n     * @returns {PrivateKey} Private key\n     * @param {PrivateKeyCiphertext} ciphertext\n     * @param {string} secret\n     * @returns {PrivateKey}\n     */\n    static fromPrivateKeyCiphertext(ciphertext, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ciphertext, PrivateKeyCiphertext);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_fromPrivateKeyCiphertext(retptr, ciphertext.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PrivateKeyCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_privatekeyciphertext_free(ptr >>> 0, 1));\n/**\n * Private Key in ciphertext form\n */\nclass PrivateKeyCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKeyCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        PrivateKeyCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PrivateKeyCiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekeyciphertext_free(ptr, 0);\n    }\n    /**\n     * Encrypt a private key using a secret string. The secret is sensitive and will be needed to\n     * decrypt the private key later, so it should be stored securely\n     *\n     * @param {PrivateKey} private_key Private key to encrypt\n     * @param {string} secret Secret to encrypt the private key with\n     * @returns {PrivateKeyCiphertext} Private key ciphertext\n     * @param {PrivateKey} private_key\n     * @param {string} secret\n     * @returns {PrivateKeyCiphertext}\n     */\n    static encryptPrivateKey(private_key, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, private_key.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Decrypts a private ciphertext using a secret string. This must be the same secret used to\n     * encrypt the private key\n     *\n     * @param {string} secret Secret used to encrypt the private key\n     * @returns {PrivateKey} Private key\n     * @param {string} secret\n     * @returns {PrivateKey}\n     */\n    decryptToPrivateKey(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_decryptToPrivateKey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the ciphertext string\n     *\n     * @returns {string} Ciphertext string\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Creates a PrivateKeyCiphertext from a string\n     *\n     * @param {string} ciphertext Ciphertext string\n     * @returns {PrivateKeyCiphertext} Private key ciphertext\n     * @param {string} ciphertext\n     * @returns {PrivateKeyCiphertext}\n     */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst ProgramFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_program_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo program\n */\nclass Program {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Program.prototype);\n        obj.__wbg_ptr = ptr;\n        ProgramFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProgramFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_program_free(ptr, 0);\n    }\n    /**\n     * Create a program from a program string\n     *\n     * @param {string} program Aleo program source code\n     * @returns {Program} Program object\n     * @param {string} program\n     * @returns {Program}\n     */\n    static fromString(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Program.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the program\n     *\n     * @returns {string} String containing the program source code\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Determine if a function is present in the program\n     *\n     * @param {string} functionName Name of the function to check for\n     * @returns {boolean} True if the program is valid, false otherwise\n     * @param {string} function_name\n     * @returns {boolean}\n     */\n    hasFunction(function_name) {\n        const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.program_hasFunction(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n     * Get javascript array of functions names in the program\n     *\n     * @returns {Array} Array of all function names present in the program\n     *\n     * @example\n     * const expected_functions = [\n     *   \"mint\",\n     *   \"transfer_private\",\n     *   \"transfer_private_to_public\",\n     *   \"transfer_public\",\n     *   \"transfer_public_to_private\",\n     *   \"join\",\n     *   \"split\",\n     *   \"fee\"\n     * ]\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_functions = credits_program.getFunctions();\n     * console.log(credits_functions === expected_functions); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getFunctions() {\n        const ret = wasm.program_getFunctions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a javascript object representation of the function inputs and types. This can be used\n     * to generate a web form to capture user inputs for an execution of a function.\n     *\n     * @param {string} function_name Name of the function to get inputs for\n     * @returns {Array} Array of function inputs\n     *\n     * @example\n     * const expected_inputs = [\n     *     {\n     *       type:\"record\",\n     *       visibility:\"private\",\n     *       record:\"credits\",\n     *       members:[\n     *         {\n     *           name:\"microcredits\",\n     *           type:\"u64\",\n     *           visibility:\"private\"\n     *         }\n     *       ],\n     *       register:\"r0\"\n     *     },\n     *     {\n     *       type:\"address\",\n     *       visibility:\"private\",\n     *       register:\"r1\"\n     *     },\n     *     {\n     *       type:\"u64\",\n     *       visibility:\"private\",\n     *       register:\"r2\"\n     *     }\n     * ];\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const transfer_function_inputs = credits_program.getFunctionInputs(\"transfer_private\");\n     * console.log(transfer_function_inputs === expected_inputs); // Output should be \"true\"\n     * @param {string} function_name\n     * @returns {Array<any>}\n     */\n    getFunctionInputs(function_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getFunctionInputs(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a the list of a program's mappings and the names/types of their keys and values.\n     *\n     * @returns {Array} - An array of objects representing the mappings in the program\n     * @example\n     * const expected_mappings = [\n     *    {\n     *       name: \"account\",\n     *       key_name: \"owner\",\n     *       key_type: \"address\",\n     *       value_name: \"microcredits\",\n     *       value_type: \"u64\"\n     *    }\n     * ]\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_mappings = credits_program.getMappings();\n     * console.log(credits_mappings === expected_mappings); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getMappings() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_getMappings(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a javascript object representation of a program record and its types\n     *\n     * @param {string} record_name Name of the record to get members for\n     * @returns {Object} Object containing the record name, type, and members\n     *\n     * @example\n     *\n     * const expected_record = {\n     *     type: \"record\",\n     *     record: \"Credits\",\n     *     members: [\n     *       {\n     *         name: \"owner\",\n     *         type: \"address\",\n     *         visibility: \"private\"\n     *       },\n     *       {\n     *         name: \"microcredits\",\n     *         type: \"u64\",\n     *         visibility: \"private\"\n     *       }\n     *     ];\n     *  };\n     *\n     * const credits_program = aleo_wasm.Program.getCreditsProgram();\n     * const credits_record = credits_program.getRecordMembers(\"Credits\");\n     * console.log(credits_record === expected_record); // Output should be \"true\"\n     * @param {string} record_name\n     * @returns {object}\n     */\n    getRecordMembers(record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getRecordMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a javascript object representation of a program struct and its types\n     *\n     * @param {string} struct_name Name of the struct to get members for\n     * @returns {Array} Array containing the struct members\n     *\n     * @example\n     *\n     * const STRUCT_PROGRAM = \"program token_issue.aleo;\n     *\n     * struct token_metadata:\n     *     network as u32;\n     *     version as u32;\n     *\n     * struct token:\n     *     token_id as u32;\n     *     metadata as token_metadata;\n     *\n     * function no_op:\n     *    input r0 as u64;\n     *    output r0 as u64;\"\n     *\n     * const expected_struct_members = [\n     *    {\n     *      name: \"token_id\",\n     *      type: \"u32\",\n     *    },\n     *    {\n     *      name: \"metadata\",\n     *      type: \"struct\",\n     *      struct_id: \"token_metadata\",\n     *      members: [\n     *       {\n     *         name: \"network\",\n     *         type: \"u32\",\n     *       }\n     *       {\n     *         name: \"version\",\n     *         type: \"u32\",\n     *       }\n     *     ]\n     *   }\n     * ];\n     *\n     * const program = aleo_wasm.Program.fromString(STRUCT_PROGRAM);\n     * const struct_members = program.getStructMembers(\"token\");\n     * console.log(struct_members === expected_struct_members); // Output should be \"true\"\n     * @param {string} struct_name\n     * @returns {Array<any>}\n     */\n    getStructMembers(struct_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(struct_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getStructMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the credits.aleo program\n     *\n     * @returns {Program} The credits.aleo program\n     * @returns {Program}\n     */\n    static getCreditsProgram() {\n        const ret = wasm.program_getCreditsProgram();\n        return Program.__wrap(ret);\n    }\n    /**\n     * Get the id of the program\n     *\n     * @returns {string} The id of the program\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get a unique address of the program\n     *\n     * @returns {Address} The address of the program\n     * @returns {Address}\n     */\n    address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_address(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Determine equality with another program\n     *\n     * @param {Program} other The other program to compare\n     * @returns {boolean} True if the programs are equal, false otherwise\n     * @param {Program} other\n     * @returns {boolean}\n     */\n    isEqual(other) {\n        _assertClass(other, Program);\n        const ret = wasm.program_isEqual(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get program_imports\n     *\n     * @returns {Array} The program imports\n     *\n     * @example\n     *\n     * const DOUBLE_TEST = \"import multiply_test.aleo;\n     *\n     * program double_test.aleo;\n     *\n     * function double_it:\n     *     input r0 as u32.private;\n     *     call multiply_test.aleo/multiply 2u32 r0 into r1;\n     *     output r1 as u32.private;\";\n     *\n     * const expected_imports = [\n     *    \"multiply_test.aleo\"\n     * ];\n     *\n     * const program = aleo_wasm.Program.fromString(DOUBLE_TEST_PROGRAM);\n     * const imports = program.getImports();\n     * console.log(imports === expected_imports); // Output should be \"true\"\n     * @returns {Array<any>}\n     */\n    getImports() {\n        const ret = wasm.program_getImports(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst ProgramManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_programmanager_free(ptr >>> 0, 1));\n\nclass ProgramManager {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProgramManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_programmanager_free(ptr, 0);\n    }\n    /**\n     * Deploy an Aleo program\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program being deployed\n     * @param imports A javascript object holding the source code of any imported programs in the\n     * form \\{\"program_name1\": \"program_source_code\", \"program_name2\": \"program_source_code\", ..\\}.\n     * Note that all imported programs must be deployed on chain before the main program in order\n     * for the deployment to succeed\n     * @param fee_credits The amount of credits to pay as a fee\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param imports (optional) Provide a list of imports to use for the program deployment in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {number} fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildDeploymentTransaction(private_key, program, fee_credits, fee_record, url, imports, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        let ptr1 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr1 = fee_record.__destroy_into_raw();\n        }\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr3 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr4 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildDeploymentTransaction(private_key.__wbg_ptr, ptr0, len0, fee_credits, ptr1, ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the fee for a program deployment\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param program The source code of the program being deployed\n     * @param imports (optional) Provide a list of imports to use for the deployment fee estimation\n     * in the form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @returns {u64}\n     * @param {string} program\n     * @param {object | null} [imports]\n     * @returns {Promise<bigint>}\n     */\n    static estimateDeploymentFee(program, imports) {\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_estimateDeploymentFee(ptr0, len0, isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the component of the deployment cost which comes from the fee for the program name.\n     * Note that this cost does not represent the entire cost of deployment. It is additional to\n     * the cost of the size (in bytes) of the deployment.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param name The name of the program to be deployed\n     * @returns {u64}\n     * @param {string} name\n     * @returns {bigint}\n     */\n    static estimateProgramNameCost(name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateProgramNameCost(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Execute an arbitrary function locally\n     *\n     * @param {PrivateKey} private_key The private key of the sender\n     * @param {string} program The source code of the program being executed\n     * @param {string} function The name of the function to execute\n     * @param {Array} inputs A javascript array of inputs to the function\n     * @param {boolean} prove_execution If true, the execution will be proven and an execution object\n     * containing the proof and the encrypted inputs and outputs needed to verify the proof offline\n     * will be returned.\n     * @param {boolean} cache Cache the proving and verifying keys in the Execution response.\n     * If this is set to 'true' the keys synthesized will be stored in the Execution Response\n     * and the `ProvingKey` and `VerifyingKey` can be retrieved from the response via the `.getKeys()`\n     * method.\n     * @param {Object | undefined} imports (optional) Provide a list of imports to use for the function execution in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param {ProvingKey | undefined} proving_key (optional) Provide a verifying key to use for the function execution\n     * @param {VerifyingKey | undefined} verifying_key (optional) Provide a verifying key to use for the function execution\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {boolean} prove_execution\n     * @param {boolean} cache\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {string | null} [url]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<ExecutionResponse>}\n     */\n    static executeFunctionOffline(private_key, program, _function, inputs, prove_execution, cache, imports, proving_key, verifying_key, url, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr2 = proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr3 = verifying_key.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_executeFunctionOffline(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), prove_execution, cache, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr2, ptr3, ptr4, len4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Execute Aleo function and create an Aleo execution transaction\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program being executed\n     * @param function The name of the function to execute\n     * @param inputs A javascript array of inputs to the function\n     * @param fee_credits The amount of credits to pay as a fee\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * If this is set to 'true' the keys synthesized (or passed in as optional parameters via the\n     * `proving_key` and `verifying_key` arguments) will be stored in the ProgramManager's memory\n     * and used for subsequent transactions. If this is set to 'false' the proving and verifying\n     * keys will be deallocated from memory after the transaction is executed.\n     * @param imports (optional) Provide a list of imports to use for the function execution in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param proving_key (optional) Provide a verifying key to use for the function execution\n     * @param verifying_key (optional) Provide a verifying key to use for the function execution\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {number} fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildExecutionTransaction(private_key, program, _function, inputs, fee_credits, fee_record, url, imports, proving_key, verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr4 = proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr5 = verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildExecutionTransaction(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), fee_credits, ptr2, ptr3, len3, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate Fee for Aleo function execution. Note if \"cache\" is set to true, the proving and\n     * verifying keys will be stored in the ProgramManager's memory and used for subsequent\n     * program executions.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param private_key The private key of the sender\n     * @param program The source code of the program to estimate the execution fee for\n     * @param function The name of the function to execute\n     * @param inputs A javascript array of inputs to the function\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param imports (optional) Provide a list of imports to use for the fee estimation in the\n     * form of a javascript object where the keys are a string of the program name and the values\n     * are a string representing the program source code \\{ \"hello.aleo\": \"hello.aleo source code\" \\}\n     * @param proving_key (optional) Provide a verifying key to use for the fee estimation\n     * @param verifying_key (optional) Provide a verifying key to use for the fee estimation\n     * @returns {u64} Fee in microcredits\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} _function\n     * @param {Array<any>} inputs\n     * @param {string | null} [url]\n     * @param {object | null} [imports]\n     * @param {ProvingKey | null} [proving_key]\n     * @param {VerifyingKey | null} [verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<bigint>}\n     */\n    static estimateExecutionFee(private_key, program, _function, inputs, url, imports, proving_key, verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        var ptr2 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr3 = proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr4 = verifying_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr5 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_estimateExecutionFee(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), ptr2, len2, isLikeNone(imports) ? 0 : addHeapObject(imports), ptr3, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n     * Estimate the finalize fee component for executing a function. This fee is additional to the\n     * size of the execution of the program in bytes. If the function does not have a finalize\n     * step, then the finalize fee is 0.\n     *\n     * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network\n     *\n     * @param program The program containing the function to estimate the finalize fee for\n     * @param function The function to estimate the finalize fee for\n     * @returns {u64} Fee in microcredits\n     * @param {string} program\n     * @param {string} _function\n     * @returns {bigint}\n     */\n    static estimateFinalizeFee(program, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_estimateFinalizeFee(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Join two records together to create a new record with an amount of credits equal to the sum\n     * of the credits of the two original records\n     *\n     * @param private_key The private key of the sender\n     * @param record_1 The first record to combine\n     * @param record_2 The second record to combine\n     * @param fee_credits The amount of credits to pay as a fee\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param join_proving_key (optional) Provide a proving key to use for the join function\n     * @param join_verifying_key (optional) Provide a verifying key to use for the join function\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction} Transaction object\n     * @param {PrivateKey} private_key\n     * @param {RecordPlaintext} record_1\n     * @param {RecordPlaintext} record_2\n     * @param {number} fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [join_proving_key]\n     * @param {VerifyingKey | null} [join_verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildJoinTransaction(private_key, record_1, record_2, fee_credits, fee_record, url, join_proving_key, join_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(record_1, RecordPlaintext);\n        var ptr0 = record_1.__destroy_into_raw();\n        _assertClass(record_2, RecordPlaintext);\n        var ptr1 = record_2.__destroy_into_raw();\n        let ptr2 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr2 = fee_record.__destroy_into_raw();\n        }\n        var ptr3 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(join_proving_key)) {\n            _assertClass(join_proving_key, ProvingKey);\n            ptr4 = join_proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(join_verifying_key)) {\n            _assertClass(join_verifying_key, VerifyingKey);\n            ptr5 = join_verifying_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr6 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr7 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr8 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildJoinTransaction(private_key.__wbg_ptr, ptr0, ptr1, fee_credits, ptr2, ptr3, len3, ptr4, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n     * Split an Aleo credits record into two separate records. This function does not require a fee.\n     *\n     * @param private_key The private key of the sender\n     * @param split_amount The amount of the credit split. This amount will be subtracted from the\n     * value of the record and two new records will be created with the split amount and the remainder\n     * @param amount_record The record to split\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param split_proving_key (optional) Provide a proving key to use for the split function\n     * @param split_verifying_key (optional) Provide a verifying key to use for the split function\n     * @returns {Transaction} Transaction object\n     * @param {PrivateKey} private_key\n     * @param {number} split_amount\n     * @param {RecordPlaintext} amount_record\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [split_proving_key]\n     * @param {VerifyingKey | null} [split_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildSplitTransaction(private_key, split_amount, amount_record, url, split_proving_key, split_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        _assertClass(amount_record, RecordPlaintext);\n        var ptr0 = amount_record.__destroy_into_raw();\n        var ptr1 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(split_proving_key)) {\n            _assertClass(split_proving_key, ProvingKey);\n            ptr2 = split_proving_key.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(split_verifying_key)) {\n            _assertClass(split_verifying_key, VerifyingKey);\n            ptr3 = split_verifying_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr4 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildSplitTransaction(private_key.__wbg_ptr, split_amount, ptr0, ptr1, len1, ptr2, ptr3, ptr4);\n        return takeObject(ret);\n    }\n    /**\n     * Send credits from one Aleo account to another\n     *\n     * @param private_key The private key of the sender\n     * @param amount_credits The amount of credits to send\n     * @param recipient The recipient of the transaction\n     * @param transfer_type The type of the transfer (options: \"private\", \"public\", \"private_to_public\", \"public_to_private\")\n     * @param amount_record The record to fund the amount from\n     * @param fee_credits The amount of credits to pay as a fee\n     * @param fee_record The record to spend the fee from\n     * @param url The url of the Aleo network node to send the transaction to\n     * @param transfer_verifying_key (optional) Provide a verifying key to use for the transfer\n     * function\n     * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n     * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n     * @returns {Transaction}\n     * @param {PrivateKey} private_key\n     * @param {number} amount_credits\n     * @param {string} recipient\n     * @param {string} transfer_type\n     * @param {RecordPlaintext | null | undefined} amount_record\n     * @param {number} fee_credits\n     * @param {RecordPlaintext | null} [fee_record]\n     * @param {string | null} [url]\n     * @param {ProvingKey | null} [transfer_proving_key]\n     * @param {VerifyingKey | null} [transfer_verifying_key]\n     * @param {ProvingKey | null} [fee_proving_key]\n     * @param {VerifyingKey | null} [fee_verifying_key]\n     * @param {OfflineQuery | null} [offline_query]\n     * @returns {Promise<Transaction>}\n     */\n    static buildTransferTransaction(private_key, amount_credits, recipient, transfer_type, amount_record, fee_credits, fee_record, url, transfer_proving_key, transfer_verifying_key, fee_proving_key, fee_verifying_key, offline_query) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(recipient, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(transfer_type, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(amount_record)) {\n            _assertClass(amount_record, RecordPlaintext);\n            ptr2 = amount_record.__destroy_into_raw();\n        }\n        let ptr3 = 0;\n        if (!isLikeNone(fee_record)) {\n            _assertClass(fee_record, RecordPlaintext);\n            ptr3 = fee_record.__destroy_into_raw();\n        }\n        var ptr4 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(transfer_proving_key)) {\n            _assertClass(transfer_proving_key, ProvingKey);\n            ptr5 = transfer_proving_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(transfer_verifying_key)) {\n            _assertClass(transfer_verifying_key, VerifyingKey);\n            ptr6 = transfer_verifying_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr7 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr8 = fee_verifying_key.__destroy_into_raw();\n        }\n        let ptr9 = 0;\n        if (!isLikeNone(offline_query)) {\n            _assertClass(offline_query, OfflineQuery);\n            ptr9 = offline_query.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_buildTransferTransaction(private_key.__wbg_ptr, amount_credits, ptr0, len0, ptr1, len1, ptr2, fee_credits, ptr3, ptr4, len4, ptr5, ptr6, ptr7, ptr8, ptr9);\n        return takeObject(ret);\n    }\n    /**\n     * Synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code of the program to synthesize keys for\n     * @param function_id {string} The function to synthesize keys for\n     * @param inputs {Array} The inputs to the function\n     * @param imports {Object | undefined} The imports for the program\n     * @param {PrivateKey} private_key\n     * @param {string} program\n     * @param {string} function_id\n     * @param {Array<any>} inputs\n     * @param {object | null} [imports]\n     * @returns {Promise<KeyPair>}\n     */\n    static synthesizeKeyPair(private_key, program, function_id, inputs, imports) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passStringToWasm0(program, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(function_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.programmanager_synthesizeKeyPair(private_key.__wbg_ptr, ptr0, len0, ptr1, len1, addHeapObject(inputs), isLikeNone(imports) ? 0 : addHeapObject(imports));\n        return takeObject(ret);\n    }\n}\n\nconst ProvingKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_provingkey_free(ptr >>> 0, 1));\n/**\n * Proving key for a function within an Aleo program\n */\nclass ProvingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvingKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ProvingKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProvingKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_provingkey_free(ptr, 0);\n    }\n    /**\n     * Verify if the proving key is for the bond_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"bond_public_proving_key.bin\");\n     * provingKey.isBondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the bond_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isBondPublicProver() {\n        const ret = wasm.provingkey_isBondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the bond_validator function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"bond_validator_proving_key.bin\");\n     * provingKey.isBondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the bond_validator function, false if otherwise\n     * @returns {boolean}\n     */\n    isBondValidatorProver() {\n        const ret = wasm.provingkey_isBondValidatorProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the claim_unbond function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"claim_unbond_proving_key.bin\");\n     * provingKey.isClaimUnbondProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the claim_unbond function, false if otherwise\n     * @returns {boolean}\n     */\n    isClaimUnbondPublicProver() {\n        const ret = wasm.provingkey_isClaimUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the fee_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"fee_private_proving_key.bin\");\n     * provingKey.isFeePrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the fee_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isFeePrivateProver() {\n        const ret = wasm.provingkey_isFeePrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the fee_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"fee_public_proving_key.bin\");\n     * provingKey.isFeePublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the fee_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isFeePublicProver() {\n        const ret = wasm.provingkey_isFeePublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the inclusion function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"inclusion_proving_key.bin\");\n     * provingKey.isInclusionProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the inclusion function, false if otherwise\n     * @returns {boolean}\n     */\n    isInclusionProver() {\n        const ret = wasm.provingkey_isInclusionProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the join function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"join_proving_key.bin\");\n     * provingKey.isJoinProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the join function, false if otherwise\n     * @returns {boolean}\n     */\n    isJoinProver() {\n        const ret = wasm.provingkey_isJoinProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the set_validator_state function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"set_validator_set_proving_key.bin\");\n     * provingKey.isSetValidatorStateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the set_validator_state function, false if otherwise\n     * @returns {boolean}\n     */\n    isSetValidatorStateProver() {\n        const ret = wasm.provingkey_isSetValidatorStateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the split function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"split_proving_key.bin\");\n     * provingKey.isSplitProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the split function, false if otherwise\n     * @returns {boolean}\n     */\n    isSplitProver() {\n        const ret = wasm.provingkey_isSplitProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_private_proving_key.bin\");\n     * provingKey.isTransferPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPrivateProver() {\n        const ret = wasm.provingkey_isTransferPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_private_to_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_private_to_public_proving_key.bin\");\n     * provingKey.isTransferPrivateToPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_private_to_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPrivateToPublicProver() {\n        const ret = wasm.provingkey_isTransferPrivateToPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_proving_key.bin\");\n     * provingKey.isTransferPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicProver() {\n        const ret = wasm.provingkey_isTransferPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public_as_signer function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_as_signer_proving_key.bin\");\n     * provingKey.isTransferPublicAsSignerProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicAsSignerProver() {\n        const ret = wasm.provingkey_isTransferPublicAsSignerProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the transfer_public_to_private function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"transfer_public_to_private_proving_key.bin\");\n     * provingKey.isTransferPublicToPrivateProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the transfer_public_to_private function, false if otherwise\n     * @returns {boolean}\n     */\n    isTransferPublicToPrivateProver() {\n        const ret = wasm.provingkey_isTransferPublicToPrivateProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verify if the proving key is for the unbond_public function\n     *\n     * @example\n     * const provingKey = ProvingKey.fromBytes(\"unbond_public.bin\");\n     * provingKey.isUnbondPublicProver() ? console.log(\"Key verified\") : throw new Error(\"Invalid key\");\n     *\n     * @returns {boolean} returns true if the proving key is for the unbond_public_prover function, false if otherwise\n     * @returns {boolean}\n     */\n    isUnbondPublicProver() {\n        const ret = wasm.provingkey_isUnbondPublicProver(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Return the checksum of the proving key\n     *\n     * @returns {string} Checksum of the proving key\n     * @returns {string}\n     */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a copy of the proving key\n     *\n     * @returns {ProvingKey} A copy of the proving key\n     * @returns {ProvingKey}\n     */\n    copy() {\n        const ret = wasm.provingkey_copy(this.__wbg_ptr);\n        return ProvingKey.__wrap(ret);\n    }\n    /**\n     * Construct a new proving key from a byte array\n     *\n     * @param {Uint8Array} bytes Byte array representation of a proving key\n     * @returns {ProvingKey}\n     * @param {Uint8Array} bytes\n     * @returns {ProvingKey}\n     */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_3);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a proving key from string\n     *\n     * @param {string} String representation of the proving key\n     * @param {string} string\n     * @returns {ProvingKey}\n     */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return the byte representation of a proving key\n     *\n     * @returns {Uint8Array} Byte array representation of a proving key\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_2(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the proving key\n     *\n     * @returns {string} String representation of the proving key\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst RecordCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_recordciphertext_free(ptr >>> 0, 1));\n/**\n * Encrypted Aleo record\n */\nclass RecordCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n        RecordCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RecordCiphertextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordciphertext_free(ptr, 0);\n    }\n    /**\n     * Create a record ciphertext from a string\n     *\n     * @param {string} record String representation of a record ciphertext\n     * @returns {RecordCiphertext} Record ciphertext\n     * @param {string} record\n     * @returns {RecordCiphertext}\n     */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return the string reprensentation of the record ciphertext\n     *\n     * @returns {string} String representation of the record ciphertext\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Decrypt the record ciphertext into plaintext using the view key. The record will only\n     * decrypt if the record was encrypted by the account corresponding to the view key\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     * @returns {RecordPlaintext} Record plaintext object\n     * @param {ViewKey} view_key\n     * @returns {RecordPlaintext}\n     */\n    decrypt(view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            wasm.recordciphertext_decrypt(retptr, this.__wbg_ptr, view_key.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Determines if the account corresponding to the view key is the owner of the record\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     * @returns {boolean}\n     * @param {ViewKey} view_key\n     * @returns {boolean}\n     */\n    isOwner(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.recordciphertext_isOwner(this.__wbg_ptr, view_key.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the tag of the record using the graph key.\n     *\n     * @param {GraphKey} graph key of the account associatd with the record.\n     * @param {Field} commitment of the record.\n     *\n     * @returns {Field} tag of the record.\n     * @param {GraphKey} graph_key\n     * @param {Field} commitment\n     * @returns {Field}\n     */\n    static tag(graph_key, commitment) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(graph_key, GraphKey);\n            _assertClass(commitment, Field);\n            var ptr0 = commitment.__destroy_into_raw();\n            wasm.recordciphertext_tag(retptr, graph_key.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RecordPlaintextFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_recordplaintext_free(ptr >>> 0, 1));\n/**\n * Plaintext representation of an Aleo record\n */\nclass RecordPlaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordPlaintext.prototype);\n        obj.__wbg_ptr = ptr;\n        RecordPlaintextFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RecordPlaintextFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordplaintext_free(ptr, 0);\n    }\n    /**\n     * @param {string} program_id\n     * @param {string} record_name\n     * @returns {Field}\n     */\n    commitment(program_id, record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_commitment(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Return a record plaintext from a string.\n     *\n     * @param {string} record String representation of a plaintext representation of an Aleo record\n     * @returns {RecordPlaintext} Record plaintext\n     * @param {string} record\n     * @returns {RecordPlaintext}\n     */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {string} input\n     * @returns {Plaintext}\n     */\n    getMember(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_getMember(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Plaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the owner of the record.\n     * @returns {Address}\n     */\n    owner() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_owner(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a representation of a record as a javascript object for usage in client side\n     * computations. Note that this is not a reversible operation and exists for the convenience\n     * of discovering and using properties of the record.\n     *\n     * The conversion guide is as follows:\n     * - u8, u16, u32, i8, i16 i32 --> Number\n     * - u64, u128, i64, i128 --> BigInt\n     * - Address, Field, Group, Scalar --> String.\n     *\n     * Address, Field, Group, and Scalar will all be converted to their bech32 string\n     * representation. These string representations can be converted back to their respective wasm\n     * types using the fromString method on the Address, Field, Group, and Scalar objects in this\n     * library.\n     *\n     * @example\n     * # Create a wasm record from a record string.\n     * let record_plaintext_wasm = RecordPlainext.from_string(\"{\n     *   owner: aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48.private,\n     *   metadata: {\n     *     player1: aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48.private,\n     *     player2: aleo1dreuxnmg9cny8ee9v2u0wr4v4affnwm09u2pytfwz0f2en2shgqsdsfjn6.private,\n     *     nonce: 660310649780728486489183263981322848354071976582883879926426319832534836534field.private\n     *   },\n     *   id: 1953278585719525811355617404139099418855053112960441725284031425961000152405field.private,\n     *   positions: 50794271u64.private,\n     *   attempts: 0u64.private,\n     *   hits: 0u64.private,\n     *   _nonce: 5668100912391182624073500093436664635767788874314097667746354181784048204413group.public\n     * }\");\n     *\n     * let expected_object = {\n     *   owner: \"aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48\",\n     *   metadata: {\n     *     player1: \"aleo1kh5t7m30djl0ecdn4f5vuzp7dx0tcwh7ncquqjkm4matj2p2zqpqm6at48\",\n     *     player2: \"aleo1dreuxnmg9cny8ee9v2u0wr4v4affnwm09u2pytfwz0f2en2shgqsdsfjn6\",\n     *     nonce: \"660310649780728486489183263981322848354071976582883879926426319832534836534field\"\n     *   },\n     *   id: \"1953278585719525811355617404139099418855053112960441725284031425961000152405field\",\n     *   positions: 50794271,\n     *   attempts: 0,\n     *   hits: 0,\n     *   _nonce: \"5668100912391182624073500093436664635767788874314097667746354181784048204413group\"\n     * };\n     *\n     * # Create the expected object\n     * let record_plaintext_object = record_plaintext_wasm.to_js_object();\n     * assert(JSON.stringify(record_plaintext_object) == JSON.stringify(expected_object));\n     *\n     * @returns {Object} Javascript object representation of the record\n     * @returns {object}\n     */\n    toJsObject() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toJsObject(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the record plaintext string\n     *\n     * @returns {string} String representation of the record plaintext\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns the amount of microcredits in the record\n     *\n     * @returns {u64} Amount of microcredits in the record\n     * @returns {bigint}\n     */\n    microcredits() {\n        const ret = wasm.recordplaintext_microcredits(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the nonce of the record. This can be used to uniquely identify a record.\n     *\n     * @returns {string} Nonce of the record\n     * @returns {string}\n     */\n    nonce() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_nonce(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Attempt to get the serial number of a record to determine whether or not is has been spent\n     *\n     * @param {PrivateKey} private_key Private key of the account that owns the record\n     * @param {string} program_id Program ID of the program that the record is associated with\n     * @param {string} record_name Name of the record\n     *\n     * @returns {string} Serial number of the record\n     * @param {PrivateKey} private_key\n     * @param {string} program_id\n     * @param {string} record_name\n     * @returns {string}\n     */\n    serialNumberString(private_key, program_id, record_name) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_serialNumberString(retptr, this.__wbg_ptr, private_key.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr3 = r0;\n            var len3 = r1;\n            if (r3) {\n                ptr3 = 0; len3 = 0;\n                throw takeObject(r2);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred4_0, deferred4_1, 1);\n        }\n    }\n    /**\n     * Get the tag of the record using the graph key.\n     * @param {GraphKey} graph_key\n     * @param {Field} commitment\n     * @returns {Field}\n     */\n    tag(graph_key, commitment) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(graph_key, GraphKey);\n            _assertClass(commitment, Field);\n            var ptr0 = commitment.__destroy_into_raw();\n            wasm.recordplaintext_tag(retptr, this.__wbg_ptr, graph_key.__wbg_ptr, ptr0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Field.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst ScalarFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_scalar_free(ptr >>> 0, 1));\n/**\n * Scalar field element.\n */\nclass Scalar {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Scalar.prototype);\n        obj.__wbg_ptr = ptr;\n        ScalarFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ScalarFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scalar_free(ptr, 0);\n    }\n    /**\n     * Creates a scalar object from a string representation of a scalar element.\n     * @param {string} group\n     * @returns {Scalar}\n     */\n    static fromString(group) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(group, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.scalar_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns the string representation of the scalar element.\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a scalar element from a Uint8Array of left endian bytes.\n     * @param {Uint8Array} bytes\n     * @returns {Scalar}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_fromBytesLe(retptr, addBorrowedObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Encode the scalar element as a Uint8Array of left endian bytes.\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Reconstruct a scalar element from a boolean array representation.\n     * @param {Array<any>} bits\n     * @returns {Scalar}\n     */\n    static fromBitsLe(bits) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scalar_fromBitsLe(retptr, addBorrowedObject(bits));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Scalar.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Get the left endian boolean array representation of the scalar element.\n     * @returns {Array<any>}\n     */\n    toBitsLe() {\n        const ret = wasm.scalar_toBitsLe(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Create a plaintext element from a scalar element.\n     * @returns {Plaintext}\n     */\n    toPlaintext() {\n        const ret = wasm.scalar_toPlaintext(this.__wbg_ptr);\n        return Plaintext.__wrap(ret);\n    }\n    /**\n     * Clone the scalar element.\n     * @returns {Scalar}\n     */\n    clone() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Generate a random scalar element.\n     * @returns {Scalar}\n     */\n    static random() {\n        const ret = wasm.scalar_random();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Add two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    add(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_add(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Subtract two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    subtract(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_subtract(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Multiply two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    multiply(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_multiply(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Divide two scalar elements.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    divide(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_divide(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Double the scalar element.\n     * @returns {Scalar}\n     */\n    double() {\n        const ret = wasm.scalar_double(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Power of a scalar element.\n     * @param {Scalar} other\n     * @returns {Scalar}\n     */\n    pow(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.scalar_pow(this.__wbg_ptr, other.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Invert the scalar element.\n     * @returns {Scalar}\n     */\n    inverse() {\n        const ret = wasm.scalar_inverse(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the multiplicative identity of the scalar field.\n     * @returns {Scalar}\n     */\n    static one() {\n        const ret = wasm.scalar_one();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the additive identity of the scalar field.\n     * @returns {Scalar}\n     */\n    static zero() {\n        const ret = wasm.field_zero();\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Check if one scalar element equals another.\n     * @param {Scalar} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        _assertClass(other, Scalar);\n        const ret = wasm.field_equals(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst SignatureFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr >>> 0, 1));\n/**\n * Cryptographic signature of a message signed by an Aleo account\n */\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n        SignatureFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SignatureFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr, 0);\n    }\n    /**\n     * Sign a message with a private key\n     *\n     * @param {PrivateKey} private_key The private key to sign the message with\n     * @param {Uint8Array} message Byte representation of the message to sign\n     * @returns {Signature} Signature of the message\n     * @param {PrivateKey} private_key\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     */\n    static sign(private_key, message) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(private_key.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get an address from a signature.\n     *\n     * @returns {Address} Address object\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.signature_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the challenge of a signature.\n     * @returns {Scalar}\n     */\n    challenge() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Get the response of a signature.\n     * @returns {Scalar}\n     */\n    response() {\n        const ret = wasm.signature_response(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Verify a signature of a message with an address\n     *\n     * @param {Address} address The address to verify the signature with\n     * @param {Uint8Array} message Byte representation of the message to verify\n     * @returns {boolean} True if the signature is valid, false otherwise\n     * @param {Address} address\n     * @param {Uint8Array} message\n     * @returns {boolean}\n     */\n    verify(address, message) {\n        _assertClass(address, Address);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_export_3);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_verify(this.__wbg_ptr, address.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n     * Get a signature from a string representation of a signature\n     *\n     * @param {string} signature String representation of a signature\n     * @returns {Signature} Signature\n     * @param {string} signature\n     * @returns {Signature}\n     */\n    static from_string(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_from_string(ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a signature\n     *\n     * @returns {string} String representation of a signature\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst TransactionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transaction_free(ptr >>> 0, 1));\n/**\n * Webassembly Representation of an Aleo transaction\n *\n * This object is created when generating an on-chain function deployment or execution and is the\n * object that should be submitted to the Aleo Network in order to deploy or execute a function.\n */\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n        TransactionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransactionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr, 0);\n    }\n    /**\n     * Create a transaction from a string\n     *\n     * @param {string} transaction String representation of a transaction\n     * @returns {Transaction}\n     * @param {string} transaction\n     * @returns {Transaction}\n     */\n    static fromString(transaction) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transaction, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a transaction from a Uint8Array of left endian bytes.\n     *\n     * @param {Uint8Array} Uint8Array of left endian bytes encoding a Transaction.\n     * @returns {Transaction}\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the transaction as a string. If you want to submit this transaction to the Aleo Network\n     * this function will create the string that should be submitted in the `POST` data.\n     *\n     * @returns {string} String representation of the transaction\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transaction as a Uint8Array of left endian bytes.\n     *\n     * @returns {Uint8Array} Uint8Array representation of the transaction\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Returns true if the transaction contains the given serial number.\n     *\n     * @param {boolean} True if the transaction contains the given serial number.\n     * @param {Field} serial_number\n     * @returns {boolean}\n     */\n    constainsSerialNumber(serial_number) {\n        _assertClass(serial_number, Field);\n        const ret = wasm.transaction_constainsSerialNumber(this.__wbg_ptr, serial_number.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction contains the given commitment.\n     *\n     * @param {boolean} True if the transaction contains the given commitment.\n     * @param {Field} commitment\n     * @returns {boolean}\n     */\n    constainsCommitment(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transaction_constainsCommitment(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Find a record in the transaction by the record's commitment.\n     * @param {Field} commitment\n     * @returns {RecordCiphertext | undefined}\n     */\n    findRecord(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transaction_findRecord(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret === 0 ? undefined : RecordCiphertext.__wrap(ret);\n    }\n    /**\n     * Returns the transaction's base fee.\n     * @returns {bigint}\n     */\n    baseFeeAmount() {\n        const ret = wasm.transaction_baseFeeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the transaction's total fee.\n     * @returns {bigint}\n     */\n    feeAmount() {\n        const ret = wasm.transaction_feeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns the transaction's priority fee.\n     *\n     * returns {bigint} The transaction's priority fee.\n     * @returns {bigint}\n     */\n    priorityFeeAmount() {\n        const ret = wasm.transaction_priorityFeeAmount(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n     * Returns true if the transaction is a deployment transaction.\n     *\n     * @returns {boolean} True if the transaction is a deployment transaction\n     * @returns {boolean}\n     */\n    isDeploy() {\n        const ret = wasm.transaction_isDeploy(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction is an execution transaction.\n     *\n     * @returns {boolean} True if the transaction is an execution transaction\n     * @returns {boolean}\n     */\n    isExecute() {\n        const ret = wasm.transaction_isExecute(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns true if the transaction is a fee transaction.\n     *\n     * @returns {boolean} True if the transaction is a fee transaction\n     * @returns {boolean}\n     */\n    isFee() {\n        const ret = wasm.transaction_isFee(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns the program deployed within the transaction if the transaction is a deployment\n     * transaction.\n     *\n     * @returns {Program | undefined} The program deployed within the transaction.\n     * @returns {Program | undefined}\n     */\n    deployedProgram() {\n        const ret = wasm.transaction_deployedProgram(this.__wbg_ptr);\n        return ret === 0 ? undefined : Program.__wrap(ret);\n    }\n    /**\n     * Returns the execution within the transaction (if present).\n     *\n     * @returns {Execution | undefined} The execution within the transaction.\n     * @returns {Execution | undefined}\n     */\n    execution() {\n        const ret = wasm.transaction_execution(this.__wbg_ptr);\n        return ret === 0 ? undefined : Execution.__wrap(ret);\n    }\n    /**\n     * Get the record plaintext present in a transaction owned by a specific view key.\n     *\n     * @param {ViewKey} view_key View key used to decrypt the ciphertext\n     *\n     * @returns {Array<RecordPlaintext>} Array of record plaintext objects\n     * @param {ViewKey} view_key\n     * @returns {Array<any>}\n     */\n    ownedRecords(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transaction_ownedRecords(this.__wbg_ptr, view_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the records present in a transaction and their commitments.\n     *\n     * @returns {Array<{commitment: Field, record: RecordCiphertext}>} Array of record ciphertext objects\n     * @returns {Array<any>}\n     */\n    records() {\n        const ret = wasm.transaction_records(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get a summary of the transaction within a javascript object.\n     *\n     * If the transaction is an execution transaction, this function will return a list of the\n     * transitions and their inputs and outputs.\n     *\n     * If the transaction is a deployment transaction, this function will return the program id and\n     * a list of the functions and their verifying keys, constraint, and variable counts.\n     *\n     * @param {boolean} convert_to_js If true the inputs and outputs will be converted to JS objects,\n     * if false the inputs and outputs will be in wasm format.\n     *\n     * @returns {Object} Transaction summary\n     * @param {boolean} convert_to_js\n     * @returns {object}\n     */\n    summary(convert_to_js) {\n        const ret = wasm.transaction_summary(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.\n     *\n     * This value can be used to query the status of the transaction on the Aleo Network to see\n     * if it was successful. If successful, the transaction will be included in a block and this\n     * value can be used to lookup the transaction data on-chain.\n     *\n     * @returns {string} TransactionId\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the\n     * Get the type of the transaction (will return \"deploy\" or \"execute\")\n     *\n     * @returns {string} Transaction type\n     * @returns {string}\n     */\n    transactionType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionType(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transitions in a transaction.\n     *\n     * @returns {Array<Transition>} Array of transition objects\n     * @returns {Array<any>}\n     */\n    transitions() {\n        const ret = wasm.transaction_transitions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the verifying keys in a transaction.\n     *\n     * @returns {Array<Object>} Array of verifying keys.\n     * @returns {Array<any>}\n     */\n    verifyingKeys() {\n        const ret = wasm.transaction_verifyingKeys(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst TransitionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_transition_free(ptr >>> 0, 1));\n\nclass Transition {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transition.prototype);\n        obj.__wbg_ptr = ptr;\n        TransitionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TransitionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transition_free(ptr, 0);\n    }\n    /**\n     * Get the transition ID\n     *\n     * @returns {string} The transition ID\n     * @returns {string}\n     */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_id(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a transition from a string\n     *\n     * @param {string} transition String representation of a transition\n     * @returns {Transition}\n     * @param {string} transition\n     * @returns {Transition}\n     */\n    static fromString(transition) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transition, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transition_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transition.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a transition from a Uint8Array of left endian bytes.\n     *\n     * @param {Uint8Array} Uint8Array of left endian bytes encoding a Transition.\n     * @returns {Transition}\n     * @param {Uint8Array} bytes\n     * @returns {Transition}\n     */\n    static fromBytesLe(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_fromBytesLe(retptr, addHeapObject(bytes));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transition.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the transition as a string. If you want to submit this transition to the Aleo Network\n     * this function will create the string that should be submitted in the `POST` data.\n     *\n     * @returns {string} String representation of the transition\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the transition as a Uint8Array of left endian bytes.\n     *\n     * @returns {Uint8Array} Uint8Array representation of the transition\n     * @returns {Uint8Array}\n     */\n    toBytesLe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_toBytesLe(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the program ID of the transition.\n     * @returns {string}\n     */\n    programId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_programId(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the function name of the transition.\n     * @returns {string}\n     */\n    functionName() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transition_functionName(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Returns true if the transition contains the given commitment.\n     *\n     * @param {boolean} True if the transition contains the given commitment.\n     * @param {Field} commitment\n     * @returns {boolean}\n     */\n    containsCommitment(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transition_containsCommitment(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check if the transition contains a serial number.\n     *\n     * @param {Field} serial_number The serial number to check for\n     *\n     * @returns {bool} True if the transition contains a serial number, false otherwise\n     * @param {Field} serial_number\n     * @returns {boolean}\n     */\n    containsSerialNumber(serial_number) {\n        _assertClass(serial_number, Field);\n        const ret = wasm.transition_containsSerialNumber(this.__wbg_ptr, serial_number.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Find a record in the transition by the record's commitment.\n     * @param {Field} commitment\n     * @returns {RecordCiphertext | undefined}\n     */\n    findRecord(commitment) {\n        _assertClass(commitment, Field);\n        const ret = wasm.transition_findRecord(this.__wbg_ptr, commitment.__wbg_ptr);\n        return ret === 0 ? undefined : RecordCiphertext.__wrap(ret);\n    }\n    /**\n     * Get the record plaintext present in a transition owned by a specific view key.\n     *\n     * @param {ViewKey} view_key The view key of the record owner.\n     *\n     * @returns {Array<RecordPlaintext>} Array of record plaintext objects\n     * @param {ViewKey} view_key\n     * @returns {Array<any>}\n     */\n    ownedRecords(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transition_ownedRecords(this.__wbg_ptr, view_key.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the records present in a transition and their commitments.\n     *\n     * @returns {Array<{commitment: Field, record: RecordCiphertext}>} Array of record ciphertext objects\n     * @returns {Array<any>}\n     */\n    records() {\n        const ret = wasm.transition_records(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * Get the inputs of the transition.\n     *\n     * @param {bool} convert_to_js If true the inputs will be converted to JS objects, if false\n     * the inputs will be in wasm format.\n     *\n     * @returns {Array} Array of inputs\n     * @param {boolean} convert_to_js\n     * @returns {Array<any>}\n     */\n    inputs(convert_to_js) {\n        const ret = wasm.transition_inputs(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the outputs of the transition.\n     *\n     * @param {bool} convert_to_js If true the outputs will be converted to JS objects, if false\n     * the outputs will be in wasm format.\n     *\n     * @returns {Array} Array of outputs\n     * @param {boolean} convert_to_js\n     * @returns {Array<any>}\n     */\n    outputs(convert_to_js) {\n        const ret = wasm.transition_outputs(this.__wbg_ptr, convert_to_js);\n        return takeObject(ret);\n    }\n    /**\n     * Get the transition public key of the transition.\n     * @returns {Group}\n     */\n    tpk() {\n        const ret = wasm.computekey_pk_sig(this.__wbg_ptr);\n        return Group.__wrap(ret);\n    }\n    /**\n     * Get the transition view key of the transition.\n     * @param {ViewKey} view_key\n     * @returns {Field}\n     */\n    tvk(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.transition_tvk(this.__wbg_ptr, view_key.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the transition commitment of the transition.\n     * @returns {Field}\n     */\n    tcm() {\n        const ret = wasm.transition_tcm(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n    /**\n     * Get the transition signer commitment of the transition.\n     * @returns {Field}\n     */\n    scm() {\n        const ret = wasm.transition_scm(this.__wbg_ptr);\n        return Field.__wrap(ret);\n    }\n}\n\nconst VerifyingKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_verifyingkey_free(ptr >>> 0, 1));\n/**\n * Verifying key for a function within an Aleo program\n */\nclass VerifyingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VerifyingKey.prototype);\n        obj.__wbg_ptr = ptr;\n        VerifyingKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        VerifyingKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_verifyingkey_free(ptr, 0);\n    }\n    /**\n     * Returns the verifying key for the bond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_public function\n     * @returns {VerifyingKey}\n     */\n    static bondPublicVerifier() {\n        const ret = wasm.verifyingkey_bondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the bond_validator function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_validator function\n     * @returns {VerifyingKey}\n     */\n    static bondValidatorVerifier() {\n        const ret = wasm.verifyingkey_bondValidatorVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the claim_delegator function\n     *\n     * @returns {VerifyingKey} Verifying key for the claim_unbond_public function\n     * @returns {VerifyingKey}\n     */\n    static claimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_claimUnbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the fee_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the fee_private function\n     * @returns {VerifyingKey}\n     */\n    static feePrivateVerifier() {\n        const ret = wasm.verifyingkey_feePrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the fee_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the fee_public function\n     * @returns {VerifyingKey}\n     */\n    static feePublicVerifier() {\n        const ret = wasm.verifyingkey_feePublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the inclusion function\n     *\n     * @returns {VerifyingKey} Verifying key for the inclusion function\n     * @returns {VerifyingKey}\n     */\n    static inclusionVerifier() {\n        const ret = wasm.verifyingkey_inclusionVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the join function\n     *\n     * @returns {VerifyingKey} Verifying key for the join function\n     * @returns {VerifyingKey}\n     */\n    static joinVerifier() {\n        const ret = wasm.verifyingkey_joinVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the set_validator_state function\n     *\n     * @returns {VerifyingKey} Verifying key for the set_validator_state function\n     * @returns {VerifyingKey}\n     */\n    static setValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_setValidatorStateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the split function\n     *\n     * @returns {VerifyingKey} Verifying key for the split function\n     * @returns {VerifyingKey}\n     */\n    static splitVerifier() {\n        const ret = wasm.verifyingkey_splitVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_private function\n     * @returns {VerifyingKey}\n     */\n    static transferPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_private_to_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_private_to_public function\n     * @returns {VerifyingKey}\n     */\n    static transferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPrivateToPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicVerifier() {\n        const ret = wasm.verifyingkey_transferPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public_as_signer function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public_as_signer function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicAsSignerVerifier() {\n        const ret = wasm.verifyingkey_transferPublicAsSignerVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the transfer_public_to_private function\n     *\n     * @returns {VerifyingKey} Verifying key for the transfer_public_to_private function\n     * @returns {VerifyingKey}\n     */\n    static transferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_transferPublicToPrivateVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the unbond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the unbond_public function\n     * @returns {VerifyingKey}\n     */\n    static unbondPublicVerifier() {\n        const ret = wasm.verifyingkey_unbondPublicVerifier();\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Returns the verifying key for the bond_public function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_public function\n     * @returns {boolean}\n     */\n    isBondPublicVerifier() {\n        const ret = wasm.verifyingkey_isBondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Returns the verifying key for the bond_validator function\n     *\n     * @returns {VerifyingKey} Verifying key for the bond_validator function\n     * @returns {boolean}\n     */\n    isBondValidatorVerifier() {\n        const ret = wasm.verifyingkey_isBondValidatorVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the claim_delegator function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isClaimUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isClaimUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the fee_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isFeePrivateVerifier() {\n        const ret = wasm.verifyingkey_isFeePrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the fee_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isFeePublicVerifier() {\n        const ret = wasm.verifyingkey_isFeePublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the inclusion function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isInclusionVerifier() {\n        const ret = wasm.verifyingkey_isInclusionVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the join function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isJoinVerifier() {\n        const ret = wasm.verifyingkey_isJoinVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the set_validator_state function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isSetValidatorStateVerifier() {\n        const ret = wasm.verifyingkey_isSetValidatorStateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the split function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isSplitVerifier() {\n        const ret = wasm.verifyingkey_isSplitVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_private_to_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPrivateToPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPrivateToPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public_as_signer function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicAsSignerVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicAsSignerVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the transfer_public_to_private function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isTransferPublicToPrivateVerifier() {\n        const ret = wasm.verifyingkey_isTransferPublicToPrivateVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Verifies the verifying key is for the unbond_public function\n     *\n     * @returns {bool}\n     * @returns {boolean}\n     */\n    isUnbondPublicVerifier() {\n        const ret = wasm.verifyingkey_isUnbondPublicVerifier(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get the checksum of the verifying key\n     *\n     * @returns {string} Checksum of the verifying key\n     * @returns {string}\n     */\n    checksum() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_checksum(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Create a copy of the verifying key\n     *\n     * @returns {VerifyingKey} A copy of the verifying key\n     * @returns {VerifyingKey}\n     */\n    copy() {\n        const ret = wasm.verifyingkey_copy(this.__wbg_ptr);\n        return VerifyingKey.__wrap(ret);\n    }\n    /**\n     * Construct a new verifying key from a byte array\n     *\n     * @param {Uint8Array} bytes Byte representation of a verifying key\n     * @returns {VerifyingKey}\n     * @param {Uint8Array} bytes\n     * @returns {VerifyingKey}\n     */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_3);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a verifying key from string\n     *\n     * @param {String} string String representation of a verifying key\n     * @returns {VerifyingKey}\n     * @param {string} string\n     * @returns {VerifyingKey}\n     */\n    static fromString(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromString(retptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create a byte array from a verifying key\n     *\n     * @returns {Uint8Array} Byte representation of a verifying key\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_2(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get a string representation of the verifying key\n     *\n     * @returns {String} String representation of the verifying key\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toString(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst ViewKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_viewkey_free(ptr >>> 0, 1));\n\nclass ViewKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewKey.prototype);\n        obj.__wbg_ptr = ptr;\n        ViewKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ViewKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewkey_free(ptr, 0);\n    }\n    /**\n     * Create a new view key from a private key\n     *\n     * @param {PrivateKey} private_key Private key\n     * @returns {ViewKey} View key\n     * @param {PrivateKey} private_key\n     * @returns {ViewKey}\n     */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.privatekey_to_view_key(private_key.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Create a new view key from a string representation of a view key\n     *\n     * @param {string} view_key String representation of a view key\n     * @returns {ViewKey} View key\n     * @param {string} view_key\n     * @returns {ViewKey}\n     */\n    static from_string(view_key) {\n        const ptr0 = passStringToWasm0(view_key, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewkey_from_string(ptr0, len0);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n     * Get a string representation of a view key\n     *\n     * @returns {string} String representation of a view key\n     * @returns {string}\n     */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get the address corresponding to a view key\n     *\n     * @returns {Address} Address\n     * @returns {Address}\n     */\n    to_address() {\n        const ret = wasm.address_from_view_key(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n     * Get the underlying scalar of a view key.\n     * @returns {Scalar}\n     */\n    to_scalar() {\n        const ret = wasm.field_clone(this.__wbg_ptr);\n        return Scalar.__wrap(ret);\n    }\n    /**\n     * Decrypt a record ciphertext with a view key\n     *\n     * @param {string} ciphertext String representation of a record ciphertext\n     * @returns {string} String representation of a record plaintext\n     * @param {string} ciphertext\n     * @returns {string}\n     */\n    decrypt(ciphertext) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.viewkey_decrypt(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_2(deferred3_0, deferred3_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_address_new = function(arg0) {\n        const ret = Address.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_arrayBuffer_d1b44c4390db422f = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).arrayBuffer();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_async_9ff6d9e405f13772 = function(arg0) {\n        const ret = getObject(arg0).async;\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_ciphertext_new = function(arg0) {\n        const ret = Ciphertext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_data_432d9c3df2630942 = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_export_2(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_executionresponse_new = function(arg0) {\n        const ret = ExecutionResponse.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_f1856afdb49415d1 = function(arg0) {\n        const ret = fetch(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_field_new = function(arg0) {\n        const ret = Field.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_field_unwrap = function(arg0) {\n        const ret = Field.__unwrap(takeObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_group_new = function(arg0) {\n        const ret = Group.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_a5ea9117f258a0ec = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keypair_new = function(arg0) {\n        const ret = KeyPair.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_log_1af7ae7bd9c6ae19 = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_491(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_86231e225ca6b962 = function() { return handleError(function () {\n        const ret = new XMLHttpRequest();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_b1a33e5095abf678 = function() { return handleError(function (arg0, arg1) {\n        const ret = new Worker(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_e25e5aab09ff45db = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_e9a4a67dbababe57 = function(arg0) {\n        const ret = new Int32Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_c4c419ef0bc8a1f8 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_of_4a05197bfc89556f = function(arg0, arg1, arg2) {\n        const ret = Array.of(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_open_13a598ea50d82926 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n        getObject(arg0).open(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), arg5 !== 0);\n    }, arguments) };\n    imports.wbg.__wbg_overrideMimeType_36ce5eeae20aff9f = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).overrideMimeType(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_plaintext_new = function(arg0) {\n        const ret = Plaintext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_postMessage_6edafa8f7b9c2f52 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).postMessage(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_recordciphertext_new = function(arg0) {\n        const ret = RecordCiphertext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_recordplaintext_new = function(arg0) {\n        const ret = RecordPlaintext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_79b1e9274cde3c87 = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_responseText_ad050aa7f8afec9f = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg1).responseText;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    }, arguments) };\n    imports.wbg.__wbg_response_49e10f8ee7f418db = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).response;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_send_40a47636ff90f64d = function() { return handleError(function (arg0) {\n        getObject(arg0).send();\n    }, arguments) };\n    imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {\n        getObject(arg0).body = getObject(arg1);\n    };\n    imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {\n        getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];\n    };\n    imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {\n        getObject(arg0).headers = getObject(arg1);\n    };\n    imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {\n        getObject(arg0).method = getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {\n        getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];\n    };\n    imports.wbg.__wbg_setonmessage_5a885b16bdc6dca6 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {\n        getObject(arg0).signal = getObject(arg1);\n    };\n    imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_signature_new = function(arg0) {\n        const ret = Signature.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_spawnWorker_a8e0ffb747e264de = function(arg0, arg1, arg2, arg3) {\n        const ret = spawnWorker(getObject(arg0), getObject(arg1), getObject(arg2), arg3 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_status_12bcf88a8ff51470 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_new = function(arg0) {\n        const ret = Transaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transition_new = function(arg0) {\n        const ret = Transition.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_value_dab73d3d5d4abaaf = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_verifyingkey_new = function(arg0) {\n        const ret = VerifyingKey.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_61f0a081053dd3c2 = function(arg0, arg1, arg2) {\n        const ret = Atomics.waitAsync(getObject(arg0), arg1 >>> 0, arg2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_7ce6c8a047c752c3 = function() {\n        const ret = Atomics.waitAsync;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i128 = function(arg0, arg1) {\n        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u128 = function(arg0, arg1) {\n        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbindgen_closure_wrapper6041 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 519, __wbg_adapter_40);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6047 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 519, __wbg_adapter_40);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_link_9579f016b4522a24 = function(arg0) {\n        const val = `onmessage = function (ev) {\n            let [ia, index, value] = ev.data;\n            ia = new Int32Array(ia.buffer);\n            let result = Atomics.wait(ia, index, value);\n            postMessage(result);\n        };\n        `;\n        const ret = typeof URL.createObjectURL === 'undefined' ? \"data:application/javascript,\" + encodeURIComponent(val) : URL.createObjectURL(new Blob([val], { type: \"text/javascript\" }));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_module = function() {\n        const ret = __wbg_init.__wbindgen_wasm_module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_rethrow = function(arg0) {\n        throw takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_3, wasm.__wbindgen_export_4);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n    imports.wbg.memory = memory || new WebAssembly.Memory({initial:23,maximum:65536,shared:true});\n}\n\nfunction __wbg_finalize_init(instance, module, thread_stack_size) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n    if (typeof thread_stack_size !== 'undefined' && (typeof thread_stack_size !== 'number' || thread_stack_size === 0 || thread_stack_size % 65536 !== 0)) { throw 'invalid stack size' }\n    wasm.__wbindgen_start(thread_stack_size);\n    return wasm;\n}\n\nfunction initSync(module, memory) {\n    if (wasm !== undefined) return wasm;\n\n    let thread_stack_size;\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module, memory, thread_stack_size} = module);\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports, memory);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module, thread_stack_size);\n}\n\nasync function __wbg_init(module_or_path, memory) {\n    if (wasm !== undefined) return wasm;\n\n    let thread_stack_size;\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path, memory, thread_stack_size} = module_or_path);\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n        }\n    }\n\n\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports, memory);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module, thread_stack_size);\n}\n\nconst module$1 = /* asset import */ new __webpack_require__.U(__webpack_require__(/*! aleo_wasm.wasm */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/aleo_wasm.wasm\"));\n                \n                    await __wbg_init({ module_or_path: module$1 });\n\nasync function initThreadPool(threads) {\n    if (threads == null) {\n        threads = navigator.hardwareConcurrency;\n    }\n\n    console.info(`Spawning ${threads} threads`);\n\n    await initThreadPool$1(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! worker.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/worker.js\")), threads);\n}\n\n\n//# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErd2FzbUAwLjguNi9ub2RlX21vZHVsZXMvQHByb3ZhYmxlaHEvd2FzbS9kaXN0L3Rlc3RuZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJGQUEyRiw4QkFBOEIsTUFBTSxnQkFBZ0IsNkNBQTZDOztBQUU1TCwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZGQUE2RixnQkFBZ0IsNkNBQTZDOztBQUUxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsY0FBYztBQUN6QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsU0FBUztBQUMxQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFNBQVM7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsV0FBVztBQUM1QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixXQUFXO0FBQzVCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsc0JBQXNCO0FBQ3ZDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsc0JBQXNCO0FBQ3ZDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFlBQVk7QUFDN0IsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsc0JBQXNCO0FBQ3ZDLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsWUFBWTtBQUM3QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsc0JBQXNCO0FBQ3ZDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0ZBQW9GO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxpQkFBaUI7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSw0REFBNEQ7QUFDNUQsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsZUFBZTtBQUM5QixlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGVBQWUsWUFBWTtBQUMzQixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxlQUFlO0FBQzlCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQ0FBb0M7QUFDbkQsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsd0JBQXdCO0FBQ3ZDLGVBQWUsZUFBZTtBQUM5QixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLDJCQUEyQixRQUFRO0FBQ25DLHNCQUFzQixPQUFPO0FBQzdCLHVCQUF1QixvQkFBb0I7QUFDM0MsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixrQkFBa0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsaUJBQWlCO0FBQ2xDLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixpQkFBaUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsV0FBVztBQUM1QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsU0FBUztBQUN4QixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFdBQVc7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyw0Q0FBNEMsR0FBRztBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyw0Q0FBNEMsR0FBRztBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakIsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLEtBQUs7QUFDTCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMLHVFQUF1RTtBQUN2RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLQUFrSyx5QkFBeUI7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQscUNBQXFDO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkpBQTZKO0FBQzdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELFVBQVU7QUFDVix3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pELFVBQVU7QUFDVix1RkFBdUY7QUFDdkY7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBOztBQUVBLGlCQUFpQixzTUFBMEM7QUFDM0Q7QUFDQSx1Q0FBdUMsMEJBQTBCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsU0FBUzs7QUFFdEMsMkJBQTJCLDRMQUFxQztBQUNoRTs7QUFFd2Q7QUFDeGQiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXJuYW1lL2FsZW8vcmF0ZS1saW1pdGluZy1udWxsaWZpZXIvcmxuLW1lc3NhZ2UtYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm92YWJsZWhxK3dhc21AMC44LjYvbm9kZV9tb2R1bGVzL0Bwcm92YWJsZWhxL3dhc20vZGlzdC90ZXN0bmV0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHNwYXduV29ya2VyKHVybCwgbW9kdWxlLCBtZW1vcnksIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGluIE5vZGUgdG8gd2FpdCBvbmUgZXh0cmEgdGljaywgc28gdGhhdCB3YXlcbiAgICAgICAgICAgICAgICAvLyB0aGUgV29ya2VyIGNhbiBmdWxseSBpbml0aWFsaXplIGJlZm9yZSB3ZSByZXR1cm4uXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod29ya2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgaW4gTm9kZSwgdGhpcyBhbGxvd3MgdGhlIHByb2Nlc3MgdG8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGUgV29ya2VyIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JrZXIudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgICAgIG1lbW9yeSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxubGV0IHdhc207XG5cbmNvbnN0IGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHVuZGVmaW5lZCk7XG5cbmhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTtcblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5jb25zdCBjYWNoZWRUZXh0RGVjb2RlciA9ICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KSA6IHsgZGVjb2RlOiAoKSA9PiB7IHRocm93IEVycm9yKCdUZXh0RGVjb2RlciBub3QgYXZhaWxhYmxlJykgfSB9ICk7XG5cbmlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7IGNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpOyB9XG5sZXQgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OEFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkVWludDhBcnJheU1lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpIHtcbiAgICAgICAgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhBcnJheU1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc2xpY2UocHRyLCBwdHIgKyBsZW4pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKGFkZEhlYXBPYmplY3QoZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMTMyKSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxubGV0IFdBU01fVkVDVE9SX0xFTiA9IDA7XG5cbmNvbnN0IGNhY2hlZFRleHRFbmNvZGVyID0gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JykgOiB7IGVuY29kZTogKCkgPT4geyB0aHJvdyBFcnJvcignVGV4dEVuY29kZXIgbm90IGF2YWlsYWJsZScpIH0gfSApO1xuXG5jb25zdCBlbmNvZGVTdHJpbmcgPSBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIHBhc3NTdHJpbmdUb1dhc20wKGFyZywgbWFsbG9jLCByZWFsbG9jKSB7XG5cbiAgICBpZiAocmVhbGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZShhcmcpO1xuICAgICAgICBjb25zdCBwdHIgPSBtYWxsb2MoYnVmLmxlbmd0aCwgMSkgPj4+IDA7XG4gICAgICAgIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyLCBwdHIgKyBidWYubGVuZ3RoKS5zZXQoYnVmKTtcbiAgICAgICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBsZXQgcHRyID0gbWFsbG9jKGxlbiwgMSkgPj4+IDA7XG5cbiAgICBjb25zdCBtZW0gPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMywgMSkgPj4+IDA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciArIG9mZnNldCwgcHRyICsgbGVuKTtcbiAgICAgICAgY29uc3QgcmV0ID0gZW5jb2RlU3RyaW5nKGFyZywgdmlldyk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHJldC53cml0dGVuO1xuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBvZmZzZXQsIDEpID4+PiAwO1xuICAgIH1cblxuICAgIFdBU01fVkVDVE9SX0xFTiA9IG9mZnNldDtcbiAgICByZXR1cm4gcHRyO1xufVxuXG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGw7XG59XG5cbmxldCBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREYXRhVmlld01lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpIHtcbiAgICAgICAgY2FjaGVkRGF0YVZpZXdNZW1vcnkwID0gbmV3IERhdGFWaWV3KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWREYXRhVmlld01lbW9yeTA7XG59XG5cbmNvbnN0IENMT1NVUkVfRFRPUlMgPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoc3RhdGUgPT4ge1xuICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfNS5nZXQoc3RhdGUuZHRvcikoc3RhdGUuYSwgc3RhdGUuYik7XG59KTtcblxuZnVuY3Rpb24gbWFrZU11dENsb3N1cmUoYXJnMCwgYXJnMSwgZHRvciwgZikge1xuICAgIGNvbnN0IHN0YXRlID0geyBhOiBhcmcwLCBiOiBhcmcxLCBjbnQ6IDEsIGR0b3IgfTtcbiAgICBjb25zdCByZWFsID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgdXAgd2l0aCBhIGNsb3N1cmUgd2UgaW5jcmVtZW50IHRoZSBpbnRlcm5hbCByZWZlcmVuY2VcbiAgICAgICAgLy8gY291bnQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBSdXN0IGNsb3N1cmUgZW52aXJvbm1lbnQgd29uJ3RcbiAgICAgICAgLy8gYmUgZGVhbGxvY2F0ZWQgd2hpbGUgd2UncmUgaW52b2tpbmcgaXQuXG4gICAgICAgIHN0YXRlLmNudCsrO1xuICAgICAgICBjb25zdCBhID0gc3RhdGUuYTtcbiAgICAgICAgc3RhdGUuYSA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZihhLCBzdGF0ZS5iLCAuLi5hcmdzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgtLXN0YXRlLmNudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfNS5nZXQoc3RhdGUuZHRvcikoYSwgc3RhdGUuYik7XG4gICAgICAgICAgICAgICAgQ0xPU1VSRV9EVE9SUy51bnJlZ2lzdGVyKHN0YXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlYWwub3JpZ2luYWwgPSBzdGF0ZTtcbiAgICBDTE9TVVJFX0RUT1JTLnJlZ2lzdGVyKHJlYWwsIHN0YXRlLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHJlYWw7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzcyhpbnN0YW5jZSwga2xhc3MpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGluc3RhbmNlIG9mICR7a2xhc3MubmFtZX1gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheThUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiAxLCAxKSA+Pj4gMDtcbiAgICBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDEpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cbi8qKlxuICogVmVyaWZ5IGFuIGV4ZWN1dGlvbiB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGFuZCBhIHNpbmdsZSB0cmFuc2l0aW9uLiBFeGVjdXRpb25zIHdpdGggbXVsdGlwbGVcbiAqIHRyYW5zaXRpb25zIG9yIGZ1bmN0aW9ucyB3aWxsIGZhaWwgdG8gdmVyaWZ5LiBBbHNvLCB0aGlzIGRvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBzdGF0ZSByb290IG9mXG4gKiB0aGUgZXhlY3V0aW9uIGlzIGluY2x1ZGVkIGluIHRoZSBBbGVvIE5ldHdvcmsgbGVkZ2VyLlxuICpcbiAqIEBwYXJhbSB7RXhlY3V0aW9ufSBleGVjdXRpb24gVGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiB0byB2ZXJpZnlcbiAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5fSB2ZXJpZnlpbmdfa2V5IFRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7UHJvZ3JhbX0gcHJvZ3JhbSBUaGUgcHJvZ3JhbSB0aGF0IHRoZSBmdW5jdGlvbiBleGVjdXRpb24gYmVsb25ncyB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uX2lkIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHdhcyBleGVjdXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4ZWN1dGlvbiBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAcGFyYW0ge0V4ZWN1dGlvbn0gZXhlY3V0aW9uXG4gKiBAcGFyYW0ge1ZlcmlmeWluZ0tleX0gdmVyaWZ5aW5nX2tleVxuICogQHBhcmFtIHtQcm9ncmFtfSBwcm9ncmFtXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25faWRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2ZXJpZnlGdW5jdGlvbkV4ZWN1dGlvbihleGVjdXRpb24sIHZlcmlmeWluZ19rZXksIHByb2dyYW0sIGZ1bmN0aW9uX2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhleGVjdXRpb24sIEV4ZWN1dGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJvZ3JhbSwgUHJvZ3JhbSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChmdW5jdGlvbl9pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnZlcmlmeUZ1bmN0aW9uRXhlY3V0aW9uKHJldHB0ciwgZXhlY3V0aW9uLl9fd2JnX3B0ciwgdmVyaWZ5aW5nX2tleS5fX3diZ19wdHIsIHByb2dyYW0uX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjAgIT09IDA7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5VThGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gMSwgcHRyIC8gMSArIGxlbik7XG59XG5cbmxldCBzdGFja19wb2ludGVyID0gMTI4O1xuXG5mdW5jdGlvbiBhZGRCb3Jyb3dlZE9iamVjdChvYmopIHtcbiAgICBpZiAoc3RhY2tfcG9pbnRlciA9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiBqcyBzdGFjaycpO1xuICAgIGhlYXBbLS1zdGFja19wb2ludGVyXSA9IG9iajtcbiAgICByZXR1cm4gc3RhY2tfcG9pbnRlcjtcbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlY2VpdmVyXG4gKi9cbmZ1bmN0aW9uIHJ1blJheW9uVGhyZWFkKHJlY2VpdmVyKSB7XG4gICAgd2FzbS5ydW5SYXlvblRocmVhZChyZWNlaXZlcik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtudW1iZXJ9IG51bV90aHJlYWRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZnVuY3Rpb24gaW5pdFRocmVhZFBvb2wkMSh1cmwsIG51bV90aHJlYWRzKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5pbml0VGhyZWFkUG9vbChhZGRIZWFwT2JqZWN0KHVybCksIG51bV90aHJlYWRzKTtcbiAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xufVxuXG5mdW5jdGlvbiBfX3diZ19hZGFwdGVyXzQwKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzYoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSk7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2FkYXB0ZXJfNDkxKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzcoYXJnMCwgYXJnMSwgYWRkSGVhcE9iamVjdChhcmcyKSwgYWRkSGVhcE9iamVjdChhcmczKSk7XG59XG5cbmNvbnN0IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q3JlZGVudGlhbHMgPSBbXCJvbWl0XCIsIFwic2FtZS1vcmlnaW5cIiwgXCJpbmNsdWRlXCJdO1xuXG5jb25zdCBfX3diaW5kZ2VuX2VudW1fUmVxdWVzdE1vZGUgPSBbXCJzYW1lLW9yaWdpblwiLCBcIm5vLWNvcnNcIiwgXCJjb3JzXCIsIFwibmF2aWdhdGVcIl07XG5cbmNvbnN0IEFkZHJlc3NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfYWRkcmVzc19mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBQdWJsaWMgYWRkcmVzcyBvZiBhbiBBbGVvIGFjY291bnRcbiAqL1xuY2xhc3MgQWRkcmVzcyB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQWRkcmVzcy5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBBZGRyZXNzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEFkZHJlc3NGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2FkZHJlc3NfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmUgYW4gQWxlbyBhZGRyZXNzIGZyb20gYSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgdG8gZGVyaXZlIHRoZSBhZGRyZXNzIGZyb21cbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc30gQWRkcmVzcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXlcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbV9wcml2YXRlX2tleShwcml2YXRlX2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFkZHJlc3NfZnJvbV9wcml2YXRlX2tleShwcml2YXRlX2tleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVyaXZlIGFuIEFsZW8gYWRkcmVzcyBmcm9tIGEgdmlldyBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXkgVGhlIHZpZXcga2V5IHRvIGRlcml2ZSB0aGUgYWRkcmVzcyBmcm9tXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9IEFkZHJlc3MgY29ycmVzcG9uZGluZyB0byB0aGUgdmlldyBrZXlcbiAgICAgKiBAcGFyYW0ge1ZpZXdLZXl9IHZpZXdfa2V5XG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21fdmlld19rZXkodmlld19rZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHZpZXdfa2V5LCBWaWV3S2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hZGRyZXNzX2Zyb21fdmlld19rZXkodmlld19rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZSBhbiBBbGVvIGFkZHJlc3MgZnJvbSBhIGNvbXB1dGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb21wdXRlS2V5fSBjb21wdXRlX2tleSBUaGUgY29tcHV0ZSBrZXkgdG8gZGVyaXZlIHRoZSBhZGRyZXNzIGZyb21cbiAgICAgKiBAcGFyYW0ge0NvbXB1dGVLZXl9IGNvbXB1dGVfa2V5XG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21fY29tcHV0ZV9rZXkoY29tcHV0ZV9rZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbXB1dGVfa2V5LCBDb21wdXRlS2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hZGRyZXNzX2Zyb21fY29tcHV0ZV9rZXkoY29tcHV0ZV9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhbGVvIGFkZHJlc3Mgb2JqZWN0IGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFkZHJlc3NtXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9IEFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tX3N0cmluZyhhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhZGRyZXNzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWRkcmVzc19mcm9tX3N0cmluZyhwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBBbGVvIGFkZHJlc3Mgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IEFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvX3N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYWRkcmVzc190b19zdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgYSBzaWduYXR1cmUgZm9yIGEgbWVzc2FnZSBzaWduZWQgYnkgdGhlIGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gQnl0ZSBhcnJheSByZXByZXNlbnRpbmcgYSBtZXNzYWdlIHNpZ25lZCBieSB0aGUgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBCb29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKG1lc3NhZ2UsIHdhc20uX193YmluZGdlbl9leHBvcnRfMyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaWduYXR1cmUsIFNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYWRkcmVzc192ZXJpZnkodGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHNpZ25hdHVyZS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbn1cblxuY29uc3QgQkhQMTAyNEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iaHAxMDI0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEJIUDEwMjQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEJIUDEwMjQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQkhQMTAyNEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBCSFAxMDI0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19iaHAxMDI0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQkhQIGhhc2hlciB3aXRoIGFuIGlucHV0IHNpemUgb2YgMTAyNCBiaXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmJocDEwMjRfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBCSFAxMDI0RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJIUCBoYXNoZXIgd2l0aCBhbiBpbnB1dCBzaXplIG9mIDEwMjQgYml0cyB3aXRoIGEgY3VzdG9tIGRvbWFpbiBzZXBhcmF0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbl9zZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7QkhQMTAyNH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0dXAoZG9tYWluX3NlcGFyYXRvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZG9tYWluX3NlcGFyYXRvciwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uYmhwMTAyNF9zZXR1cChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQkhQMTAyNC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBCSFAgaGFzaCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiAxMDI0IGJpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBoYXNoKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYmhwMTAyNF9oYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgaGFzaCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiAxMDI0IGJpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBoYXNoVG9Hcm91cChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmJocDEwMjRfaGFzaFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJIUCBjb21taXRtZW50IHdpdGggYW4gaW5wdXQgaGFzaGVyIG9mIDEwMjQgYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgY29tbWl0KGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iaHAxMDI0X2NvbW1pdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQkhQIGNvbW1pdG1lbnQgd2l0aCBhbiBpbnB1dCBoYXNoZXIgb2YgMTAyNCBiaXRzIGFuZCByYW5kb21pemVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcGFyYW0ge1NjYWxhcn0gcmFuZG9taXplclxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBjb21taXRUb0dyb3VwKGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iaHAxMDI0X2NvbW1pdFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IEJIUDI1NkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iaHAyNTZfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQkhQMjU2IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCSFAyNTYucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQkhQMjU2RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEJIUDI1NkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmhwMjU2X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQkhQIGhhc2hlciB3aXRoIGFuIGlucHV0IHNpemUgb2YgMjU2IGJpdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmhwMjU2X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQkhQMjU2RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJIUCBoYXNoZXIgd2l0aCBhbiBpbnB1dCBzaXplIG9mIDI1NiBiaXRzIHdpdGggYSBjdXN0b20gZG9tYWluIHNlcGFyYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluX3NlcGFyYXRvclxuICAgICAqIEByZXR1cm5zIHtCSFAyNTZ9XG4gICAgICovXG4gICAgc3RhdGljIHNldHVwKGRvbWFpbl9zZXBhcmF0b3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRvbWFpbl9zZXBhcmF0b3IsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmJocDI1Nl9zZXR1cChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQkhQMjU2Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJIUCBoYXNoIHdpdGggYW4gaW5wdXQgaGFzaGVyIG9mIDI1NiBiaXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgaGFzaChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmJocDI1Nl9oYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgaGFzaCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiAyNTYgYml0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGhhc2hUb0dyb3VwKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYmhwMjU2X2hhc2hUb0dyb3VwKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiAyNTYgYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgY29tbWl0KGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iaHAyNTZfY29tbWl0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiAyNTYgYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9XG4gICAgICovXG4gICAgY29tbWl0VG9Hcm91cChpbnB1dCwgcmFuZG9taXplcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmFuZG9taXplciwgU2NhbGFyKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gcmFuZG9taXplci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYmhwMjU2X2NvbW1pdFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IEJIUDUxMkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iaHA1MTJfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQkhQNTEyIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCSFA1MTIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQkhQNTEyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEJIUDUxMkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmhwNTEyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQkhQIGhhc2hlciB3aXRoIGFuIGlucHV0IHNpemUgb2YgNTEyIGJpdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmhwNTEyX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQkhQNTEyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJIUCBoYXNoZXIgd2l0aCBhbiBpbnB1dCBzaXplIG9mIDUxMiBiaXRzIHdpdGggYSBjdXN0b20gZG9tYWluIHNlcGFyYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluX3NlcGFyYXRvclxuICAgICAqIEByZXR1cm5zIHtCSFA1MTJ9XG4gICAgICovXG4gICAgc3RhdGljIHNldHVwKGRvbWFpbl9zZXBhcmF0b3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRvbWFpbl9zZXBhcmF0b3IsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmJocDUxMl9zZXR1cChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQkhQNTEyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJIUCBoYXNoIHdpdGggYW4gaW5wdXQgaGFzaGVyIG9mIDUxMiBiaXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgaGFzaChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmJocDUxMl9oYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgaGFzaCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA1MTIgYml0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGhhc2hUb0dyb3VwKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYmhwNTEyX2hhc2hUb0dyb3VwKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA1MTIgYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgY29tbWl0KGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iaHA1MTJfY29tbWl0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA1MTIgYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9XG4gICAgICovXG4gICAgY29tbWl0VG9Hcm91cChpbnB1dCwgcmFuZG9taXplcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmFuZG9taXplciwgU2NhbGFyKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gcmFuZG9taXplci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYmhwNTEyX2NvbW1pdFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IEJIUDc2OEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19iaHA3NjhfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgQkhQNzY4IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShCSFA3NjgucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQkhQNzY4RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEJIUDc2OEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfYmhwNzY4X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQkhQIGhhc2hlciB3aXRoIGFuIGlucHV0IHNpemUgb2YgNzY4IGJpdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uYmhwNzY4X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgQkhQNzY4RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJIUCBoYXNoZXIgd2l0aCBhbiBpbnB1dCBzaXplIG9mIDc2OCBiaXRzIHdpdGggYSBjdXN0b20gZG9tYWluIHNlcGFyYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluX3NlcGFyYXRvclxuICAgICAqIEByZXR1cm5zIHtCSFA3Njh9XG4gICAgICovXG4gICAgc3RhdGljIHNldHVwKGRvbWFpbl9zZXBhcmF0b3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRvbWFpbl9zZXBhcmF0b3IsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmJocDc2OF9zZXR1cChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQkhQNzY4Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJIUCBoYXNoIHdpdGggYW4gaW5wdXQgaGFzaGVyIG9mIDc2OCBiaXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgaGFzaChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmJocDc2OF9oYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgaGFzaCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA3NjggYml0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGhhc2hUb0dyb3VwKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uYmhwNzY4X2hhc2hUb0dyb3VwKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA3NjggYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgY29tbWl0KGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5iaHA3NjhfY29tbWl0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCSFAgY29tbWl0bWVudCB3aXRoIGFuIGlucHV0IGhhc2hlciBvZiA3NjggYml0cyBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9XG4gICAgICovXG4gICAgY29tbWl0VG9Hcm91cChpbnB1dCwgcmFuZG9taXplcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmFuZG9taXplciwgU2NhbGFyKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gcmFuZG9taXplci5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uYmhwNzY4X2NvbW1pdFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IENpcGhlcnRleHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfY2lwaGVydGV4dF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTbmFya1ZNIENpcGhlcnRleHQgb2JqZWN0LiBBIENpcGhlcnRleHQgcmVwcmVzZW50cyBhbiBzeW1tZXRyaWNhbGx5IGVuY3J5cHRlZCBwbGFpbnRleHQuIFRoaXNcbiAqIG9iamVjdCBwcm92aWRlcyBkZWNyeXB0aW9uIG1ldGhvZHMgdG8gcmVjb3ZlciB0aGUgcGxhaW50ZXh0IGZyb20gdGhlIGNpcGhlcnRleHQgKGdpdmVuIHRoZVxuICogYXBpIGNvbnN1bWVyIGhhcyB0aGUgcHJvcGVyIGRlY3J5cHRpb24gbWF0ZXJpYWxzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICovXG5jbGFzcyBDaXBoZXJ0ZXh0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShDaXBoZXJ0ZXh0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIENpcGhlcnRleHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgQ2lwaGVydGV4dEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfY2lwaGVydGV4dF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgdGhlIGNpcGhlcnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWaWV3S2V5fSBUaGUgdmlldyBrZXkgb2YgdGhlIGFjY291bnQgdGhhdCBlbmNyeXB0ZWQgdGhlIGNpcGhlcnRleHQuXG4gICAgICogQHBhcmFtIHtHcm91cH0gVGhlIG5vbmNlIHVzZWQgdG8gZW5jcnlwdCB0aGUgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQbGFpbnRleHR9IFRoZSBkZWNyeXB0ZWQgcGxhaW50ZXh0LlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXlcbiAgICAgKiBAcGFyYW0ge0dyb3VwfSBub25jZVxuICAgICAqIEByZXR1cm5zIHtQbGFpbnRleHR9XG4gICAgICovXG4gICAgZGVjcnlwdCh2aWV3X2tleSwgbm9uY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHZpZXdfa2V5LCBWaWV3S2V5KTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gdmlld19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mobm9uY2UsIEdyb3VwKTtcbiAgICAgICAgICAgIHZhciBwdHIxID0gbm9uY2UuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLmNpcGhlcnRleHRfZGVjcnlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBwdHIxKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBsYWludGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGEgY2lwaGVydGV4dCB1c2luZyB0aGUgdmlldyBrZXkgb2YgdGhlIHRyYW5zaXRpb24gc2lnbmVyLCB0cmFuc2l0aW9uIHB1YmxpYyBrZXksIGFuZFxuICAgICAqIChwcm9ncmFtLCBmdW5jdGlvbiwgaW5kZXgpIHR1cGxlLlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXlcbiAgICAgKiBAcGFyYW0ge0dyb3VwfSB0cmFuc2l0aW9uX3B1YmxpY19rZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbl9uYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICBkZWNyeXB0X3dpdGhfdHJhbnNpdGlvbl9pbmZvKHZpZXdfa2V5LCB0cmFuc2l0aW9uX3B1YmxpY19rZXksIHByb2dyYW0sIGZ1bmN0aW9uX25hbWUsIGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh2aWV3X2tleSwgVmlld0tleSk7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IHZpZXdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zaXRpb25fcHVibGljX2tleSwgR3JvdXApO1xuICAgICAgICAgICAgdmFyIHB0cjEgPSB0cmFuc2l0aW9uX3B1YmxpY19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICBjb25zdCBwdHIyID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjMgPSBwYXNzU3RyaW5nVG9XYXNtMChmdW5jdGlvbl9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4zID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5jaXBoZXJ0ZXh0X2RlY3J5cHRfd2l0aF90cmFuc2l0aW9uX2luZm8ocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgcHRyMSwgcHRyMiwgbGVuMiwgcHRyMywgbGVuMywgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGxhaW50ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY3J5cHQgYSBjaXBoZXJ0ZXh0IHVzaW5nIHRoZSB0cmFuc2l0aW9uIHZpZXcga2V5IGFuZCBhIChwcm9ncmFtLCBmdW5jdGlvbiwgaW5kZXgpIHR1cGxlLlxuICAgICAqIEBwYXJhbSB7RmllbGR9IHRyYW5zaXRpb25fdmlld19rZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbl9uYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICBkZWNyeXB0X3dpdGhfdHJhbnNpdGlvbl92aWV3X2tleSh0cmFuc2l0aW9uX3ZpZXdfa2V5LCBwcm9ncmFtLCBmdW5jdGlvbl9uYW1lLCBpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModHJhbnNpdGlvbl92aWV3X2tleSwgRmllbGQpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSB0cmFuc2l0aW9uX3ZpZXdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHByb2dyYW0sIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIyID0gcGFzc1N0cmluZ1RvV2FzbTAoZnVuY3Rpb25fbmFtZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uY2lwaGVydGV4dF9kZWNyeXB0X3dpdGhfdHJhbnNpdGlvbl92aWV3X2tleShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBwdHIxLCBsZW4xLCBwdHIyLCBsZW4yLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQbGFpbnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcnlwdHMgYSBjaXBoZXJ0ZXh0IGludG8gcGxhaW50ZXh0IHVzaW5nIHRoZSBnaXZlbiBjaXBoZXJ0ZXh0IHZpZXcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWVsZH0gdHJhbnNpdGlvbl92aWV3X2tleSBUaGUgdHJhbnNpdGlvbiB2aWV3IGtleSB0aGF0IHdhcyB1c2VkIHRvIGVuY3J5cHQgdGhlIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UGxhaW50ZXh0fSBUaGUgZGVjcnlwdGVkIHBsYWludGV4dC5cbiAgICAgKiBAcGFyYW0ge0ZpZWxkfSB0cmFuc2l0aW9uX3ZpZXdfa2V5XG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICBkZWNyeXB0U3ltbWV0cmljKHRyYW5zaXRpb25fdmlld19rZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zaXRpb25fdmlld19rZXksIEZpZWxkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gdHJhbnNpdGlvbl92aWV3X2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20uY2lwaGVydGV4dF9kZWNyeXB0U3ltbWV0cmljKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGxhaW50ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGEgbGVmdCBlbmRpYW4gYnl0ZSBhcnJheSBpbnRvIGEgQ2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgVGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBDaXBoZXJ0ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NpcGhlcnRleHR9IFRoZSBDaXBoZXJ0ZXh0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0NpcGhlcnRleHR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlc0xlKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uY2lwaGVydGV4dF9mcm9tQnl0ZXNMZShyZXRwdHIsIGFkZEhlYXBPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENpcGhlcnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYSBDaXBoZXJ0ZXh0IHN0cmluZyBpbnRvIGEgQ2lwaGVydGV4dCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2lwaGVydGV4dCBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDaXBoZXJ0ZXh0fSBUaGUgQ2lwaGVydGV4dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNpcGhlcnRleHRcbiAgICAgKiBAcmV0dXJucyB7Q2lwaGVydGV4dH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjaXBoZXJ0ZXh0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5jaXBoZXJ0ZXh0X2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENpcGhlcnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGEgQ2lwaGVydGV4dCBvYmplY3QgaW50byBhIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gVGhlIHNlcmlhbGl6ZWQgQ2lwaGVydGV4dC5cbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmNpcGhlcnRleHRfdG9CeXRlcyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgYSBDaXBoZXJ0ZXh0IGludG8gYSBqcyBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VyaWFsaXplZCBDaXBoZXJ0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmNpcGhlcnRleHRfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQ29tcHV0ZUtleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19jb21wdXRla2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIENvbXB1dGVLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKENvbXB1dGVLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgQ29tcHV0ZUtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBDb21wdXRlS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19jb21wdXRla2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXB1dGUga2V5IGZyb20gYSBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgUHJpdmF0ZSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wdXRlS2V5fSBDb21wdXRlIGtleVxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXlcbiAgICAgKiBAcmV0dXJucyB7Q29tcHV0ZUtleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbV9wcml2YXRlX2tleShwcml2YXRlX2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmNvbXB1dGVrZXlfZnJvbV9wcml2YXRlX2tleShwcml2YXRlX2tleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQ29tcHV0ZUtleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhZGRyZXNzIGZyb20gdGhlIGNvbXB1dGUga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgYWRkcmVzcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5hZGRyZXNzX2Zyb21fY29tcHV0ZV9rZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBza19wcmYgb2YgdGhlIGNvbXB1dGUga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1NjYWxhcn0gc2tfcHJmXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBza19wcmYoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY29tcHV0ZWtleV9za19wcmYodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByX3RhZyBvZiB0aGUgY29tcHV0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9IHByX3RhZ1xuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBwa19zaWcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uY29tcHV0ZWtleV9wa19zaWcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJfc2lnIG9mIHRoZSBjb21wdXRlIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtHcm91cH0gcHJfc2lnXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHByX3NpZygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb21wdXRla2V5X3ByX3NpZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IEV4ZWN1dGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19leGVjdXRpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRXhlY3V0aW9uIG9mIGFuIEFsZW8gcHJvZ3JhbS5cbiAqL1xuY2xhc3MgRXhlY3V0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFeGVjdXRpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgRXhlY3V0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEV4ZWN1dGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZXhlY3V0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBleGVjdXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uZXhlY3V0aW9uX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBleGVjdXRpb24gb2JqZWN0IGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0V4ZWN1dGlvbiB8IEVycm9yfSBUaGUgd2FzbSByZXByZXNlbnRhdGlvbiBvZiBhbiBleGVjdXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7RXhlY3V0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKGV4ZWN1dGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZXhlY3V0aW9uLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5leGVjdXRpb25fZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXhlY3V0aW9uLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdsb2JhbCBzdGF0ZSByb290IG9mIHRoZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXhlY3V0aW9uIHwgRXJyb3J9IFRoZSBnbG9iYWwgc3RhdGUgcm9vdCB1c2VkIGluIHRoZSBleGVjdXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnbG9iYWxTdGF0ZVJvb3QoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmV4ZWN1dGlvbl9nbG9iYWxTdGF0ZVJvb3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9vZiBvZiB0aGUgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGV4ZWN1dGlvbiBwcm9vZi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHByb29mKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5leGVjdXRpb25fcHJvb2YocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2l0aW9ucyBwcmVzZW50IGluIHRoZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBcnJheTxUcmFuc2l0aW9uPiB0aGUgYXJyYXkgb2YgdHJhbnNpdGlvbnMgcHJlc2VudCBpbiB0aGUgZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGlvbl90cmFuc2l0aW9ucyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBFeGVjdXRpb25SZXNwb25zZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19leGVjdXRpb25yZXNwb25zZV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBXZWJhc3NlbWJseSBSZXByZXNlbnRhdGlvbiBvZiBhbiBBbGVvIGZ1bmN0aW9uIGV4ZWN1dGlvbiByZXNwb25zZVxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIHJldHVybmVkIGJ5IHRoZSBleGVjdXRpb24gb2YgYW4gQWxlbyBmdW5jdGlvbiBvZmYtY2hhaW4uIEl0IHByb3ZpZGVzIG1ldGhvZHMgZm9yXG4gKiByZXRyaWV2aW5nIHRoZSBvdXRwdXRzIG9mIHRoZSBmdW5jdGlvbiBleGVjdXRpb24uXG4gKi9cbmNsYXNzIEV4ZWN1dGlvblJlc3BvbnNlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShFeGVjdXRpb25SZXNwb25zZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBFeGVjdXRpb25SZXNwb25zZUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBFeGVjdXRpb25SZXNwb25zZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZXhlY3V0aW9ucmVzcG9uc2VfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG91dHB1dHMgb2YgdGhlIGV4ZWN1dGVkIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBvdXRwdXRzIG9mIHRoZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGdldE91dHB1dHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0aW9ucmVzcG9uc2VfZ2V0T3V0cHV0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4ZWN1dGlvbiBvYmplY3QgaWYgcHJlc2VudCwgbnVsbCBpZiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXhlY3V0aW9uIHwgdW5kZWZpbmVkfSBUaGUgZXhlY3V0aW9uIG9iamVjdCBpZiBwcmVzZW50LCBudWxsIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtFeGVjdXRpb24gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0RXhlY3V0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmV4ZWN1dGlvbnJlc3BvbnNlX2dldEV4ZWN1dGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBFeGVjdXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb2dyYW0ga2V5cyBpZiBwcmVzZW50XG4gICAgICogQHJldHVybnMge0tleVBhaXJ9XG4gICAgICovXG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5leGVjdXRpb25yZXNwb25zZV9nZXRLZXlzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gS2V5UGFpci5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm92aW5nX2tleSBpZiB0aGUgcHJvdmluZyBrZXkgd2FzIGNhY2hlZCBpbiB0aGUgRXhlY3V0aW9uIHJlc3BvbnNlLlxuICAgICAqIE5vdGUgdGhlIHByb3Zpbmcga2V5IGlzIHJlbW92ZWQgZnJvbSB0aGUgcmVzcG9uc2Ugb2JqZWN0IGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIHRoaXNcbiAgICAgKiBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB3aWxsIHJldHVybiBudWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb3ZpbmdLZXkgfCB1bmRlZmluZWR9IFRoZSBwcm92aW5nIGtleVxuICAgICAqIEByZXR1cm5zIHtQcm92aW5nS2V5IHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldFByb3ZpbmdLZXkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0aW9ucmVzcG9uc2VfZ2V0UHJvdmluZ0tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBQcm92aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmdfa2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVGhlIHZlcmlmeWluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fVxuICAgICAqL1xuICAgIGdldFZlcmlmeWluZ0tleSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5leGVjdXRpb25yZXNwb25zZV9nZXRWZXJpZnlpbmdLZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbklkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5leGVjdXRpb25yZXNwb25zZV9nZXRGdW5jdGlvbklkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtQcm9ncmFtfVxuICAgICAqL1xuICAgIGdldFByb2dyYW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZXhlY3V0aW9ucmVzcG9uc2VfZ2V0UHJvZ3JhbSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBQcm9ncmFtLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgRmllbGRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZmllbGRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRmllbGQgZWxlbWVudC5cbiAqL1xuY2xhc3MgRmllbGQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZpZWxkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEZpZWxkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdGF0aWMgX191bndyYXAoanNWYWx1ZSkge1xuICAgICAgICBpZiAoIShqc1ZhbHVlIGluc3RhbmNlb2YgRmllbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNWYWx1ZS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEZpZWxkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19maWVsZF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmaWVsZCBvYmplY3QgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZpZWxkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKGZpZWxkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChmaWVsZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZmllbGRfZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWVsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZpZWxkX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZmllbGQgZWxlbWVudCBmcm9tIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXNMZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZpZWxkX2Zyb21CeXRlc0xlKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZmllbGQgZWxlbWVudCBhcyBhIFVpbnQ4QXJyYXkgb2YgbGVmdCBlbmRpYW4gYnl0ZXMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdG9CeXRlc0xlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmZpZWxkX3RvQnl0ZXNMZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbnN0cnVjdCBhIGZpZWxkIGVsZW1lbnQgZnJvbSBhIGJvb2xlYW4gYXJyYXkgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBiaXRzXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQml0c0xlKGJpdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5maWVsZF9mcm9tQml0c0xlKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYml0cykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsZWZ0IGVuZGlhbiBib29sZWFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWVsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRvQml0c0xlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX3RvQml0c0xlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGxhaW50ZXh0IGZyb20gdGhlIGZpZWxkIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICB0b1BsYWludGV4dCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF90b1BsYWludGV4dCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBQbGFpbnRleHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoZSBmaWVsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9jbG9uZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByYW5kb20gZmllbGQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdHdvIGZpZWxkIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7RmllbGR9IG90aGVyXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIGFkZChvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9hZGQodGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIGZpZWxkIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7RmllbGR9IG90aGVyXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgRmllbGQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX3N1YnRyYWN0KHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBmaWVsZCBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge0ZpZWxkfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBtdWx0aXBseShvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9tdWx0aXBseSh0aGlzLl9fd2JnX3B0ciwgb3RoZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIGZpZWxkIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7RmllbGR9IG90aGVyXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIGRpdmlkZShvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9kaXZpZGUodGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG93ZXIgb2YgYSBmaWVsZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IG90aGVyXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHBvdyhvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9wb3codGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJ0IHRoZSBmaWVsZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX2ludmVyc2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWRkaXRpdmUgaWRlbnRpdHkgZWxlbWVudCBvZiB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHN0YXRpYyB6ZXJvKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX3plcm8oKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG11bHRpcGxpY2F0aXZlIGlkZW50aXR5IG9mIHRoZSBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgc3RhdGljIG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9vbmUoKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3VibGUgdGhlIGZpZWxkIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9kb3VibGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9uZSBmaWVsZCBlbGVtZW50IGVxdWFscyBhbm90aGVyLlxuICAgICAqIEBwYXJhbSB7RmllbGR9IG90aGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgRmllbGQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX2VxdWFscyh0aGlzLl9fd2JnX3B0ciwgb3RoZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IEdyYXBoS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2dyYXBoa2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIEdyYXBoS2V5IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShHcmFwaEtleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBHcmFwaEtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBHcmFwaEtleUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZ3JhcGhrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZ3JhcGgga2V5IGZyb20gYSB2aWV3IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXkgVmlldyBrZXlcbiAgICAgKiBAcmV0dXJucyB7R3JhcGhLZXl9IEdyYXBoIGtleVxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXlcbiAgICAgKiBAcmV0dXJucyB7R3JhcGhLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21fdmlld19rZXkodmlld19rZXkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHZpZXdfa2V5LCBWaWV3S2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncmFwaGtleV9mcm9tX3ZpZXdfa2V5KHZpZXdfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcmFwaEtleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGdyYXBoIGtleSBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JhcGgga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JhcGhfa2V5IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyYXBoIGtleVxuICAgICAqIEByZXR1cm5zIHtHcmFwaEtleX0gR3JhcGgga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyYXBoX2tleVxuICAgICAqIEByZXR1cm5zIHtHcmFwaEtleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbV9zdHJpbmcoZ3JhcGhfa2V5KSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChncmFwaF9rZXksIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncmFwaGtleV9mcm9tX3N0cmluZyhwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBncmFwaCBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyYXBoIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9fc3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ncmFwaGtleV90b19zdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNrX3RhZyBvZiB0aGUgZ3JhcGgga2V5LiBVc2VkIHRvIGRldGVybWluZSBvd25lcnNoaXAgb2YgcmVjb3Jkcy5cbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgc2tfdGFnKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX2Nsb25lKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgR3JvdXBGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZ3JvdXBfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRWxsaXB0aWMgY3VydmUgZWxlbWVudC5cbiAqL1xuY2xhc3MgR3JvdXAge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEdyb3VwLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIEdyb3VwRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEdyb3VwRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19ncm91cF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBncm91cCBvYmplY3QgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyb3VwIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKGdyb3VwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChncm91cCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZ3JvdXBfZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncm91cCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdyb3VwX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudCBmcm9tIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXNMZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdyb3VwX2Zyb21CeXRlc0xlKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ3JvdXAgZWxlbWVudCBhcyBhIFVpbnQ4QXJyYXkgb2YgbGVmdCBlbmRpYW4gYnl0ZXMuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdG9CeXRlc0xlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLmdyb3VwX3RvQnl0ZXNMZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbnN0cnVjdCBhIGdyb3VwIGVsZW1lbnQgZnJvbSBhIGJvb2xlYW4gYXJyYXkgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBiaXRzXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQml0c0xlKGJpdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5ncm91cF9mcm9tQml0c0xlKHJldHB0ciwgYWRkQm9ycm93ZWRPYmplY3QoYml0cykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsZWZ0IGVuZGlhbiBib29sZWFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncm91cCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRvQml0c0xlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdyb3VwX3RvQml0c0xlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGdyb3VwIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHRvWENvb3JkaW5hdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ3JvdXBfdG9YQ29vcmRpbmF0ZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGxhaW50ZXh0IGVsZW1lbnQgZnJvbSBhIGdyb3VwIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICB0b1BsYWludGV4dCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF90b1BsYWludGV4dCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBQbGFpbnRleHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoZSBncm91cCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF9jbG9uZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByYW5kb20gZ3JvdXAgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9XG4gICAgICovXG4gICAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF9yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdHdvIGdyb3VwIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7R3JvdXB9IG90aGVyXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGFkZChvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEdyb3VwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF9hZGQodGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIGdyb3VwIGVsZW1lbnRzIChlcXVpdmFsZW50bHk6IGFkZCB0aGUgaW52ZXJzZSBvZiBhbiBlbGVtZW50KS5cbiAgICAgKiBAcGFyYW0ge0dyb3VwfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mob3RoZXIsIEdyb3VwKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF9zdWJ0cmFjdCh0aGlzLl9fd2JnX3B0ciwgb3RoZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSBhIGdyb3VwIGVsZW1lbnQgYnkgYSBzY2FsYXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1NjYWxhcn0gc2NhbGFyXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHNjYWxhck11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2NhbGFyLCBTY2FsYXIpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdyb3VwX3NjYWxhck11bHRpcGx5KHRoaXMuX193YmdfcHRyLCBzY2FsYXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3VibGUgdGhlIGdyb3VwIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF9kb3VibGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW52ZXJzZSBvZiB0aGUgZ3JvdXAgZWxlbWVudC4gVGhpcyBpcyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgcG9pbnQgYWJvdXQgdGhlIGF4aXNcbiAgICAgKiBvZiBzeW1tZXRyeSBpLmUuICh4LHkpIC0+ICh4LCAteSkuXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ3JvdXBfaW52ZXJzZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgb25lIGdyb3VwIGVsZW1lbnQgZXF1YWxzIGFub3RoZXIuXG4gICAgICogQHBhcmFtIHtHcm91cH0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG90aGVyLCBHcm91cCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZ3JvdXBfZXF1YWxzKHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGdyb3VwIGlkZW50aXR5IGVsZW1lbnQgdW5kZXIgdGhlIGdyb3VwIG9wZXJhdGlvbiAoaS5lLiB0aGUgcG9pbnQgYXQgaW5maW5pdHkuKVxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5ncm91cF96ZXJvKCk7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBnZW5lcmF0b3Igb2YgdGhlIGdyb3VwLlxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmdyb3VwX2dlbmVyYXRvcigpO1xuICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBLZXlQYWlyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX2tleXBhaXJfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogS2V5IHBhaXIgb2JqZWN0IGNvbnRhaW5pbmcgYm90aCB0aGUgZnVuY3Rpb24gcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXNcbiAqL1xuY2xhc3MgS2V5UGFpciB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoS2V5UGFpci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBLZXlQYWlyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEtleVBhaXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX2tleXBhaXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IGtleSBwYWlyIGZyb20gcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleX0gcHJvdmluZ19rZXkgUHJvdmluZyBrZXkgY29ycmVzcG9uZGluZyB0byBhIGZ1bmN0aW9uIGluIGFuIEFsZW8gcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5fSB2ZXJpZnlpbmdfa2V5IFZlcmlmeWluZyBrZXkgY29ycmVzcG9uZGluZyB0byBhIGZ1bmN0aW9uIGluIGFuIEFsZW8gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtLZXlQYWlyfSBLZXkgcGFpciBvYmplY3QgY29udGFpbmluZyBib3RoIHRoZSBmdW5jdGlvbiBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5c1xuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleX0gcHJvdmluZ19rZXlcbiAgICAgKiBAcGFyYW0ge1ZlcmlmeWluZ0tleX0gdmVyaWZ5aW5nX2tleVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3Zpbmdfa2V5LCB2ZXJpZnlpbmdfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwcm92aW5nX2tleSwgUHJvdmluZ0tleSk7XG4gICAgICAgIHZhciBwdHIwID0gcHJvdmluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICB2YXIgcHRyMSA9IHZlcmlmeWluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ua2V5cGFpcl9uZXcocHRyMCwgcHRyMSk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBLZXlQYWlyRmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJvdmluZyBrZXkuIFRoaXMgbWV0aG9kIHdpbGwgcmVtb3ZlIHRoZSBwcm92aW5nIGtleSBmcm9tIHRoZSBrZXkgcGFpclxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb3ZpbmdLZXl9XG4gICAgICogQHJldHVybnMge1Byb3ZpbmdLZXl9XG4gICAgICovXG4gICAgcHJvdmluZ0tleSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5rZXlwYWlyX3Byb3ZpbmdLZXkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm92aW5nS2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmVyaWZ5aW5nIGtleS4gVGhpcyBtZXRob2Qgd2lsbCByZW1vdmUgdGhlIHZlcmlmeWluZyBrZXkgZnJvbSB0aGUga2V5IHBhaXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICB2ZXJpZnlpbmdLZXkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ua2V5cGFpcl92ZXJpZnlpbmdLZXkocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IE1ldGFkYXRhRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX21ldGFkYXRhX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIE1ldGFkYXRhIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShNZXRhZGF0YS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBNZXRhZGF0YUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBNZXRhZGF0YUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfbWV0YWRhdGFfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfbWV0YWRhdGFfbmFtZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IG5hbWUoYXJnMCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYXJnMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLl9fd2JnX3NldF9tZXRhZGF0YV9uYW1lKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbG9jYXRvcigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X21ldGFkYXRhX2xvY2F0b3IocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCBsb2NhdG9yKGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfbWV0YWRhdGFfbG9jYXRvcih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHByb3ZlcigpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmdfZ2V0X21ldGFkYXRhX3Byb3ZlcihyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmcwXG4gICAgICovXG4gICAgc2V0IHByb3ZlcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X21ldGFkYXRhX3Byb3Zlcih0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHZlcmlmaWVyKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfbWV0YWRhdGFfdmVyaWZpZXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnMFxuICAgICAqL1xuICAgIHNldCB2ZXJpZmllcihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChhcmcwLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uX193Ymdfc2V0X21ldGFkYXRhX3ZlcmlmaWVyKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdmVyaWZ5aW5nS2V5KCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diZ19nZXRfbWV0YWRhdGFfdmVyaWZ5aW5nS2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZzBcbiAgICAgKi9cbiAgICBzZXQgdmVyaWZ5aW5nS2V5KGFyZzApIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFyZzAsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgd2FzbS5fX3diZ19zZXRfbWV0YWRhdGFfdmVyaWZ5aW5nS2V5KHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgYmFzZVVybCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ubWV0YWRhdGFfYmFzZVVybChyZXRwdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBib25kX3B1YmxpYygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZXRhZGF0YV9ib25kX3B1YmxpYygpO1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9uZF92YWxpZGF0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWV0YWRhdGFfYm9uZF92YWxpZGF0b3IoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9XG4gICAgICovXG4gICAgc3RhdGljIGNsYWltX3VuYm9uZF9wdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWV0YWRhdGFfY2xhaW1fdW5ib25kX3B1YmxpYygpO1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmVlX3ByaXZhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWV0YWRhdGFfZmVlX3ByaXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9XG4gICAgICovXG4gICAgc3RhdGljIGZlZV9wdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWV0YWRhdGFfZmVlX3B1YmxpYygpO1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5jbHVzaW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX2luY2x1c2lvbigpO1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNZXRhZGF0YX1cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZXRhZGF0YV9qb2luKCk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRfdmFsaWRhdG9yX3N0YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3NldF92YWxpZGF0b3Jfc3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9XG4gICAgICovXG4gICAgc3RhdGljIHNwbGl0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3NwbGl0KCk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zlcl9wcml2YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3RyYW5zZmVyX3ByaXZhdGUoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9XG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3RyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljKCk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zlcl9wdWJsaWMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ubWV0YWRhdGFfdHJhbnNmZXJfcHVibGljKCk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2Zlcl9wdWJsaWNfYXNfc2lnbmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3RyYW5zZmVyX3B1YmxpY19hc19zaWduZXIoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TWV0YWRhdGF9XG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3RyYW5zZmVyX3B1YmxpY190b19wcml2YXRlKCk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge01ldGFkYXRhfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmJvbmRfcHVibGljKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLm1ldGFkYXRhX3VuYm9uZF9wdWJsaWMoKTtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgT2ZmbGluZVF1ZXJ5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX29mZmxpbmVxdWVyeV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBBbiBvZmZsaW5lIHF1ZXJ5IG9iamVjdCB1c2VkIHRvIGluc2VydCB0aGUgZ2xvYmFsIHN0YXRlIHJvb3QgYW5kIHN0YXRlIHBhdGhzIG5lZWRlZCB0byBjcmVhdGVcbiAqIGEgdmFsaWQgaW5jbHVzaW9uIHByb29mIG9mZmxpbmUuXG4gKi9cbmNsYXNzIE9mZmxpbmVRdWVyeSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2ZmbGluZVF1ZXJ5LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIE9mZmxpbmVRdWVyeUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBPZmZsaW5lUXVlcnlGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX29mZmxpbmVxdWVyeV9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2ZmbGluZSBxdWVyeSBvYmplY3QuIFRoZSBzdGF0ZSByb290IGlzIHJlcXVpcmVkIHRvIGJlIHBhc3NlZCBpbiBhcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19oZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVfcm9vdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrX2hlaWdodCwgc3RhdGVfcm9vdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc3RhdGVfcm9vdCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ub2ZmbGluZXF1ZXJ5X25ldyhyZXRwdHIsIGJsb2NrX2hlaWdodCwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX193YmdfcHRyID0gcjAgPj4+IDA7XG4gICAgICAgICAgICBPZmZsaW5lUXVlcnlGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBibG9jayBoZWlnaHQgdG8gdGhlIG9mZmxpbmUgcXVlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja19oZWlnaHRcbiAgICAgKi9cbiAgICBhZGRCbG9ja0hlaWdodChibG9ja19oZWlnaHQpIHtcbiAgICAgICAgd2FzbS5vZmZsaW5lcXVlcnlfYWRkQmxvY2tIZWlnaHQodGhpcy5fX3diZ19wdHIsIGJsb2NrX2hlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBzdGF0ZSBwYXRoIHRvIHRoZSBvZmZsaW5lIHF1ZXJ5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21taXRtZW50OiBUaGUgY29tbWl0bWVudCBjb3JyZXNwb25kaW5nIHRvIGEgcmVjb3JkIGlucG91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZV9wYXRoOiBUaGUgc3RhdGUgcGF0aCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjb21taXRtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1pdG1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVfcGF0aFxuICAgICAqL1xuICAgIGFkZFN0YXRlUGF0aChjb21taXRtZW50LCBzdGF0ZV9wYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChjb21taXRtZW50LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHN0YXRlX3BhdGgsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLm9mZmxpbmVxdWVyeV9hZGRTdGF0ZVBhdGgocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEganNvbiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9mZmxpbmUgcXVlcnkgb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ub2ZmbGluZXF1ZXJ5X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9mZmxpbmUgcXVlcnkgb2JqZWN0IGZyb20gYSBqc29uIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHJldHVybnMge09mZmxpbmVRdWVyeX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5vZmZsaW5lcXVlcnlfZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2ZmbGluZVF1ZXJ5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBQZWRlcnNlbjEyOEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wZWRlcnNlbjEyOF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQZWRlcnNlbjEyOCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUGVkZXJzZW4xMjgucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUGVkZXJzZW4xMjhGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGVkZXJzZW4xMjhGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3BlZGVyc2VuMTI4X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUGVkZXJzZW4gaGFzaGVyIGZvciBhIGdpdmVuICh1cCB0bykgMTI4LWJpdCBpbnB1dC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wZWRlcnNlbjEyOF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFBlZGVyc2VuMTI4RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFBlZGVyc2VuIGhhc2hlciBmb3IgYSBnaXZlbiAodXAgdG8pIDEyOC1iaXQgaW5wdXQgd2l0aCBhIGN1c3RvbSBkb21haW4gc2VwYXJhdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5fc2VwYXJhdG9yXG4gICAgICogQHJldHVybnMge1BlZGVyc2VuMTI4fVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXR1cChkb21haW5fc2VwYXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkb21haW5fc2VwYXJhdG9yLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucGVkZXJzZW4xMjhfc2V0dXAocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBQZWRlcnNlbjEyOC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUGVkZXJzZW4gaGFzaCBmb3IgYSBnaXZlbiAodXAgdG8pIDEyOC1iaXQgaW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBoYXNoKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucGVkZXJzZW4xMjhfaGFzaChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUGVkZXJzZW4gY29tbWl0bWVudCBmb3IgdGhlIGdpdmVuICh1cCB0bykgMTI4LWJpdCBpbnB1dCBhbmQgcmFuZG9taXplci5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtTY2FsYXJ9IHJhbmRvbWl6ZXJcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgY29tbWl0KGlucHV0LCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHB0cjAgPSByYW5kb21pemVyLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICAgICAgd2FzbS5wZWRlcnNlbjEyOF9jb21taXQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFBlZGVyc2VuIGNvbW1pdG1lbnQgZm9yIHRoZSBnaXZlbiAodXAgdG8pIDEyOC1iaXQgaW5wdXQgYW5kIHJhbmRvbWl6ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSByYW5kb21pemVyXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGNvbW1pdFRvR3JvdXAoaW5wdXQsIHJhbmRvbWl6ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJhbmRvbWl6ZXIsIFNjYWxhcik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IHJhbmRvbWl6ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnBlZGVyc2VuMTI4X2NvbW1pdFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIHB0cjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFBlZGVyc2VuNjRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcGVkZXJzZW42NF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQZWRlcnNlbjY0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShQZWRlcnNlbjY0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFBlZGVyc2VuNjRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGVkZXJzZW42NEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcGVkZXJzZW42NF9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFBlZGVyc2VuIGhhc2hlciBmb3IgYSBnaXZlbiAodXAgdG8pIDY0LWJpdCBpbnB1dC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wZWRlcnNlbjY0X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgUGVkZXJzZW42NEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBQZWRlcnNlbjY0IGhhc2hlciBmb3IgYSBnaXZlbiAodXAgdG8pIDY0LWJpdCBpbnB1dCB3aXRoIGEgY3VzdG9tIGRvbWFpbiBzZXBhcmF0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbl9zZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7UGVkZXJzZW42NH1cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0dXAoZG9tYWluX3NlcGFyYXRvcikge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZG9tYWluX3NlcGFyYXRvciwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnBlZGVyc2VuNjRfc2V0dXAocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBQZWRlcnNlbjY0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQZWRlcnNlbiBoYXNoIGZvciBhIGdpdmVuICh1cCB0bykgNjQtYml0IGlucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgaGFzaChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBlZGVyc2VuNjRfaGFzaChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUGVkZXJzZW4gY29tbWl0bWVudCBmb3IgdGhlIGdpdmVuICh1cCB0bykgNjQtYml0IGlucHV0IGFuZCByYW5kb21pemVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcGFyYW0ge1NjYWxhcn0gcmFuZG9taXplclxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBjb21taXQoaW5wdXQsIHJhbmRvbWl6ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJhbmRvbWl6ZXIsIFNjYWxhcik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IHJhbmRvbWl6ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnBlZGVyc2VuNjRfY29tbWl0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBQZWRlcnNlbiBjb21taXRtZW50IGZvciB0aGUgZ2l2ZW4gKHVwIHRvKSA2NC1iaXQgaW5wdXQgYW5kIHJhbmRvbWl6ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSByYW5kb21pemVyXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGNvbW1pdFRvR3JvdXAoaW5wdXQsIHJhbmRvbWl6ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJhbmRvbWl6ZXIsIFNjYWxhcik7XG4gICAgICAgICAgICB2YXIgcHRyMCA9IHJhbmRvbWl6ZXIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgICAgICB3YXNtLnBlZGVyc2VuNjRfY29tbWl0VG9Hcm91cChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgcHRyMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUGxhaW50ZXh0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3BsYWludGV4dF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBTbmFya1ZNIFBsYWludGV4dCBvYmplY3QuIFBsYWludGV4dCBpcyBhIGZ1bmRhbWVudGFsIG1vbmFkaWMgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCBBbGVvXG4gKiBwcmltaXRpdmUgdHlwZXMgKGJvb2xlYW4sIGZpZWxkLCBncm91cCwgaTgsIGkxNiwgaTMyLCBpNjQsIGkxMjgsIHU4LCB1MTYsIHUzMiwgdTY0LCB1MTI4LFxuICogc2NhbGFyLCBhbmQgc2lnbmF0dXJlKSwgc3RydWN0IHR5cGVzLCBhbmQgYXJyYXkgdHlwZXMuXG4gKlxuICogSW4gdGhlIGNvbnRleHQgb2YgYSB3ZWIgb3IgTm9kZUpTIGFwcGxpY2F0aW9uLCB0aGlzIHR5cGUgaXMgdXNlZnVsIGZvciB0dXJuaW5nIGFuIEFsZW8gdHlwZSBpbnRvXG4gKiBhIEpTIHZhbHVlLCBvYmplY3QsIG9yIGFycmF5IHRoYXQgbWlnaHQgYmUgbmVjZXNzYXJ5IGZvciBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyB3aXRoaW4gdGhlXG4gKiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSBib25kIHN0YXRlIG9mIGFuIGV4aXN0aW5nIGFkZHJlc3MuXG4gKiBjb25zdCBib25kU3RhdGUgPSBhd2FpdCBmZXRjaChodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjEvbWFpbm5ldC9wcm9ncmFtL2NyZWRpdHMuYWxlby9tYXBwaW5nL2JvbmRfc3RhdGUvYWxlbzEyemx5dGhsN2h0amR0ampqejNhaGRqNHZsNndrM3p1em0zN3M4MGw4NnFweDhmeXg5NWZxbnhjbjJmKTtcbiAqIC8vIENvbnZlcnQgdGhlIGJvbmQgc3RhdGUgdG8gYSBQbGFpbnRleHQgb2JqZWN0LlxuICogY29uc3QgYm9uZFN0YXRlUGxhaW50ZXh0ID0gUGxhaW50ZXh0LmZyb21TdHJpbmcoYm9uZF9zdGF0ZSk7XG4gKiAvLyBDb252ZXJ0IHRoZSBQbGFpbnRleHQgb2JqZWN0IHRvIGEgSlMgb2JqZWN0LlxuICogY29uc3QgYm9uZFN0YXRlT2JqZWN0ID0gYm9uZF9zdGF0ZV9wbGFpbnRleHQudG9PYmplY3QoKTtcbiAqIC8vIENoZWNrIGlmIHRoZSBib25kIHN0YXRlIG1hdGNoZXMgdGhlIGV4cGVjdGVkIG9iamVjdC5cbiAqIGNvbnN0IGV4cGVjdGVkT2JqZWN0ID0geyB2YWxpZGF0b3I6IFwiYWxlbzEyemx5dGhsN2h0amR0ampqejNhaGRqNHZsNndrM3p1em0zN3M4MGw4NnFweDhmeXg5NWZxbnhjbjJmXCIsIG1pY3JvY3JlZGl0czogMTAwMDAwMDAwdTY0IH07XG4gKiBhc3NlcnQoIEpTT04uc3RyaW5naWZ5KGJvbmRTdGF0ZU9iamVjdCkgPT09IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkT2JqZWN0KSApO1xuICovXG5jbGFzcyBQbGFpbnRleHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFBsYWludGV4dC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQbGFpbnRleHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUGxhaW50ZXh0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wbGFpbnRleHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHBsYWludGV4dCBtZW1iZXIgaWYgdGhlIHBsYWludGV4dCBpcyBhIHN0cnVjdC4gUmV0dXJucyBgbnVsbGAgaWYgdGhlIHBsYWludGV4dCBpcyBub3RcbiAgICAgKiBhIHN0cnVjdCBvciB0aGUgbWVtYmVyIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBsYWludGV4dCBtZW1iZXIgdG8gZmluZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQbGFpbnRleHR9IFRoZSBwbGFpbnRleHQgbWVtYmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICBmaW5kKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5hbWUsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnBsYWludGV4dF9maW5kKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGxhaW50ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgYSBwbGFpbnRleHQgd2l0aCBhbiBhZGRyZXNzIGFuZCByYW5kb21pemVyLlxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7U2NhbGFyfSByYW5kb21pemVyXG4gICAgICogQHJldHVybnMge0NpcGhlcnRleHR9XG4gICAgICovXG4gICAgZW5jcnlwdChhZGRyZXNzLCByYW5kb21pemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhZGRyZXNzLCBBZGRyZXNzKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYW5kb21pemVyLCBTY2FsYXIpO1xuICAgICAgICAgICAgd2FzbS5wbGFpbnRleHRfZW5jcnlwdChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRyZXNzLl9fd2JnX3B0ciwgcmFuZG9taXplci5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVydGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IGEgcGxhaW50ZXh0IHdpdGggYSB0cmFuc2l0aW9uIHZpZXcga2V5LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IHRyYW5zaXRpb25fdmlld19rZXlcbiAgICAgKiBAcmV0dXJucyB7Q2lwaGVydGV4dH1cbiAgICAgKi9cbiAgICBlbmNyeXB0U3ltbWV0cmljKHRyYW5zaXRpb25fdmlld19rZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zaXRpb25fdmlld19rZXksIEZpZWxkKTtcbiAgICAgICAgICAgIHdhc20ucGxhaW50ZXh0X2VuY3J5cHRTeW1tZXRyaWMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgdHJhbnNpdGlvbl92aWV3X2tleS5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVydGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGxhaW50ZXh0IG9iamVjdCBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBsYWludGV4dCBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwbGFpbnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UGxhaW50ZXh0fSBUaGUgcGxhaW50ZXh0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhaW50ZXh0XG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhwbGFpbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHBsYWludGV4dCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucGxhaW50ZXh0X2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBsYWludGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwbGFpbnRleHQgb2JqZWN0IGZyb20gYSBzZXJpZXMgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIEEgbGVmdCBlbmRpYW4gYnl0ZSBhcnJheSByZXByZXNlbnRpbmcgdGhlIHBsYWludGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQbGFpbnRleHR9IFRoZSBwbGFpbnRleHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UGxhaW50ZXh0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXNMZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBsYWludGV4dF9mcm9tQnl0ZXNMZShyZXRwdHIsIGFkZEhlYXBPYmplY3QoYnl0ZXMpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBsYWludGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBwbGFpbnRleHQgZWxlbWVudCBmcm9tIGEgc2VyaWVzIG9mIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlcyBBIGxlZnQgZW5kaWFuIGJ5dGUgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwbGFpbnRleHQuXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdG9CeXRlc0xlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBsYWludGV4dF90b0J5dGVzTGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwbGFpbnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwbGFpbnRleHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucGxhaW50ZXh0X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZXMgdGhlIHR5cGUgb2YgdGhlIHBsYWludGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0eXBlIG9mIHRoZSBwbGFpbnRleHQuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBwbGFpbnRleHRUeXBlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wbGFpbnRleHRfcGxhaW50ZXh0VHlwZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gY29udmVydCB0aGUgcGxhaW50ZXh0IHRvIGEgSlMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIEpTIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGxhaW50ZXh0LlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgdG9PYmplY3QoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucGxhaW50ZXh0X3RvT2JqZWN0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBQb3NlaWRvbjJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcG9zZWlkb24yX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFBvc2VpZG9uMiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUG9zZWlkb24yLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFBvc2VpZG9uMkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQb3NlaWRvbjJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Bvc2VpZG9uMl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFBvc2VpZG9uIGhhc2hlciB3aXRoIGFuIGlucHV0IHJhdGUgb2YgMi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wb3NlaWRvbjJfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBQb3NlaWRvbjJGaW5hbGl6YXRpb24ucmVnaXN0ZXIodGhpcywgdGhpcy5fX3diZ19wdHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUG9zZWlkb24gaGFzaGVyIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiAyIGFuZCBhIGN1c3RvbSBkb21haW4gc2VwYXJhdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5fc2VwYXJhdG9yXG4gICAgICogQHJldHVybnMge1Bvc2VpZG9uMn1cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0dXAoZG9tYWluX3NlcGFyYXRvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZG9tYWluX3NlcGFyYXRvciwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucG9zZWlkb24yX3NldHVwKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQb3NlaWRvbjIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUG9zZWlkb24gaGFzaCB3aXRoIGFuIGlucHV0IHJhdGUgb2YgMi5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIGhhc2goaW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wb3NlaWRvbjJfaGFzaChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBleHRlbmRlZCBQb3NlaWRvbiBoYXNoIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiAyLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtX291dHB1dHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBoYXNoTWFueShpbnB1dCwgbnVtX291dHB1dHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wb3NlaWRvbjJfaGFzaE1hbnkocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCksIG51bV9vdXRwdXRzKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQb3NlaWRvbiBoYXNoIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiAyIG9uIHRoZSBzY2FsYXIgZmllbGQuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgaGFzaFRvU2NhbGFyKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucG9zZWlkb24yX2hhc2hUb1NjYWxhcihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUG9zZWlkb24gaGFzaCB3aXRoIGFuIGlucHV0IHJhdGUgb2YgMiBvbiB0aGUgYWZmaW5lIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7R3JvdXB9XG4gICAgICovXG4gICAgaGFzaFRvR3JvdXAoaW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wb3NlaWRvbjJfaGFzaFRvR3JvdXAocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXAuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFBvc2VpZG9uNEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19wb3NlaWRvbjRfZnJlZShwdHIgPj4+IDAsIDEpKTtcblxuY2xhc3MgUG9zZWlkb240IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShQb3NlaWRvbjQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUG9zZWlkb240RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFBvc2VpZG9uNEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcG9zZWlkb240X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUG9zZWlkb24gaGFzaGVyIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiA0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnBvc2VpZG9uNF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIFBvc2VpZG9uNEZpbmFsaXphdGlvbi5yZWdpc3Rlcih0aGlzLCB0aGlzLl9fd2JnX3B0ciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBQb3NlaWRvbiBoYXNoZXIgd2l0aCBhbiBpbnB1dCByYXRlIG9mIDQgYW5kIGEgY3VzdG9tIGRvbWFpbiBzZXBhcmF0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbl9zZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7UG9zZWlkb240fVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXR1cChkb21haW5fc2VwYXJhdG9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChkb21haW5fc2VwYXJhdG9yLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wb3NlaWRvbjRfc2V0dXAocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBvc2VpZG9uNC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQb3NlaWRvbiBoYXNoIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiA0LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgaGFzaChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBvc2VpZG9uNF9oYXNoKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4dGVuZGVkIFBvc2VpZG9uIGhhc2ggd2l0aCBhbiBpbnB1dCByYXRlIG9mIDQuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1fb3V0cHV0c1xuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGhhc2hNYW55KGlucHV0LCBudW1fb3V0cHV0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBvc2VpZG9uNF9oYXNoTWFueShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSwgbnVtX291dHB1dHMpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFBvc2VpZG9uIGhhc2ggd2l0aCBhbiBpbnB1dCByYXRlIG9mIDQgb24gdGhlIHNjYWxhciBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBoYXNoVG9TY2FsYXIoaW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wb3NlaWRvbjRfaGFzaFRvU2NhbGFyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNjYWxhci5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQb3NlaWRvbiBoYXNoIHdpdGggYW4gaW5wdXQgcmF0ZSBvZiA0IG9uIHRoZSBhZmZpbmUgY3VydmUuXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtHcm91cH1cbiAgICAgKi9cbiAgICBoYXNoVG9Hcm91cChpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBvc2VpZG9uNF9oYXNoVG9Hcm91cChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGlucHV0KSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUG9zZWlkb244RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Bvc2VpZG9uOF9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBQb3NlaWRvbjgge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFBvc2VpZG9uOC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQb3NlaWRvbjhGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUG9zZWlkb244RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wb3NlaWRvbjhfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBQb3NlaWRvbiBoYXNoZXIgd2l0aCBhbiBpbnB1dCByYXRlIG9mIDguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucG9zZWlkb244X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgUG9zZWlkb244RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFBvc2VpZG9uIGhhc2hlciB3aXRoIGFuIGlucHV0IHJhdGUgb2YgOCBhbmQgYSBjdXN0b20gZG9tYWluIHNlcGFyYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluX3NlcGFyYXRvclxuICAgICAqIEByZXR1cm5zIHtQb3NlaWRvbjh9XG4gICAgICovXG4gICAgc3RhdGljIHNldHVwKGRvbWFpbl9zZXBhcmF0b3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGRvbWFpbl9zZXBhcmF0b3IsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnBvc2VpZG9uOF9zZXR1cChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9zZWlkb244Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFBvc2VpZG9uIGhhc2ggd2l0aCBhbiBpbnB1dCByYXRlIG9mIDguXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBoYXNoKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucG9zZWlkb244X2hhc2gocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXh0ZW5kZWQgUG9zZWlkb24gaGFzaCB3aXRoIGFuIGlucHV0IHJhdGUgb2YgOC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bV9vdXRwdXRzXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgaGFzaE1hbnkoaW5wdXQsIG51bV9vdXRwdXRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucG9zZWlkb244X2hhc2hNYW55KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpLCBudW1fb3V0cHV0cyk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUG9zZWlkb24gaGFzaCB3aXRoIGFuIGlucHV0IHJhdGUgb2YgOCBvbiB0aGUgc2NhbGFyIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7U2NhbGFyfVxuICAgICAqL1xuICAgIGhhc2hUb1NjYWxhcihpbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnBvc2VpZG9uOF9oYXNoVG9TY2FsYXIocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChpbnB1dCkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFBvc2VpZG9uIGhhc2ggd2l0aCBhbiBpbnB1dCByYXRlIG9mIDggb24gdGhlIGFmZmluZSBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0XG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIGhhc2hUb0dyb3VwKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucG9zZWlkb244X2hhc2hUb0dyb3VwKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGFkZEhlYXBPYmplY3QoaW5wdXQpKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBQcml2YXRlS2V5RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3ByaXZhdGVrZXlfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogUHJpdmF0ZSBrZXkgb2YgYW4gQWxlbyBhY2NvdW50XG4gKi9cbmNsYXNzIFByaXZhdGVLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFByaXZhdGVLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUHJpdmF0ZUtleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQcml2YXRlS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wcml2YXRla2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBuZXcgcHJpdmF0ZSBrZXkgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByaXZhdGVrZXlfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICBQcml2YXRlS2V5RmluYWxpemF0aW9uLnJlZ2lzdGVyKHRoaXMsIHRoaXMuX193YmdfcHRyLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHByaXZhdGUga2V5IGZyb20gYSBzZXJpZXMgb2YgdW5jaGVja2VkIGJ5dGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNlZWQgVW5jaGVja2VkIDMyIGJ5dGUgbG9uZyBVaW50OEFycmF5IGFjdGluZyBhcyB0aGUgc2VlZCBmb3IgdGhlIHByaXZhdGUga2V5XG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXl9XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzZWVkXG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21fc2VlZF91bmNoZWNrZWQoc2VlZCkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoc2VlZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcml2YXRla2V5X2Zyb21fc2VlZF91bmNoZWNrZWQocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBQcml2YXRlS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwcml2YXRlIGtleSBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcHJpdmF0ZSBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHByaXZhdGUga2V5XG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXl9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVfa2V5XG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21fc3RyaW5nKHByaXZhdGVfa2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcml2YXRlX2tleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucHJpdmF0ZWtleV9mcm9tX3N0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5LiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHZlcnkgY2FyZWZ1bGx5XG4gICAgICogYXMgaXQgZXhwb3NlcyB0aGUgcHJpdmF0ZSBrZXkgcGxhaW50ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBwcml2YXRlIGtleVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9fc3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcml2YXRla2V5X3RvX3N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmlldyBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWaWV3S2V5fVxuICAgICAqIEByZXR1cm5zIHtWaWV3S2V5fVxuICAgICAqL1xuICAgIHRvX3ZpZXdfa2V5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByaXZhdGVrZXlfdG9fdmlld19rZXkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVmlld0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByaXZhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICB0b19hZGRyZXNzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByaXZhdGVrZXlfdG9fYWRkcmVzcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBZGRyZXNzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGEgbWVzc2FnZSB3aXRoIHRoZSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBCeXRlIGFycmF5IHJlcHJlc2VudGluZyBhIG1lc3NhZ2Ugc2lnbmVkIGJ5IHRoZSBhZGRyZXNzXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX0gU2lnbmF0dXJlIGdlbmVyYXRlZCBieSBzaWduaW5nIHRoZSBtZXNzYWdlIHdpdGggdGhlIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfVxuICAgICAqL1xuICAgIHNpZ24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAobWVzc2FnZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcml2YXRla2V5X3NpZ24odGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBuZXcgcmFuZG9tbHkgZ2VuZXJhdGVkIHByaXZhdGUga2V5IGNpcGhlcnRleHQgdXNpbmcgYSBzZWNyZXQuIFRoZSBzZWNyZXQgaXMgc2Vuc2l0aXZlXG4gICAgICogYW5kIHdpbGwgYmUgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIHByaXZhdGUga2V5IGxhdGVyLCBzbyBpdCBzaG91bGQgYmUgc3RvcmVkIHNlY3VyZWx5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0IFNlY3JldCB1c2VkIHRvIGVuY3J5cHQgdGhlIHByaXZhdGUga2V5XG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXlDaXBoZXJ0ZXh0fSBDaXBoZXJ0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleUNpcGhlcnRleHR9XG4gICAgICovXG4gICAgc3RhdGljIG5ld0VuY3J5cHRlZChzZWNyZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNlY3JldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucHJpdmF0ZWtleV9uZXdFbmNyeXB0ZWQocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXlDaXBoZXJ0ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgYW4gZXhpc3RpbmcgcHJpdmF0ZSBrZXkgd2l0aCBhIHNlY3JldC4gVGhlIHNlY3JldCBpcyBzZW5zaXRpdmUgYW5kIHdpbGwgYmUgbmVlZGVkIHRvXG4gICAgICogZGVjcnlwdCB0aGUgcHJpdmF0ZSBrZXkgbGF0ZXIsIHNvIGl0IHNob3VsZCBiZSBzdG9yZWQgc2VjdXJlbHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXQgU2VjcmV0IHVzZWQgdG8gZW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleUNpcGhlcnRleHR9IENpcGhlcnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5Q2lwaGVydGV4dH1cbiAgICAgKi9cbiAgICB0b0NpcGhlcnRleHQoc2VjcmV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzZWNyZXQsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnByaXZhdGVrZXlfdG9DaXBoZXJ0ZXh0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleUNpcGhlcnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHByaXZhdGUga2V5IGZyb20gYSBwcml2YXRlIGtleSBjaXBoZXJ0ZXh0IGFuZCBzZWNyZXQgb3JpZ2luYWxseSB1c2VkIHRvIGVuY3J5cHQgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleUNpcGhlcnRleHR9IGNpcGhlcnRleHQgQ2lwaGVydGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VjcmV0IFNlY3JldCBvcmlnaW5hbGx5IHVzZWQgdG8gZW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleX0gUHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXlDaXBoZXJ0ZXh0fSBjaXBoZXJ0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleUNpcGhlcnRleHQoY2lwaGVydGV4dCwgc2VjcmV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhjaXBoZXJ0ZXh0LCBQcml2YXRlS2V5Q2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc2VjcmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcml2YXRla2V5X2Zyb21Qcml2YXRlS2V5Q2lwaGVydGV4dChyZXRwdHIsIGNpcGhlcnRleHQuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFByaXZhdGVLZXlDaXBoZXJ0ZXh0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3ByaXZhdGVrZXljaXBoZXJ0ZXh0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFByaXZhdGUgS2V5IGluIGNpcGhlcnRleHQgZm9ybVxuICovXG5jbGFzcyBQcml2YXRlS2V5Q2lwaGVydGV4dCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUHJpdmF0ZUtleUNpcGhlcnRleHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUHJpdmF0ZUtleUNpcGhlcnRleHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUHJpdmF0ZUtleUNpcGhlcnRleHRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3ByaXZhdGVrZXljaXBoZXJ0ZXh0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCBhIHByaXZhdGUga2V5IHVzaW5nIGEgc2VjcmV0IHN0cmluZy4gVGhlIHNlY3JldCBpcyBzZW5zaXRpdmUgYW5kIHdpbGwgYmUgbmVlZGVkIHRvXG4gICAgICogZGVjcnlwdCB0aGUgcHJpdmF0ZSBrZXkgbGF0ZXIsIHNvIGl0IHNob3VsZCBiZSBzdG9yZWQgc2VjdXJlbHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgUHJpdmF0ZSBrZXkgdG8gZW5jcnlwdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXQgU2VjcmV0IHRvIGVuY3J5cHQgdGhlIHByaXZhdGUga2V5IHdpdGhcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleUNpcGhlcnRleHR9IFByaXZhdGUga2V5IGNpcGhlcnRleHRcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5Q2lwaGVydGV4dH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jcnlwdFByaXZhdGVLZXkocHJpdmF0ZV9rZXksIHNlY3JldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHNlY3JldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucHJpdmF0ZWtleV90b0NpcGhlcnRleHQocmV0cHRyLCBwcml2YXRlX2tleS5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleUNpcGhlcnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcnlwdHMgYSBwcml2YXRlIGNpcGhlcnRleHQgdXNpbmcgYSBzZWNyZXQgc3RyaW5nLiBUaGlzIG11c3QgYmUgdGhlIHNhbWUgc2VjcmV0IHVzZWQgdG9cbiAgICAgKiBlbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldCBTZWNyZXQgdXNlZCB0byBlbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5fSBQcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleX1cbiAgICAgKi9cbiAgICBkZWNyeXB0VG9Qcml2YXRlS2V5KHNlY3JldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoc2VjcmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcml2YXRla2V5Y2lwaGVydGV4dF9kZWNyeXB0VG9Qcml2YXRlS2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaXBoZXJ0ZXh0IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ2lwaGVydGV4dCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5jaXBoZXJ0ZXh0X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByaXZhdGVLZXlDaXBoZXJ0ZXh0IGZyb20gYSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaXBoZXJ0ZXh0IENpcGhlcnRleHQgc3RyaW5nXG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXlDaXBoZXJ0ZXh0fSBQcml2YXRlIGtleSBjaXBoZXJ0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNpcGhlcnRleHRcbiAgICAgKiBAcmV0dXJucyB7UHJpdmF0ZUtleUNpcGhlcnRleHR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoY2lwaGVydGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY2lwaGVydGV4dCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucHJpdmF0ZWtleWNpcGhlcnRleHRfZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleUNpcGhlcnRleHQuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFByb2dyYW1GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcHJvZ3JhbV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBXZWJhc3NlbWJseSBSZXByZXNlbnRhdGlvbiBvZiBhbiBBbGVvIHByb2dyYW1cbiAqL1xuY2xhc3MgUHJvZ3JhbSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUHJvZ3JhbS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBQcm9ncmFtRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFByb2dyYW1GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Byb2dyYW1fZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwcm9ncmFtIGZyb20gYSBwcm9ncmFtIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW0gQWxlbyBwcm9ncmFtIHNvdXJjZSBjb2RlXG4gICAgICogQHJldHVybnMge1Byb2dyYW19IFByb2dyYW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1cbiAgICAgKiBAcmV0dXJucyB7UHJvZ3JhbX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhwcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb2dyYW0uX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgY29udGFpbmluZyB0aGUgcHJvZ3JhbSBzb3VyY2UgY29kZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnByb2dyYW1fdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSBmdW5jdGlvbiBpcyBwcmVzZW50IGluIHRoZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm9ncmFtIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25fbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0Z1bmN0aW9uKGZ1bmN0aW9uX25hbWUpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGZ1bmN0aW9uX25hbWUsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtX2hhc0Z1bmN0aW9uKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGphdmFzY3JpcHQgYXJyYXkgb2YgZnVuY3Rpb25zIG5hbWVzIGluIHRoZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGFsbCBmdW5jdGlvbiBuYW1lcyBwcmVzZW50IGluIHRoZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGV4cGVjdGVkX2Z1bmN0aW9ucyA9IFtcbiAgICAgKiAgIFwibWludFwiLFxuICAgICAqICAgXCJ0cmFuc2Zlcl9wcml2YXRlXCIsXG4gICAgICogICBcInRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljXCIsXG4gICAgICogICBcInRyYW5zZmVyX3B1YmxpY1wiLFxuICAgICAqICAgXCJ0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZVwiLFxuICAgICAqICAgXCJqb2luXCIsXG4gICAgICogICBcInNwbGl0XCIsXG4gICAgICogICBcImZlZVwiXG4gICAgICogXVxuICAgICAqXG4gICAgICogY29uc3QgY3JlZGl0c19wcm9ncmFtID0gYWxlb193YXNtLlByb2dyYW0uZ2V0Q3JlZGl0c1Byb2dyYW0oKTtcbiAgICAgKiBjb25zdCBjcmVkaXRzX2Z1bmN0aW9ucyA9IGNyZWRpdHNfcHJvZ3JhbS5nZXRGdW5jdGlvbnMoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjcmVkaXRzX2Z1bmN0aW9ucyA9PT0gZXhwZWN0ZWRfZnVuY3Rpb25zKTsgLy8gT3V0cHV0IHNob3VsZCBiZSBcInRydWVcIlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtX2dldEZ1bmN0aW9ucyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbiBpbnB1dHMgYW5kIHR5cGVzLiBUaGlzIGNhbiBiZSB1c2VkXG4gICAgICogdG8gZ2VuZXJhdGUgYSB3ZWIgZm9ybSB0byBjYXB0dXJlIHVzZXIgaW5wdXRzIGZvciBhbiBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbl9uYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGdldCBpbnB1dHMgZm9yXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBmdW5jdGlvbiBpbnB1dHNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZXhwZWN0ZWRfaW5wdXRzID0gW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgdHlwZTpcInJlY29yZFwiLFxuICAgICAqICAgICAgIHZpc2liaWxpdHk6XCJwcml2YXRlXCIsXG4gICAgICogICAgICAgcmVjb3JkOlwiY3JlZGl0c1wiLFxuICAgICAqICAgICAgIG1lbWJlcnM6W1xuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICBuYW1lOlwibWljcm9jcmVkaXRzXCIsXG4gICAgICogICAgICAgICAgIHR5cGU6XCJ1NjRcIixcbiAgICAgKiAgICAgICAgICAgdmlzaWJpbGl0eTpcInByaXZhdGVcIlxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAgcmVnaXN0ZXI6XCJyMFwiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICB0eXBlOlwiYWRkcmVzc1wiLFxuICAgICAqICAgICAgIHZpc2liaWxpdHk6XCJwcml2YXRlXCIsXG4gICAgICogICAgICAgcmVnaXN0ZXI6XCJyMVwiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICB0eXBlOlwidTY0XCIsXG4gICAgICogICAgICAgdmlzaWJpbGl0eTpcInByaXZhdGVcIixcbiAgICAgKiAgICAgICByZWdpc3RlcjpcInIyXCJcbiAgICAgKiAgICAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBjb25zdCBjcmVkaXRzX3Byb2dyYW0gPSBhbGVvX3dhc20uUHJvZ3JhbS5nZXRDcmVkaXRzUHJvZ3JhbSgpO1xuICAgICAqIGNvbnN0IHRyYW5zZmVyX2Z1bmN0aW9uX2lucHV0cyA9IGNyZWRpdHNfcHJvZ3JhbS5nZXRGdW5jdGlvbklucHV0cyhcInRyYW5zZmVyX3ByaXZhdGVcIik7XG4gICAgICogY29uc29sZS5sb2codHJhbnNmZXJfZnVuY3Rpb25faW5wdXRzID09PSBleHBlY3RlZF9pbnB1dHMpOyAvLyBPdXRwdXQgc2hvdWxkIGJlIFwidHJ1ZVwiXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uX25hbWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbklucHV0cyhmdW5jdGlvbl9uYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChmdW5jdGlvbl9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2dldEZ1bmN0aW9uSW5wdXRzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHRoZSBsaXN0IG9mIGEgcHJvZ3JhbSdzIG1hcHBpbmdzIGFuZCB0aGUgbmFtZXMvdHlwZXMgb2YgdGhlaXIga2V5cyBhbmQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBtYXBwaW5ncyBpbiB0aGUgcHJvZ3JhbVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZXhwZWN0ZWRfbWFwcGluZ3MgPSBbXG4gICAgICogICAge1xuICAgICAqICAgICAgIG5hbWU6IFwiYWNjb3VudFwiLFxuICAgICAqICAgICAgIGtleV9uYW1lOiBcIm93bmVyXCIsXG4gICAgICogICAgICAga2V5X3R5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAqICAgICAgIHZhbHVlX25hbWU6IFwibWljcm9jcmVkaXRzXCIsXG4gICAgICogICAgICAgdmFsdWVfdHlwZTogXCJ1NjRcIlxuICAgICAqICAgIH1cbiAgICAgKiBdXG4gICAgICpcbiAgICAgKiBjb25zdCBjcmVkaXRzX3Byb2dyYW0gPSBhbGVvX3dhc20uUHJvZ3JhbS5nZXRDcmVkaXRzUHJvZ3JhbSgpO1xuICAgICAqIGNvbnN0IGNyZWRpdHNfbWFwcGluZ3MgPSBjcmVkaXRzX3Byb2dyYW0uZ2V0TWFwcGluZ3MoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjcmVkaXRzX21hcHBpbmdzID09PSBleHBlY3RlZF9tYXBwaW5ncyk7IC8vIE91dHB1dCBzaG91bGQgYmUgXCJ0cnVlXCJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRNYXBwaW5ncygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2dldE1hcHBpbmdzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcHJvZ3JhbSByZWNvcmQgYW5kIGl0cyB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlY29yZF9uYW1lIE5hbWUgb2YgdGhlIHJlY29yZCB0byBnZXQgbWVtYmVycyBmb3JcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgcmVjb3JkIG5hbWUsIHR5cGUsIGFuZCBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY29uc3QgZXhwZWN0ZWRfcmVjb3JkID0ge1xuICAgICAqICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAqICAgICByZWNvcmQ6IFwiQ3JlZGl0c1wiLFxuICAgICAqICAgICBtZW1iZXJzOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAqICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICogICAgICAgICB2aXNpYmlsaXR5OiBcInByaXZhdGVcIlxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgbmFtZTogXCJtaWNyb2NyZWRpdHNcIixcbiAgICAgKiAgICAgICAgIHR5cGU6IFwidTY0XCIsXG4gICAgICogICAgICAgICB2aXNpYmlsaXR5OiBcInByaXZhdGVcIlxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXTtcbiAgICAgKiAgfTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNyZWRpdHNfcHJvZ3JhbSA9IGFsZW9fd2FzbS5Qcm9ncmFtLmdldENyZWRpdHNQcm9ncmFtKCk7XG4gICAgICogY29uc3QgY3JlZGl0c19yZWNvcmQgPSBjcmVkaXRzX3Byb2dyYW0uZ2V0UmVjb3JkTWVtYmVycyhcIkNyZWRpdHNcIik7XG4gICAgICogY29uc29sZS5sb2coY3JlZGl0c19yZWNvcmQgPT09IGV4cGVjdGVkX3JlY29yZCk7IC8vIE91dHB1dCBzaG91bGQgYmUgXCJ0cnVlXCJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjb3JkX25hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlY29yZE1lbWJlcnMocmVjb3JkX25hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJlY29yZF9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2dldFJlY29yZE1lbWJlcnMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwcm9ncmFtIHN0cnVjdCBhbmQgaXRzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RydWN0X25hbWUgTmFtZSBvZiB0aGUgc3RydWN0IHRvIGdldCBtZW1iZXJzIGZvclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyB0aGUgc3RydWN0IG1lbWJlcnNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCBTVFJVQ1RfUFJPR1JBTSA9IFwicHJvZ3JhbSB0b2tlbl9pc3N1ZS5hbGVvO1xuICAgICAqXG4gICAgICogc3RydWN0IHRva2VuX21ldGFkYXRhOlxuICAgICAqICAgICBuZXR3b3JrIGFzIHUzMjtcbiAgICAgKiAgICAgdmVyc2lvbiBhcyB1MzI7XG4gICAgICpcbiAgICAgKiBzdHJ1Y3QgdG9rZW46XG4gICAgICogICAgIHRva2VuX2lkIGFzIHUzMjtcbiAgICAgKiAgICAgbWV0YWRhdGEgYXMgdG9rZW5fbWV0YWRhdGE7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBub19vcDpcbiAgICAgKiAgICBpbnB1dCByMCBhcyB1NjQ7XG4gICAgICogICAgb3V0cHV0IHIwIGFzIHU2NDtcIlxuICAgICAqXG4gICAgICogY29uc3QgZXhwZWN0ZWRfc3RydWN0X21lbWJlcnMgPSBbXG4gICAgICogICAge1xuICAgICAqICAgICAgbmFtZTogXCJ0b2tlbl9pZFwiLFxuICAgICAqICAgICAgdHlwZTogXCJ1MzJcIixcbiAgICAgKiAgICB9LFxuICAgICAqICAgIHtcbiAgICAgKiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgKiAgICAgIHR5cGU6IFwic3RydWN0XCIsXG4gICAgICogICAgICBzdHJ1Y3RfaWQ6IFwidG9rZW5fbWV0YWRhdGFcIixcbiAgICAgKiAgICAgIG1lbWJlcnM6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBuYW1lOiBcIm5ldHdvcmtcIixcbiAgICAgKiAgICAgICAgIHR5cGU6IFwidTMyXCIsXG4gICAgICogICAgICAgfVxuICAgICAqICAgICAgIHtcbiAgICAgKiAgICAgICAgIG5hbWU6IFwidmVyc2lvblwiLFxuICAgICAqICAgICAgICAgdHlwZTogXCJ1MzJcIixcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIF1cbiAgICAgKiAgIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogY29uc3QgcHJvZ3JhbSA9IGFsZW9fd2FzbS5Qcm9ncmFtLmZyb21TdHJpbmcoU1RSVUNUX1BST0dSQU0pO1xuICAgICAqIGNvbnN0IHN0cnVjdF9tZW1iZXJzID0gcHJvZ3JhbS5nZXRTdHJ1Y3RNZW1iZXJzKFwidG9rZW5cIik7XG4gICAgICogY29uc29sZS5sb2coc3RydWN0X21lbWJlcnMgPT09IGV4cGVjdGVkX3N0cnVjdF9tZW1iZXJzKTsgLy8gT3V0cHV0IHNob3VsZCBiZSBcInRydWVcIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3RfbmFtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGdldFN0cnVjdE1lbWJlcnMoc3RydWN0X25hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN0cnVjdF9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2dldFN0cnVjdE1lbWJlcnMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb2dyYW19IFRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtQcm9ncmFtfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDcmVkaXRzUHJvZ3JhbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtX2dldENyZWRpdHNQcm9ncmFtKCk7XG4gICAgICAgIHJldHVybiBQcm9ncmFtLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIHByb2dyYW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm9ncmFtX2lkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdW5pcXVlIGFkZHJlc3Mgb2YgdGhlIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfSBUaGUgYWRkcmVzcyBvZiB0aGUgcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIGFkZHJlc3MoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucHJvZ3JhbV9hZGRyZXNzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgZXF1YWxpdHkgd2l0aCBhbm90aGVyIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvZ3JhbX0gb3RoZXIgVGhlIG90aGVyIHByb2dyYW0gdG8gY29tcGFyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm9ncmFtcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSB7UHJvZ3JhbX0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgUHJvZ3JhbSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvZ3JhbV9pc0VxdWFsKHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvZ3JhbV9pbXBvcnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwcm9ncmFtIGltcG9ydHNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjb25zdCBET1VCTEVfVEVTVCA9IFwiaW1wb3J0IG11bHRpcGx5X3Rlc3QuYWxlbztcbiAgICAgKlxuICAgICAqIHByb2dyYW0gZG91YmxlX3Rlc3QuYWxlbztcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZV9pdDpcbiAgICAgKiAgICAgaW5wdXQgcjAgYXMgdTMyLnByaXZhdGU7XG4gICAgICogICAgIGNhbGwgbXVsdGlwbHlfdGVzdC5hbGVvL211bHRpcGx5IDJ1MzIgcjAgaW50byByMTtcbiAgICAgKiAgICAgb3V0cHV0IHIxIGFzIHUzMi5wcml2YXRlO1wiO1xuICAgICAqXG4gICAgICogY29uc3QgZXhwZWN0ZWRfaW1wb3J0cyA9IFtcbiAgICAgKiAgICBcIm11bHRpcGx5X3Rlc3QuYWxlb1wiXG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHByb2dyYW0gPSBhbGVvX3dhc20uUHJvZ3JhbS5mcm9tU3RyaW5nKERPVUJMRV9URVNUX1BST0dSQU0pO1xuICAgICAqIGNvbnN0IGltcG9ydHMgPSBwcm9ncmFtLmdldEltcG9ydHMoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhpbXBvcnRzID09PSBleHBlY3RlZF9pbXBvcnRzKTsgLy8gT3V0cHV0IHNob3VsZCBiZSBcInRydWVcIlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGdldEltcG9ydHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvZ3JhbV9nZXRJbXBvcnRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFByb2dyYW1NYW5hZ2VyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Byb2dyYW1tYW5hZ2VyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFByb2dyYW1NYW5hZ2VyIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUHJvZ3JhbU1hbmFnZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Byb2dyYW1tYW5hZ2VyX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95IGFuIEFsZW8gcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtIHByaXZhdGVfa2V5IFRoZSBwcml2YXRlIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICogQHBhcmFtIHByb2dyYW0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBwcm9ncmFtIGJlaW5nIGRlcGxveWVkXG4gICAgICogQHBhcmFtIGltcG9ydHMgQSBqYXZhc2NyaXB0IG9iamVjdCBob2xkaW5nIHRoZSBzb3VyY2UgY29kZSBvZiBhbnkgaW1wb3J0ZWQgcHJvZ3JhbXMgaW4gdGhlXG4gICAgICogZm9ybSBcXHtcInByb2dyYW1fbmFtZTFcIjogXCJwcm9ncmFtX3NvdXJjZV9jb2RlXCIsIFwicHJvZ3JhbV9uYW1lMlwiOiBcInByb2dyYW1fc291cmNlX2NvZGVcIiwgLi5cXH0uXG4gICAgICogTm90ZSB0aGF0IGFsbCBpbXBvcnRlZCBwcm9ncmFtcyBtdXN0IGJlIGRlcGxveWVkIG9uIGNoYWluIGJlZm9yZSB0aGUgbWFpbiBwcm9ncmFtIGluIG9yZGVyXG4gICAgICogZm9yIHRoZSBkZXBsb3ltZW50IHRvIHN1Y2NlZWRcbiAgICAgKiBAcGFyYW0gZmVlX2NyZWRpdHMgVGhlIGFtb3VudCBvZiBjcmVkaXRzIHRvIHBheSBhcyBhIGZlZVxuICAgICAqIEBwYXJhbSBmZWVfcmVjb3JkIFRoZSByZWNvcmQgdG8gc3BlbmQgdGhlIGZlZSBmcm9tXG4gICAgICogQHBhcmFtIHVybCBUaGUgdXJsIG9mIHRoZSBBbGVvIG5ldHdvcmsgbm9kZSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiB0b1xuICAgICAqIEBwYXJhbSBpbXBvcnRzIChvcHRpb25hbCkgUHJvdmlkZSBhIGxpc3Qgb2YgaW1wb3J0cyB0byB1c2UgZm9yIHRoZSBwcm9ncmFtIGRlcGxveW1lbnQgaW4gdGhlXG4gICAgICogZm9ybSBvZiBhIGphdmFzY3JpcHQgb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBhIHN0cmluZyBvZiB0aGUgcHJvZ3JhbSBuYW1lIGFuZCB0aGUgdmFsdWVzXG4gICAgICogYXJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcHJvZ3JhbSBzb3VyY2UgY29kZSBcXHsgXCJoZWxsby5hbGVvXCI6IFwiaGVsbG8uYWxlbyBzb3VyY2UgY29kZVwiIFxcfVxuICAgICAqIEBwYXJhbSBmZWVfcHJvdmluZ19rZXkgKG9wdGlvbmFsKSBQcm92aWRlIGEgcHJvdmluZyBrZXkgdG8gdXNlIGZvciB0aGUgZmVlIGV4ZWN1dGlvblxuICAgICAqIEBwYXJhbSBmZWVfdmVyaWZ5aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIGZlZSBleGVjdXRpb25cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259XG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZlZV9jcmVkaXRzXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBudWxsfSBbZmVlX3JlY29yZF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFt1cmxdXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSBbaW1wb3J0c11cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbZmVlX3Byb3Zpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5IHwgbnVsbH0gW2ZlZV92ZXJpZnlpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgbnVsbH0gW29mZmxpbmVfcXVlcnldXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZERlcGxveW1lbnRUcmFuc2FjdGlvbihwcml2YXRlX2tleSwgcHJvZ3JhbSwgZmVlX2NyZWRpdHMsIGZlZV9yZWNvcmQsIHVybCwgaW1wb3J0cywgZmVlX3Byb3Zpbmdfa2V5LCBmZWVfdmVyaWZ5aW5nX2tleSwgb2ZmbGluZV9xdWVyeSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBsZXQgcHRyMSA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShmZWVfcmVjb3JkKSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZlZV9yZWNvcmQsIFJlY29yZFBsYWludGV4dCk7XG4gICAgICAgICAgICBwdHIxID0gZmVlX3JlY29yZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHRyMiA9IGlzTGlrZU5vbmUodXJsKSA/IDAgOiBwYXNzU3RyaW5nVG9XYXNtMCh1cmwsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgdmFyIGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGxldCBwdHIzID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfcHJvdmluZ19rZXksIFByb3ZpbmdLZXkpO1xuICAgICAgICAgICAgcHRyMyA9IGZlZV9wcm92aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyNCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShmZWVfdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfdmVyaWZ5aW5nX2tleSwgVmVyaWZ5aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjQgPSBmZWVfdmVyaWZ5aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyNSA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShvZmZsaW5lX3F1ZXJ5KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG9mZmxpbmVfcXVlcnksIE9mZmxpbmVRdWVyeSk7XG4gICAgICAgICAgICBwdHI1ID0gb2ZmbGluZV9xdWVyeS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb2dyYW1tYW5hZ2VyX2J1aWxkRGVwbG95bWVudFRyYW5zYWN0aW9uKHByaXZhdGVfa2V5Ll9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgZmVlX2NyZWRpdHMsIHB0cjEsIHB0cjIsIGxlbjIsIGlzTGlrZU5vbmUoaW1wb3J0cykgPyAwIDogYWRkSGVhcE9iamVjdChpbXBvcnRzKSwgcHRyMywgcHRyNCwgcHRyNSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgcHJvZ3JhbSBkZXBsb3ltZW50XG4gICAgICpcbiAgICAgKiBEaXNjbGFpbWVyOiBGZWUgZXN0aW1hdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIG1heSBub3QgcmVwcmVzZW50IGEgY29ycmVjdCBlc3RpbWF0ZSBvbiBhbnkgY3VycmVudCBvciBmdXR1cmUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHByb2dyYW0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBwcm9ncmFtIGJlaW5nIGRlcGxveWVkXG4gICAgICogQHBhcmFtIGltcG9ydHMgKG9wdGlvbmFsKSBQcm92aWRlIGEgbGlzdCBvZiBpbXBvcnRzIHRvIHVzZSBmb3IgdGhlIGRlcGxveW1lbnQgZmVlIGVzdGltYXRpb25cbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIGphdmFzY3JpcHQgb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBhIHN0cmluZyBvZiB0aGUgcHJvZ3JhbSBuYW1lIGFuZCB0aGUgdmFsdWVzXG4gICAgICogYXJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcHJvZ3JhbSBzb3VyY2UgY29kZSBcXHsgXCJoZWxsby5hbGVvXCI6IFwiaGVsbG8uYWxlbyBzb3VyY2UgY29kZVwiIFxcfVxuICAgICAqIEByZXR1cm5zIHt1NjR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1cbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IFtpbXBvcnRzXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJpZ2ludD59XG4gICAgICovXG4gICAgc3RhdGljIGVzdGltYXRlRGVwbG95bWVudEZlZShwcm9ncmFtLCBpbXBvcnRzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvZ3JhbW1hbmFnZXJfZXN0aW1hdGVEZXBsb3ltZW50RmVlKHB0cjAsIGxlbjAsIGlzTGlrZU5vbmUoaW1wb3J0cykgPyAwIDogYWRkSGVhcE9iamVjdChpbXBvcnRzKSk7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIHRoZSBjb21wb25lbnQgb2YgdGhlIGRlcGxveW1lbnQgY29zdCB3aGljaCBjb21lcyBmcm9tIHRoZSBmZWUgZm9yIHRoZSBwcm9ncmFtIG5hbWUuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgY29zdCBkb2VzIG5vdCByZXByZXNlbnQgdGhlIGVudGlyZSBjb3N0IG9mIGRlcGxveW1lbnQuIEl0IGlzIGFkZGl0aW9uYWwgdG9cbiAgICAgKiB0aGUgY29zdCBvZiB0aGUgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBkZXBsb3ltZW50LlxuICAgICAqXG4gICAgICogRGlzY2xhaW1lcjogRmVlIGVzdGltYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHJlcHJlc2VudCBhIGNvcnJlY3QgZXN0aW1hdGUgb24gYW55IGN1cnJlbnQgb3IgZnV0dXJlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIHRvIGJlIGRlcGxveWVkXG4gICAgICogQHJldHVybnMge3U2NH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgc3RhdGljIGVzdGltYXRlUHJvZ3JhbU5hbWVDb3N0KG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKG5hbWUsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnByb2dyYW1tYW5hZ2VyX2VzdGltYXRlUHJvZ3JhbU5hbWVDb3N0KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRCaWdJbnQ2NChyZXRwdHIgKyA4ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFuIGFyYml0cmFyeSBmdW5jdGlvbiBsb2NhbGx5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5IFRoZSBwcml2YXRlIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBwcm9ncmFtIGJlaW5nIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIEEgamF2YXNjcmlwdCBhcnJheSBvZiBpbnB1dHMgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcm92ZV9leGVjdXRpb24gSWYgdHJ1ZSwgdGhlIGV4ZWN1dGlvbiB3aWxsIGJlIHByb3ZlbiBhbmQgYW4gZXhlY3V0aW9uIG9iamVjdFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIHByb29mIGFuZCB0aGUgZW5jcnlwdGVkIGlucHV0cyBhbmQgb3V0cHV0cyBuZWVkZWQgdG8gdmVyaWZ5IHRoZSBwcm9vZiBvZmZsaW5lXG4gICAgICogd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhY2hlIENhY2hlIHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBpbiB0aGUgRXhlY3V0aW9uIHJlc3BvbnNlLlxuICAgICAqIElmIHRoaXMgaXMgc2V0IHRvICd0cnVlJyB0aGUga2V5cyBzeW50aGVzaXplZCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgRXhlY3V0aW9uIFJlc3BvbnNlXG4gICAgICogYW5kIHRoZSBgUHJvdmluZ0tleWAgYW5kIGBWZXJpZnlpbmdLZXlgIGNhbiBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgcmVzcG9uc2UgdmlhIHRoZSBgLmdldEtleXMoKWBcbiAgICAgKiBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3QgfCB1bmRlZmluZWR9IGltcG9ydHMgKG9wdGlvbmFsKSBQcm92aWRlIGEgbGlzdCBvZiBpbXBvcnRzIHRvIHVzZSBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpbiB0aGVcbiAgICAgKiBmb3JtIG9mIGEgamF2YXNjcmlwdCBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIGEgc3RyaW5nIG9mIHRoZSBwcm9ncmFtIG5hbWUgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmFtIHNvdXJjZSBjb2RlIFxceyBcImhlbGxvLmFsZW9cIjogXCJoZWxsby5hbGVvIHNvdXJjZSBjb2RlXCIgXFx9XG4gICAgICogQHBhcmFtIHtQcm92aW5nS2V5IHwgdW5kZWZpbmVkfSBwcm92aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvblxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5IHwgdW5kZWZpbmVkfSB2ZXJpZnlpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHZlcmlmeWluZyBrZXkgdG8gdXNlIGZvciB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IF9mdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gaW5wdXRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcm92ZV9leGVjdXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhY2hlXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSBbaW1wb3J0c11cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbcHJvdmluZ19rZXldXG4gICAgICogQHBhcmFtIHtWZXJpZnlpbmdLZXkgfCBudWxsfSBbdmVyaWZ5aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IFt1cmxdXG4gICAgICogQHBhcmFtIHtPZmZsaW5lUXVlcnkgfCBudWxsfSBbb2ZmbGluZV9xdWVyeV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeGVjdXRpb25SZXNwb25zZT59XG4gICAgICovXG4gICAgc3RhdGljIGV4ZWN1dGVGdW5jdGlvbk9mZmxpbmUocHJpdmF0ZV9rZXksIHByb2dyYW0sIF9mdW5jdGlvbiwgaW5wdXRzLCBwcm92ZV9leGVjdXRpb24sIGNhY2hlLCBpbXBvcnRzLCBwcm92aW5nX2tleSwgdmVyaWZ5aW5nX2tleSwgdXJsLCBvZmZsaW5lX3F1ZXJ5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwcml2YXRlX2tleSwgUHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChfZnVuY3Rpb24sIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgbGV0IHB0cjIgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUocHJvdmluZ19rZXkpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocHJvdmluZ19rZXksIFByb3ZpbmdLZXkpO1xuICAgICAgICAgICAgcHRyMiA9IHByb3Zpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHIzID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKHZlcmlmeWluZ19rZXkpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModmVyaWZ5aW5nX2tleSwgVmVyaWZ5aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjMgPSB2ZXJpZnlpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdHI0ID0gaXNMaWtlTm9uZSh1cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHVybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICB2YXIgbGVuNCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgbGV0IHB0cjUgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUob2ZmbGluZV9xdWVyeSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhvZmZsaW5lX3F1ZXJ5LCBPZmZsaW5lUXVlcnkpO1xuICAgICAgICAgICAgcHRyNSA9IG9mZmxpbmVfcXVlcnkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtbWFuYWdlcl9leGVjdXRlRnVuY3Rpb25PZmZsaW5lKHByaXZhdGVfa2V5Ll9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgYWRkSGVhcE9iamVjdChpbnB1dHMpLCBwcm92ZV9leGVjdXRpb24sIGNhY2hlLCBpc0xpa2VOb25lKGltcG9ydHMpID8gMCA6IGFkZEhlYXBPYmplY3QoaW1wb3J0cyksIHB0cjIsIHB0cjMsIHB0cjQsIGxlbjQsIHB0cjUpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIEFsZW8gZnVuY3Rpb24gYW5kIGNyZWF0ZSBhbiBBbGVvIGV4ZWN1dGlvbiB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHByaXZhdGVfa2V5IFRoZSBwcml2YXRlIGtleSBvZiB0aGUgc2VuZGVyXG4gICAgICogQHBhcmFtIHByb2dyYW0gVGhlIHNvdXJjZSBjb2RlIG9mIHRoZSBwcm9ncmFtIGJlaW5nIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIGlucHV0cyBBIGphdmFzY3JpcHQgYXJyYXkgb2YgaW5wdXRzIHRvIHRoZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBmZWVfY3JlZGl0cyBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gcGF5IGFzIGEgZmVlXG4gICAgICogQHBhcmFtIGZlZV9yZWNvcmQgVGhlIHJlY29yZCB0byBzcGVuZCB0aGUgZmVlIGZyb21cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIEFsZW8gbmV0d29yayBub2RlIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgICogSWYgdGhpcyBpcyBzZXQgdG8gJ3RydWUnIHRoZSBrZXlzIHN5bnRoZXNpemVkIChvciBwYXNzZWQgaW4gYXMgb3B0aW9uYWwgcGFyYW1ldGVycyB2aWEgdGhlXG4gICAgICogYHByb3Zpbmdfa2V5YCBhbmQgYHZlcmlmeWluZ19rZXlgIGFyZ3VtZW50cykgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIFByb2dyYW1NYW5hZ2VyJ3MgbWVtb3J5XG4gICAgICogYW5kIHVzZWQgZm9yIHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBJZiB0aGlzIGlzIHNldCB0byAnZmFsc2UnIHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmdcbiAgICAgKiBrZXlzIHdpbGwgYmUgZGVhbGxvY2F0ZWQgZnJvbSBtZW1vcnkgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSBpbXBvcnRzIChvcHRpb25hbCkgUHJvdmlkZSBhIGxpc3Qgb2YgaW1wb3J0cyB0byB1c2UgZm9yIHRoZSBmdW5jdGlvbiBleGVjdXRpb24gaW4gdGhlXG4gICAgICogZm9ybSBvZiBhIGphdmFzY3JpcHQgb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBhIHN0cmluZyBvZiB0aGUgcHJvZ3JhbSBuYW1lIGFuZCB0aGUgdmFsdWVzXG4gICAgICogYXJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcHJvZ3JhbSBzb3VyY2UgY29kZSBcXHsgXCJoZWxsby5hbGVvXCI6IFwiaGVsbG8uYWxlbyBzb3VyY2UgY29kZVwiIFxcfVxuICAgICAqIEBwYXJhbSBwcm92aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvblxuICAgICAqIEBwYXJhbSB2ZXJpZnlpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHZlcmlmeWluZyBrZXkgdG8gdXNlIGZvciB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIGZlZV9wcm92aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSBwcm92aW5nIGtleSB0byB1c2UgZm9yIHRoZSBmZWUgZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIGZlZV92ZXJpZnlpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHZlcmlmeWluZyBrZXkgdG8gdXNlIGZvciB0aGUgZmVlIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn1cbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gX2Z1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlX2NyZWRpdHNcbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dCB8IG51bGx9IFtmZWVfcmVjb3JkXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW3VybF1cbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IFtpbXBvcnRzXVxuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleSB8IG51bGx9IFtwcm92aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge1ZlcmlmeWluZ0tleSB8IG51bGx9IFt2ZXJpZnlpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleSB8IG51bGx9IFtmZWVfcHJvdmluZ19rZXldXG4gICAgICogQHBhcmFtIHtWZXJpZnlpbmdLZXkgfCBudWxsfSBbZmVlX3ZlcmlmeWluZ19rZXldXG4gICAgICogQHBhcmFtIHtPZmZsaW5lUXVlcnkgfCBudWxsfSBbb2ZmbGluZV9xdWVyeV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24ocHJpdmF0ZV9rZXksIHByb2dyYW0sIF9mdW5jdGlvbiwgaW5wdXRzLCBmZWVfY3JlZGl0cywgZmVlX3JlY29yZCwgdXJsLCBpbXBvcnRzLCBwcm92aW5nX2tleSwgdmVyaWZ5aW5nX2tleSwgZmVlX3Byb3Zpbmdfa2V5LCBmZWVfdmVyaWZ5aW5nX2tleSwgb2ZmbGluZV9xdWVyeSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoX2Z1bmN0aW9uLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGxldCBwdHIyID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV9yZWNvcmQpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZmVlX3JlY29yZCwgUmVjb3JkUGxhaW50ZXh0KTtcbiAgICAgICAgICAgIHB0cjIgPSBmZWVfcmVjb3JkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdHIzID0gaXNMaWtlTm9uZSh1cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHVybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgbGV0IHB0cjQgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUocHJvdmluZ19rZXkpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocHJvdmluZ19rZXksIFByb3ZpbmdLZXkpO1xuICAgICAgICAgICAgcHRyNCA9IHByb3Zpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI1ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKHZlcmlmeWluZ19rZXkpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3ModmVyaWZ5aW5nX2tleSwgVmVyaWZ5aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjUgPSB2ZXJpZnlpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI2ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfcHJvdmluZ19rZXksIFByb3ZpbmdLZXkpO1xuICAgICAgICAgICAgcHRyNiA9IGZlZV9wcm92aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyNyA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShmZWVfdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfdmVyaWZ5aW5nX2tleSwgVmVyaWZ5aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjcgPSBmZWVfdmVyaWZ5aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyOCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShvZmZsaW5lX3F1ZXJ5KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG9mZmxpbmVfcXVlcnksIE9mZmxpbmVRdWVyeSk7XG4gICAgICAgICAgICBwdHI4ID0gb2ZmbGluZV9xdWVyeS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb2dyYW1tYW5hZ2VyX2J1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24ocHJpdmF0ZV9rZXkuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xLCBhZGRIZWFwT2JqZWN0KGlucHV0cyksIGZlZV9jcmVkaXRzLCBwdHIyLCBwdHIzLCBsZW4zLCBpc0xpa2VOb25lKGltcG9ydHMpID8gMCA6IGFkZEhlYXBPYmplY3QoaW1wb3J0cyksIHB0cjQsIHB0cjUsIHB0cjYsIHB0cjcsIHB0cjgpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RpbWF0ZSBGZWUgZm9yIEFsZW8gZnVuY3Rpb24gZXhlY3V0aW9uLiBOb3RlIGlmIFwiY2FjaGVcIiBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHByb3ZpbmcgYW5kXG4gICAgICogdmVyaWZ5aW5nIGtleXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIFByb2dyYW1NYW5hZ2VyJ3MgbWVtb3J5IGFuZCB1c2VkIGZvciBzdWJzZXF1ZW50XG4gICAgICogcHJvZ3JhbSBleGVjdXRpb25zLlxuICAgICAqXG4gICAgICogRGlzY2xhaW1lcjogRmVlIGVzdGltYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHJlcHJlc2VudCBhIGNvcnJlY3QgZXN0aW1hdGUgb24gYW55IGN1cnJlbnQgb3IgZnV0dXJlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHNlbmRlclxuICAgICAqIEBwYXJhbSBwcm9ncmFtIFRoZSBzb3VyY2UgY29kZSBvZiB0aGUgcHJvZ3JhbSB0byBlc3RpbWF0ZSB0aGUgZXhlY3V0aW9uIGZlZSBmb3JcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb24gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0gaW5wdXRzIEEgamF2YXNjcmlwdCBhcnJheSBvZiBpbnB1dHMgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHVybCBUaGUgdXJsIG9mIHRoZSBBbGVvIG5ldHdvcmsgbm9kZSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiB0b1xuICAgICAqIEBwYXJhbSBpbXBvcnRzIChvcHRpb25hbCkgUHJvdmlkZSBhIGxpc3Qgb2YgaW1wb3J0cyB0byB1c2UgZm9yIHRoZSBmZWUgZXN0aW1hdGlvbiBpbiB0aGVcbiAgICAgKiBmb3JtIG9mIGEgamF2YXNjcmlwdCBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIGEgc3RyaW5nIG9mIHRoZSBwcm9ncmFtIG5hbWUgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmFtIHNvdXJjZSBjb2RlIFxceyBcImhlbGxvLmFsZW9cIjogXCJoZWxsby5hbGVvIHNvdXJjZSBjb2RlXCIgXFx9XG4gICAgICogQHBhcmFtIHByb3Zpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHZlcmlmeWluZyBrZXkgdG8gdXNlIGZvciB0aGUgZmVlIGVzdGltYXRpb25cbiAgICAgKiBAcGFyYW0gdmVyaWZ5aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIGZlZSBlc3RpbWF0aW9uXG4gICAgICogQHJldHVybnMge3U2NH0gRmVlIGluIG1pY3JvY3JlZGl0c1xuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBfZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGlucHV0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW3VybF1cbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IFtpbXBvcnRzXVxuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleSB8IG51bGx9IFtwcm92aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge1ZlcmlmeWluZ0tleSB8IG51bGx9IFt2ZXJpZnlpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgbnVsbH0gW29mZmxpbmVfcXVlcnldXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YmlnaW50Pn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXN0aW1hdGVFeGVjdXRpb25GZWUocHJpdmF0ZV9rZXksIHByb2dyYW0sIF9mdW5jdGlvbiwgaW5wdXRzLCB1cmwsIGltcG9ydHMsIHByb3Zpbmdfa2V5LCB2ZXJpZnlpbmdfa2V5LCBvZmZsaW5lX3F1ZXJ5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwcml2YXRlX2tleSwgUHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChfZnVuY3Rpb24sIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjIgPSBpc0xpa2VOb25lKHVybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAodXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIHZhciBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBsZXQgcHRyMyA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShwcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhwcm92aW5nX2tleSwgUHJvdmluZ0tleSk7XG4gICAgICAgICAgICBwdHIzID0gcHJvdmluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjQgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUodmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh2ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICAgICAgcHRyNCA9IHZlcmlmeWluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjUgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUob2ZmbGluZV9xdWVyeSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhvZmZsaW5lX3F1ZXJ5LCBPZmZsaW5lUXVlcnkpO1xuICAgICAgICAgICAgcHRyNSA9IG9mZmxpbmVfcXVlcnkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtbWFuYWdlcl9lc3RpbWF0ZUV4ZWN1dGlvbkZlZShwcml2YXRlX2tleS5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGFkZEhlYXBPYmplY3QoaW5wdXRzKSwgcHRyMiwgbGVuMiwgaXNMaWtlTm9uZShpbXBvcnRzKSA/IDAgOiBhZGRIZWFwT2JqZWN0KGltcG9ydHMpLCBwdHIzLCBwdHI0LCBwdHI1KTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdGhlIGZpbmFsaXplIGZlZSBjb21wb25lbnQgZm9yIGV4ZWN1dGluZyBhIGZ1bmN0aW9uLiBUaGlzIGZlZSBpcyBhZGRpdGlvbmFsIHRvIHRoZVxuICAgICAqIHNpemUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgcHJvZ3JhbSBpbiBieXRlcy4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYSBmaW5hbGl6ZVxuICAgICAqIHN0ZXAsIHRoZW4gdGhlIGZpbmFsaXplIGZlZSBpcyAwLlxuICAgICAqXG4gICAgICogRGlzY2xhaW1lcjogRmVlIGVzdGltYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgbm90IHJlcHJlc2VudCBhIGNvcnJlY3QgZXN0aW1hdGUgb24gYW55IGN1cnJlbnQgb3IgZnV0dXJlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9ncmFtIFRoZSBwcm9ncmFtIGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBmaW5hbGl6ZSBmZWUgZm9yXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZmluYWxpemUgZmVlIGZvclxuICAgICAqIEByZXR1cm5zIHt1NjR9IEZlZSBpbiBtaWNyb2NyZWRpdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBfZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBlc3RpbWF0ZUZpbmFsaXplRmVlKHByb2dyYW0sIF9mdW5jdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChfZnVuY3Rpb24sIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnByb2dyYW1tYW5hZ2VyX2VzdGltYXRlRmluYWxpemVGZWUocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEJpZ0ludDY0KHJldHB0ciArIDggKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdHdvIHJlY29yZHMgdG9nZXRoZXIgdG8gY3JlYXRlIGEgbmV3IHJlY29yZCB3aXRoIGFuIGFtb3VudCBvZiBjcmVkaXRzIGVxdWFsIHRvIHRoZSBzdW1cbiAgICAgKiBvZiB0aGUgY3JlZGl0cyBvZiB0aGUgdHdvIG9yaWdpbmFsIHJlY29yZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHNlbmRlclxuICAgICAqIEBwYXJhbSByZWNvcmRfMSBUaGUgZmlyc3QgcmVjb3JkIHRvIGNvbWJpbmVcbiAgICAgKiBAcGFyYW0gcmVjb3JkXzIgVGhlIHNlY29uZCByZWNvcmQgdG8gY29tYmluZVxuICAgICAqIEBwYXJhbSBmZWVfY3JlZGl0cyBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gcGF5IGFzIGEgZmVlXG4gICAgICogQHBhcmFtIGZlZV9yZWNvcmQgVGhlIHJlY29yZCB0byBzcGVuZCB0aGUgZmVlIGZyb21cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIEFsZW8gbmV0d29yayBub2RlIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgICogQHBhcmFtIGpvaW5fcHJvdmluZ19rZXkgKG9wdGlvbmFsKSBQcm92aWRlIGEgcHJvdmluZyBrZXkgdG8gdXNlIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBqb2luX3ZlcmlmeWluZ19rZXkgKG9wdGlvbmFsKSBQcm92aWRlIGEgdmVyaWZ5aW5nIGtleSB0byB1c2UgZm9yIHRoZSBqb2luIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZlZV9wcm92aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSBwcm92aW5nIGtleSB0byB1c2UgZm9yIHRoZSBmZWUgZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIGZlZV92ZXJpZnlpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHZlcmlmeWluZyBrZXkgdG8gdXNlIGZvciB0aGUgZmVlIGV4ZWN1dGlvblxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0fSByZWNvcmRfMVxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0fSByZWNvcmRfMlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmZWVfY3JlZGl0c1xuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgbnVsbH0gW2ZlZV9yZWNvcmRdXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBbdXJsXVxuICAgICAqIEBwYXJhbSB7UHJvdmluZ0tleSB8IG51bGx9IFtqb2luX3Byb3Zpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5IHwgbnVsbH0gW2pvaW5fdmVyaWZ5aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbZmVlX3Byb3Zpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5IHwgbnVsbH0gW2ZlZV92ZXJpZnlpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgbnVsbH0gW29mZmxpbmVfcXVlcnldXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZEpvaW5UcmFuc2FjdGlvbihwcml2YXRlX2tleSwgcmVjb3JkXzEsIHJlY29yZF8yLCBmZWVfY3JlZGl0cywgZmVlX3JlY29yZCwgdXJsLCBqb2luX3Byb3Zpbmdfa2V5LCBqb2luX3ZlcmlmeWluZ19rZXksIGZlZV9wcm92aW5nX2tleSwgZmVlX3ZlcmlmeWluZ19rZXksIG9mZmxpbmVfcXVlcnkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHByaXZhdGVfa2V5LCBQcml2YXRlS2V5KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJlY29yZF8xLCBSZWNvcmRQbGFpbnRleHQpO1xuICAgICAgICB2YXIgcHRyMCA9IHJlY29yZF8xLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmVjb3JkXzIsIFJlY29yZFBsYWludGV4dCk7XG4gICAgICAgIHZhciBwdHIxID0gcmVjb3JkXzIuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIGxldCBwdHIyID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV9yZWNvcmQpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoZmVlX3JlY29yZCwgUmVjb3JkUGxhaW50ZXh0KTtcbiAgICAgICAgICAgIHB0cjIgPSBmZWVfcmVjb3JkLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdHIzID0gaXNMaWtlTm9uZSh1cmwpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHVybCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICB2YXIgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgbGV0IHB0cjQgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoam9pbl9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhqb2luX3Byb3Zpbmdfa2V5LCBQcm92aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjQgPSBqb2luX3Byb3Zpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI1ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGpvaW5fdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhqb2luX3ZlcmlmeWluZ19rZXksIFZlcmlmeWluZ0tleSk7XG4gICAgICAgICAgICBwdHI1ID0gam9pbl92ZXJpZnlpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI2ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfcHJvdmluZ19rZXksIFByb3ZpbmdLZXkpO1xuICAgICAgICAgICAgcHRyNiA9IGZlZV9wcm92aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyNyA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShmZWVfdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfdmVyaWZ5aW5nX2tleSwgVmVyaWZ5aW5nS2V5KTtcbiAgICAgICAgICAgIHB0cjcgPSBmZWVfdmVyaWZ5aW5nX2tleS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyOCA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShvZmZsaW5lX3F1ZXJ5KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKG9mZmxpbmVfcXVlcnksIE9mZmxpbmVRdWVyeSk7XG4gICAgICAgICAgICBwdHI4ID0gb2ZmbGluZV9xdWVyeS5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb2dyYW1tYW5hZ2VyX2J1aWxkSm9pblRyYW5zYWN0aW9uKHByaXZhdGVfa2V5Ll9fd2JnX3B0ciwgcHRyMCwgcHRyMSwgZmVlX2NyZWRpdHMsIHB0cjIsIHB0cjMsIGxlbjMsIHB0cjQsIHB0cjUsIHB0cjYsIHB0cjcsIHB0cjgpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhbiBBbGVvIGNyZWRpdHMgcmVjb3JkIGludG8gdHdvIHNlcGFyYXRlIHJlY29yZHMuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmVxdWlyZSBhIGZlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHNlbmRlclxuICAgICAqIEBwYXJhbSBzcGxpdF9hbW91bnQgVGhlIGFtb3VudCBvZiB0aGUgY3JlZGl0IHNwbGl0LiBUaGlzIGFtb3VudCB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGVcbiAgICAgKiB2YWx1ZSBvZiB0aGUgcmVjb3JkIGFuZCB0d28gbmV3IHJlY29yZHMgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhlIHNwbGl0IGFtb3VudCBhbmQgdGhlIHJlbWFpbmRlclxuICAgICAqIEBwYXJhbSBhbW91bnRfcmVjb3JkIFRoZSByZWNvcmQgdG8gc3BsaXRcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIEFsZW8gbmV0d29yayBub2RlIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgICogQHBhcmFtIHNwbGl0X3Byb3Zpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHByb3Zpbmcga2V5IHRvIHVzZSBmb3IgdGhlIHNwbGl0IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHNwbGl0X3ZlcmlmeWluZ19rZXkgKG9wdGlvbmFsKSBQcm92aWRlIGEgdmVyaWZ5aW5nIGtleSB0byB1c2UgZm9yIHRoZSBzcGxpdCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGxpdF9hbW91bnRcbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dH0gYW1vdW50X3JlY29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW3VybF1cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbc3BsaXRfcHJvdmluZ19rZXldXG4gICAgICogQHBhcmFtIHtWZXJpZnlpbmdLZXkgfCBudWxsfSBbc3BsaXRfdmVyaWZ5aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge09mZmxpbmVRdWVyeSB8IG51bGx9IFtvZmZsaW5lX3F1ZXJ5XVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRTcGxpdFRyYW5zYWN0aW9uKHByaXZhdGVfa2V5LCBzcGxpdF9hbW91bnQsIGFtb3VudF9yZWNvcmQsIHVybCwgc3BsaXRfcHJvdmluZ19rZXksIHNwbGl0X3ZlcmlmeWluZ19rZXksIG9mZmxpbmVfcXVlcnkpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHByaXZhdGVfa2V5LCBQcml2YXRlS2V5KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFtb3VudF9yZWNvcmQsIFJlY29yZFBsYWludGV4dCk7XG4gICAgICAgIHZhciBwdHIwID0gYW1vdW50X3JlY29yZC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHVybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAodXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBsZXQgcHRyMiA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZShzcGxpdF9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzcGxpdF9wcm92aW5nX2tleSwgUHJvdmluZ0tleSk7XG4gICAgICAgICAgICBwdHIyID0gc3BsaXRfcHJvdmluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjMgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoc3BsaXRfdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzcGxpdF92ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICAgICAgcHRyMyA9IHNwbGl0X3ZlcmlmeWluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjQgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUob2ZmbGluZV9xdWVyeSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhvZmZsaW5lX3F1ZXJ5LCBPZmZsaW5lUXVlcnkpO1xuICAgICAgICAgICAgcHRyNCA9IG9mZmxpbmVfcXVlcnkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtbWFuYWdlcl9idWlsZFNwbGl0VHJhbnNhY3Rpb24ocHJpdmF0ZV9rZXkuX193YmdfcHRyLCBzcGxpdF9hbW91bnQsIHB0cjAsIHB0cjEsIGxlbjEsIHB0cjIsIHB0cjMsIHB0cjQpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGNyZWRpdHMgZnJvbSBvbmUgQWxlbyBhY2NvdW50IHRvIGFub3RoZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHNlbmRlclxuICAgICAqIEBwYXJhbSBhbW91bnRfY3JlZGl0cyBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gc2VuZFxuICAgICAqIEBwYXJhbSByZWNpcGllbnQgVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJfdHlwZSBUaGUgdHlwZSBvZiB0aGUgdHJhbnNmZXIgKG9wdGlvbnM6IFwicHJpdmF0ZVwiLCBcInB1YmxpY1wiLCBcInByaXZhdGVfdG9fcHVibGljXCIsIFwicHVibGljX3RvX3ByaXZhdGVcIilcbiAgICAgKiBAcGFyYW0gYW1vdW50X3JlY29yZCBUaGUgcmVjb3JkIHRvIGZ1bmQgdGhlIGFtb3VudCBmcm9tXG4gICAgICogQHBhcmFtIGZlZV9jcmVkaXRzIFRoZSBhbW91bnQgb2YgY3JlZGl0cyB0byBwYXkgYXMgYSBmZWVcbiAgICAgKiBAcGFyYW0gZmVlX3JlY29yZCBUaGUgcmVjb3JkIHRvIHNwZW5kIHRoZSBmZWUgZnJvbVxuICAgICAqIEBwYXJhbSB1cmwgVGhlIHVybCBvZiB0aGUgQWxlbyBuZXR3b3JrIG5vZGUgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJfdmVyaWZ5aW5nX2tleSAob3B0aW9uYWwpIFByb3ZpZGUgYSB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZmVlX3Byb3Zpbmdfa2V5IChvcHRpb25hbCkgUHJvdmlkZSBhIHByb3Zpbmcga2V5IHRvIHVzZSBmb3IgdGhlIGZlZSBleGVjdXRpb25cbiAgICAgKiBAcGFyYW0gZmVlX3ZlcmlmeWluZ19rZXkgKG9wdGlvbmFsKSBQcm92aWRlIGEgdmVyaWZ5aW5nIGtleSB0byB1c2UgZm9yIHRoZSBmZWUgZXhlY3V0aW9uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50X2NyZWRpdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjaXBpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVyX3R5cGVcbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dCB8IG51bGwgfCB1bmRlZmluZWR9IGFtb3VudF9yZWNvcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlX2NyZWRpdHNcbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dCB8IG51bGx9IFtmZWVfcmVjb3JkXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW3VybF1cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbdHJhbnNmZXJfcHJvdmluZ19rZXldXG4gICAgICogQHBhcmFtIHtWZXJpZnlpbmdLZXkgfCBudWxsfSBbdHJhbnNmZXJfdmVyaWZ5aW5nX2tleV1cbiAgICAgKiBAcGFyYW0ge1Byb3ZpbmdLZXkgfCBudWxsfSBbZmVlX3Byb3Zpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7VmVyaWZ5aW5nS2V5IHwgbnVsbH0gW2ZlZV92ZXJpZnlpbmdfa2V5XVxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgbnVsbH0gW29mZmxpbmVfcXVlcnldXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFRyYW5zZmVyVHJhbnNhY3Rpb24ocHJpdmF0ZV9rZXksIGFtb3VudF9jcmVkaXRzLCByZWNpcGllbnQsIHRyYW5zZmVyX3R5cGUsIGFtb3VudF9yZWNvcmQsIGZlZV9jcmVkaXRzLCBmZWVfcmVjb3JkLCB1cmwsIHRyYW5zZmVyX3Byb3Zpbmdfa2V5LCB0cmFuc2Zlcl92ZXJpZnlpbmdfa2V5LCBmZWVfcHJvdmluZ19rZXksIGZlZV92ZXJpZnlpbmdfa2V5LCBvZmZsaW5lX3F1ZXJ5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwcml2YXRlX2tleSwgUHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChyZWNpcGllbnQsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHRyYW5zZmVyX3R5cGUsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgbGV0IHB0cjIgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoYW1vdW50X3JlY29yZCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhbW91bnRfcmVjb3JkLCBSZWNvcmRQbGFpbnRleHQpO1xuICAgICAgICAgICAgcHRyMiA9IGFtb3VudF9yZWNvcmQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjMgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoZmVlX3JlY29yZCkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhmZWVfcmVjb3JkLCBSZWNvcmRQbGFpbnRleHQpO1xuICAgICAgICAgICAgcHRyMyA9IGZlZV9yZWNvcmQuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB0cjQgPSBpc0xpa2VOb25lKHVybCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAodXJsLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIHZhciBsZW40ID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBsZXQgcHRyNSA9IDA7XG4gICAgICAgIGlmICghaXNMaWtlTm9uZSh0cmFuc2Zlcl9wcm92aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2Zlcl9wcm92aW5nX2tleSwgUHJvdmluZ0tleSk7XG4gICAgICAgICAgICBwdHI1ID0gdHJhbnNmZXJfcHJvdmluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjYgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUodHJhbnNmZXJfdmVyaWZ5aW5nX2tleSkpIHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2Zlcl92ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICAgICAgcHRyNiA9IHRyYW5zZmVyX3ZlcmlmeWluZ19rZXkuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0cjcgPSAwO1xuICAgICAgICBpZiAoIWlzTGlrZU5vbmUoZmVlX3Byb3Zpbmdfa2V5KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZlZV9wcm92aW5nX2tleSwgUHJvdmluZ0tleSk7XG4gICAgICAgICAgICBwdHI3ID0gZmVlX3Byb3Zpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI4ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKGZlZV92ZXJpZnlpbmdfa2V5KSkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGZlZV92ZXJpZnlpbmdfa2V5LCBWZXJpZnlpbmdLZXkpO1xuICAgICAgICAgICAgcHRyOCA9IGZlZV92ZXJpZnlpbmdfa2V5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHI5ID0gMDtcbiAgICAgICAgaWYgKCFpc0xpa2VOb25lKG9mZmxpbmVfcXVlcnkpKSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Mob2ZmbGluZV9xdWVyeSwgT2ZmbGluZVF1ZXJ5KTtcbiAgICAgICAgICAgIHB0cjkgPSBvZmZsaW5lX3F1ZXJ5Ll9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvZ3JhbW1hbmFnZXJfYnVpbGRUcmFuc2ZlclRyYW5zYWN0aW9uKHByaXZhdGVfa2V5Ll9fd2JnX3B0ciwgYW1vdW50X2NyZWRpdHMsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGZlZV9jcmVkaXRzLCBwdHIzLCBwdHI0LCBsZW40LCBwdHI1LCBwdHI2LCBwdHI3LCBwdHI4LCBwdHI5KTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3ludGhlc2l6ZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgYSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSB7c3RyaW5nfSBUaGUgcHJvZ3JhbSBzb3VyY2UgY29kZSBvZiB0aGUgcHJvZ3JhbSB0byBzeW50aGVzaXplIGtleXMgZm9yXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uX2lkIHtzdHJpbmd9IFRoZSBmdW5jdGlvbiB0byBzeW50aGVzaXplIGtleXMgZm9yXG4gICAgICogQHBhcmFtIGlucHV0cyB7QXJyYXl9IFRoZSBpbnB1dHMgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGltcG9ydHMge09iamVjdCB8IHVuZGVmaW5lZH0gVGhlIGltcG9ydHMgZm9yIHRoZSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uX2lkXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IFtpbXBvcnRzXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEtleVBhaXI+fVxuICAgICAqL1xuICAgIHN0YXRpYyBzeW50aGVzaXplS2V5UGFpcihwcml2YXRlX2tleSwgcHJvZ3JhbSwgZnVuY3Rpb25faWQsIGlucHV0cywgaW1wb3J0cykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAoZnVuY3Rpb25faWQsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm9ncmFtbWFuYWdlcl9zeW50aGVzaXplS2V5UGFpcihwcml2YXRlX2tleS5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGFkZEhlYXBPYmplY3QoaW5wdXRzKSwgaXNMaWtlTm9uZShpbXBvcnRzKSA/IDAgOiBhZGRIZWFwT2JqZWN0KGltcG9ydHMpKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFByb3ZpbmdLZXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcHJvdmluZ2tleV9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuLyoqXG4gKiBQcm92aW5nIGtleSBmb3IgYSBmdW5jdGlvbiB3aXRoaW4gYW4gQWxlbyBwcm9ncmFtXG4gKi9cbmNsYXNzIFByb3ZpbmdLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFByb3ZpbmdLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUHJvdmluZ0tleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBQcm92aW5nS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19wcm92aW5na2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcImJvbmRfcHVibGljX3Byb3Zpbmdfa2V5LmJpblwiKTtcbiAgICAgKiBwcm92aW5nS2V5LmlzQm9uZFB1YmxpY1Byb3ZlcigpID8gY29uc29sZS5sb2coXCJLZXkgdmVyaWZpZWRcIikgOiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgYm9uZF9wdWJsaWMgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQm9uZFB1YmxpY1Byb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzQm9uZFB1YmxpY1Byb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSBib25kX3ZhbGlkYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoXCJib25kX3ZhbGlkYXRvcl9wcm92aW5nX2tleS5iaW5cIik7XG4gICAgICogcHJvdmluZ0tleS5pc0JvbmRQdWJsaWNQcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGJvbmRfdmFsaWRhdG9yIGZ1bmN0aW9uLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0JvbmRWYWxpZGF0b3JQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmluZ2tleV9pc0JvbmRWYWxpZGF0b3JQcm92ZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgY2xhaW1fdW5ib25kIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcImNsYWltX3VuYm9uZF9wcm92aW5nX2tleS5iaW5cIik7XG4gICAgICogcHJvdmluZ0tleS5pc0NsYWltVW5ib25kUHJvdmVyKCkgPyBjb25zb2xlLmxvZyhcIktleSB2ZXJpZmllZFwiKSA6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSBjbGFpbV91bmJvbmQgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ2xhaW1VbmJvbmRQdWJsaWNQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmluZ2tleV9pc0NsYWltVW5ib25kUHVibGljUHJvdmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGZlZV9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcImZlZV9wcml2YXRlX3Byb3Zpbmdfa2V5LmJpblwiKTtcbiAgICAgKiBwcm92aW5nS2V5LmlzRmVlUHJpdmF0ZVByb3ZlcigpID8gY29uc29sZS5sb2coXCJLZXkgdmVyaWZpZWRcIikgOiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgZmVlX3ByaXZhdGUgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlUHJpdmF0ZVByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzRmVlUHJpdmF0ZVByb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSBmZWVfcHVibGljIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcImZlZV9wdWJsaWNfcHJvdmluZ19rZXkuYmluXCIpO1xuICAgICAqIHByb3ZpbmdLZXkuaXNGZWVQdWJsaWNQcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGZlZV9wdWJsaWMgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlUHVibGljUHJvdmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZpbmdrZXlfaXNGZWVQdWJsaWNQcm92ZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgaW5jbHVzaW9uIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcImluY2x1c2lvbl9wcm92aW5nX2tleS5iaW5cIik7XG4gICAgICogcHJvdmluZ0tleS5pc0luY2x1c2lvblByb3ZlcigpID8gY29uc29sZS5sb2coXCJLZXkgdmVyaWZpZWRcIikgOiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgaW5jbHVzaW9uIGZ1bmN0aW9uLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0luY2x1c2lvblByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzSW5jbHVzaW9uUHJvdmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGpvaW4gZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgcHJvdmluZ0tleSA9IFByb3ZpbmdLZXkuZnJvbUJ5dGVzKFwiam9pbl9wcm92aW5nX2tleS5iaW5cIik7XG4gICAgICogcHJvdmluZ0tleS5pc0pvaW5Qcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIGpvaW4gZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzSm9pblByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzSm9pblByb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSBzZXRfdmFsaWRhdG9yX3N0YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcInNldF92YWxpZGF0b3Jfc2V0X3Byb3Zpbmdfa2V5LmJpblwiKTtcbiAgICAgKiBwcm92aW5nS2V5LmlzU2V0VmFsaWRhdG9yU3RhdGVQcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIHNldF92YWxpZGF0b3Jfc3RhdGUgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU2V0VmFsaWRhdG9yU3RhdGVQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmluZ2tleV9pc1NldFZhbGlkYXRvclN0YXRlUHJvdmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIHNwbGl0IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcInNwbGl0X3Byb3Zpbmdfa2V5LmJpblwiKTtcbiAgICAgKiBwcm92aW5nS2V5LmlzU3BsaXRQcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIHNwbGl0IGZ1bmN0aW9uLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NwbGl0UHJvdmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZpbmdrZXlfaXNTcGxpdFByb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcInRyYW5zZmVyX3ByaXZhdGVfcHJvdmluZ19rZXkuYmluXCIpO1xuICAgICAqIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVQcm92ZXIoKSA/IGNvbnNvbGUubG9nKFwiS2V5IHZlcmlmaWVkXCIpIDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIHRyYW5zZmVyX3ByaXZhdGUgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVHJhbnNmZXJQcml2YXRlUHJvdmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZpbmdrZXlfaXNUcmFuc2ZlclByaXZhdGVQcm92ZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgdHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWMgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgcHJvdmluZ0tleSA9IFByb3ZpbmdLZXkuZnJvbUJ5dGVzKFwidHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWNfcHJvdmluZ19rZXkuYmluXCIpO1xuICAgICAqIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVUb1B1YmxpY1Byb3ZlcigpID8gY29uc29sZS5sb2coXCJLZXkgdmVyaWZpZWRcIikgOiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgdHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWMgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVHJhbnNmZXJQcml2YXRlVG9QdWJsaWNQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmluZ2tleV9pc1RyYW5zZmVyUHJpdmF0ZVRvUHVibGljUHJvdmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBwcm92aW5nIGtleSBpcyBmb3IgdGhlIHRyYW5zZmVyX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoXCJ0cmFuc2Zlcl9wdWJsaWNfcHJvdmluZ19rZXkuYmluXCIpO1xuICAgICAqIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclB1YmxpY1Byb3ZlcigpID8gY29uc29sZS5sb2coXCJLZXkgdmVyaWZpZWRcIikgOiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgdHJhbnNmZXJfcHVibGljIGZ1bmN0aW9uLCBmYWxzZSBpZiBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RyYW5zZmVyUHVibGljUHJvdmVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByb3ZpbmdrZXlfaXNUcmFuc2ZlclB1YmxpY1Byb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfYXNfc2lnbmVyIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhcInRyYW5zZmVyX3B1YmxpY19hc19zaWduZXJfcHJvdmluZ19rZXkuYmluXCIpO1xuICAgICAqIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclB1YmxpY0FzU2lnbmVyUHJvdmVyKCkgPyBjb25zb2xlLmxvZyhcIktleSB2ZXJpZmllZFwiKSA6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWMgZnVuY3Rpb24sIGZhbHNlIGlmIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVHJhbnNmZXJQdWJsaWNBc1NpZ25lclByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzVHJhbnNmZXJQdWJsaWNBc1NpZ25lclByb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoXCJ0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZV9wcm92aW5nX2tleS5iaW5cIik7XG4gICAgICogcHJvdmluZ0tleS5pc1RyYW5zZmVyUHVibGljVG9Qcml2YXRlUHJvdmVyKCkgPyBjb25zb2xlLmxvZyhcIktleSB2ZXJpZmllZFwiKSA6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZSBmdW5jdGlvbiwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUcmFuc2ZlclB1YmxpY1RvUHJpdmF0ZVByb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2lzVHJhbnNmZXJQdWJsaWNUb1ByaXZhdGVQcm92ZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgaWYgdGhlIHByb3Zpbmcga2V5IGlzIGZvciB0aGUgdW5ib25kX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoXCJ1bmJvbmRfcHVibGljLmJpblwiKTtcbiAgICAgKiBwcm92aW5nS2V5LmlzVW5ib25kUHVibGljUHJvdmVyKCkgPyBjb25zb2xlLmxvZyhcIktleSB2ZXJpZmllZFwiKSA6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmluZyBrZXkgaXMgZm9yIHRoZSB1bmJvbmRfcHVibGljX3Byb3ZlciBmdW5jdGlvbiwgZmFsc2UgaWYgb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNVbmJvbmRQdWJsaWNQcm92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJvdmluZ2tleV9pc1VuYm9uZFB1YmxpY1Byb3Zlcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2hlY2tzdW0gb2YgdGhlIHByb3Zpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGVja3N1bSBvZiB0aGUgcHJvdmluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNoZWNrc3VtKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm92aW5na2V5X2NoZWNrc3VtKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGUgcHJvdmluZyBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm92aW5nS2V5fSBBIGNvcHkgb2YgdGhlIHByb3Zpbmcga2V5XG4gICAgICogQHJldHVybnMge1Byb3ZpbmdLZXl9XG4gICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5wcm92aW5na2V5X2NvcHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUHJvdmluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHByb3Zpbmcga2V5IGZyb20gYSBieXRlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIEJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYSBwcm92aW5nIGtleVxuICAgICAqIEByZXR1cm5zIHtQcm92aW5nS2V5fVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvdmluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChieXRlcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnByb3ZpbmdrZXlfZnJvbUJ5dGVzKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm92aW5nS2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHByb3Zpbmcga2V5IGZyb20gc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm92aW5nIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7UHJvdmluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN0cmluZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucHJvdmluZ2tleV9mcm9tU3RyaW5nKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm92aW5nS2V5Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYnl0ZSByZXByZXNlbnRhdGlvbiBvZiBhIHByb3Zpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiBhIHByb3Zpbmcga2V5XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5wcm92aW5na2V5X3RvQnl0ZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3Zpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3Zpbmcga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucHJvdmluZ2tleV90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSZWNvcmRDaXBoZXJ0ZXh0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3JlY29yZGNpcGhlcnRleHRfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogRW5jcnlwdGVkIEFsZW8gcmVjb3JkXG4gKi9cbmNsYXNzIFJlY29yZENpcGhlcnRleHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJlY29yZENpcGhlcnRleHQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmVjb3JkQ2lwaGVydGV4dEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSZWNvcmRDaXBoZXJ0ZXh0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yZWNvcmRjaXBoZXJ0ZXh0X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVjb3JkIGNpcGhlcnRleHQgZnJvbSBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlY29yZCBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSByZWNvcmQgY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmRDaXBoZXJ0ZXh0fSBSZWNvcmQgY2lwaGVydGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkQ2lwaGVydGV4dH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhyZWNvcmQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHJlY29yZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkY2lwaGVydGV4dF9mcm9tU3RyaW5nKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRDaXBoZXJ0ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlbnNlbnRhdGlvbiBvZiB0aGUgcmVjb3JkIGNpcGhlcnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjb3JkIGNpcGhlcnRleHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yZWNvcmRjaXBoZXJ0ZXh0X3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjcnlwdCB0aGUgcmVjb3JkIGNpcGhlcnRleHQgaW50byBwbGFpbnRleHQgdXNpbmcgdGhlIHZpZXcga2V5LiBUaGUgcmVjb3JkIHdpbGwgb25seVxuICAgICAqIGRlY3J5cHQgaWYgdGhlIHJlY29yZCB3YXMgZW5jcnlwdGVkIGJ5IHRoZSBhY2NvdW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZpZXcga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZpZXdLZXl9IHZpZXdfa2V5IFZpZXcga2V5IHVzZWQgdG8gZGVjcnlwdCB0aGUgY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmRQbGFpbnRleHR9IFJlY29yZCBwbGFpbnRleHQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtWaWV3S2V5fSB2aWV3X2tleVxuICAgICAqIEByZXR1cm5zIHtSZWNvcmRQbGFpbnRleHR9XG4gICAgICovXG4gICAgZGVjcnlwdCh2aWV3X2tleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Modmlld19rZXksIFZpZXdLZXkpO1xuICAgICAgICAgICAgd2FzbS5yZWNvcmRjaXBoZXJ0ZXh0X2RlY3J5cHQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgdmlld19rZXkuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFBsYWludGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBhY2NvdW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZpZXcga2V5IGlzIHRoZSBvd25lciBvZiB0aGUgcmVjb3JkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ZpZXdLZXl9IHZpZXdfa2V5IFZpZXcga2V5IHVzZWQgdG8gZGVjcnlwdCB0aGUgY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc093bmVyKHZpZXdfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2aWV3X2tleSwgVmlld0tleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmVjb3JkY2lwaGVydGV4dF9pc093bmVyKHRoaXMuX193YmdfcHRyLCB2aWV3X2tleS5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRhZyBvZiB0aGUgcmVjb3JkIHVzaW5nIHRoZSBncmFwaCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dyYXBoS2V5fSBncmFwaCBrZXkgb2YgdGhlIGFjY291bnQgYXNzb2NpYXRkIHdpdGggdGhlIHJlY29yZC5cbiAgICAgKiBAcGFyYW0ge0ZpZWxkfSBjb21taXRtZW50IG9mIHRoZSByZWNvcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9IHRhZyBvZiB0aGUgcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7R3JhcGhLZXl9IGdyYXBoX2tleVxuICAgICAqIEBwYXJhbSB7RmllbGR9IGNvbW1pdG1lbnRcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgc3RhdGljIHRhZyhncmFwaF9rZXksIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGdyYXBoX2tleSwgR3JhcGhLZXkpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNvbW1pdG1lbnQsIEZpZWxkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gY29tbWl0bWVudC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkY2lwaGVydGV4dF90YWcocmV0cHRyLCBncmFwaF9rZXkuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSZWNvcmRQbGFpbnRleHRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmVjb3JkcGxhaW50ZXh0X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiBhbiBBbGVvIHJlY29yZFxuICovXG5jbGFzcyBSZWNvcmRQbGFpbnRleHQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJlY29yZFBsYWludGV4dC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSZWNvcmRQbGFpbnRleHRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmVjb3JkUGxhaW50ZXh0RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yZWNvcmRwbGFpbnRleHRfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbV9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNvcmRfbmFtZVxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBjb21taXRtZW50KHByb2dyYW1faWQsIHJlY29yZF9uYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChwcm9ncmFtX2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJlY29yZF9uYW1lLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5yZWNvcmRwbGFpbnRleHRfY29tbWl0bWVudChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlY29yZCBwbGFpbnRleHQgZnJvbSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNvcmQgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcGxhaW50ZXh0IHJlcHJlc2VudGF0aW9uIG9mIGFuIEFsZW8gcmVjb3JkXG4gICAgICogQHJldHVybnMge1JlY29yZFBsYWludGV4dH0gUmVjb3JkIHBsYWludGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkUGxhaW50ZXh0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHJlY29yZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocmVjb3JkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5yZWNvcmRwbGFpbnRleHRfZnJvbVN0cmluZyhyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUGxhaW50ZXh0Ll9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtQbGFpbnRleHR9XG4gICAgICovXG4gICAgZ2V0TWVtYmVyKGlucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChpbnB1dCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkcGxhaW50ZXh0X2dldE1lbWJlcihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBsYWludGV4dC5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG93bmVyIG9mIHRoZSByZWNvcmQuXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgb3duZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkcGxhaW50ZXh0X293bmVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZXByZXNlbnRhdGlvbiBvZiBhIHJlY29yZCBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IGZvciB1c2FnZSBpbiBjbGllbnQgc2lkZVxuICAgICAqIGNvbXB1dGF0aW9ucy4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IGEgcmV2ZXJzaWJsZSBvcGVyYXRpb24gYW5kIGV4aXN0cyBmb3IgdGhlIGNvbnZlbmllbmNlXG4gICAgICogb2YgZGlzY292ZXJpbmcgYW5kIHVzaW5nIHByb3BlcnRpZXMgb2YgdGhlIHJlY29yZC5cbiAgICAgKlxuICAgICAqIFRoZSBjb252ZXJzaW9uIGd1aWRlIGlzIGFzIGZvbGxvd3M6XG4gICAgICogLSB1OCwgdTE2LCB1MzIsIGk4LCBpMTYgaTMyIC0tPiBOdW1iZXJcbiAgICAgKiAtIHU2NCwgdTEyOCwgaTY0LCBpMTI4IC0tPiBCaWdJbnRcbiAgICAgKiAtIEFkZHJlc3MsIEZpZWxkLCBHcm91cCwgU2NhbGFyIC0tPiBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBBZGRyZXNzLCBGaWVsZCwgR3JvdXAsIGFuZCBTY2FsYXIgd2lsbCBhbGwgYmUgY29udmVydGVkIHRvIHRoZWlyIGJlY2gzMiBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRhdGlvbi4gVGhlc2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBjYW4gYmUgY29udmVydGVkIGJhY2sgdG8gdGhlaXIgcmVzcGVjdGl2ZSB3YXNtXG4gICAgICogdHlwZXMgdXNpbmcgdGhlIGZyb21TdHJpbmcgbWV0aG9kIG9uIHRoZSBBZGRyZXNzLCBGaWVsZCwgR3JvdXAsIGFuZCBTY2FsYXIgb2JqZWN0cyBpbiB0aGlzXG4gICAgICogbGlicmFyeS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIyBDcmVhdGUgYSB3YXNtIHJlY29yZCBmcm9tIGEgcmVjb3JkIHN0cmluZy5cbiAgICAgKiBsZXQgcmVjb3JkX3BsYWludGV4dF93YXNtID0gUmVjb3JkUGxhaW5leHQuZnJvbV9zdHJpbmcoXCJ7XG4gICAgICogICBvd25lcjogYWxlbzFraDV0N20zMGRqbDBlY2RuNGY1dnV6cDdkeDB0Y3doN25jcXVxamttNG1hdGoycDJ6cXBxbTZhdDQ4LnByaXZhdGUsXG4gICAgICogICBtZXRhZGF0YToge1xuICAgICAqICAgICBwbGF5ZXIxOiBhbGVvMWtoNXQ3bTMwZGpsMGVjZG40ZjV2dXpwN2R4MHRjd2g3bmNxdXFqa200bWF0ajJwMnpxcHFtNmF0NDgucHJpdmF0ZSxcbiAgICAgKiAgICAgcGxheWVyMjogYWxlbzFkcmV1eG5tZzljbnk4ZWU5djJ1MHdyNHY0YWZmbndtMDl1MnB5dGZ3ejBmMmVuMnNoZ3FzZHNmam42LnByaXZhdGUsXG4gICAgICogICAgIG5vbmNlOiA2NjAzMTA2NDk3ODA3Mjg0ODY0ODkxODMyNjM5ODEzMjI4NDgzNTQwNzE5NzY1ODI4ODM4Nzk5MjY0MjYzMTk4MzI1MzQ4MzY1MzRmaWVsZC5wcml2YXRlXG4gICAgICogICB9LFxuICAgICAqICAgaWQ6IDE5NTMyNzg1ODU3MTk1MjU4MTEzNTU2MTc0MDQxMzkwOTk0MTg4NTUwNTMxMTI5NjA0NDE3MjUyODQwMzE0MjU5NjEwMDAxNTI0MDVmaWVsZC5wcml2YXRlLFxuICAgICAqICAgcG9zaXRpb25zOiA1MDc5NDI3MXU2NC5wcml2YXRlLFxuICAgICAqICAgYXR0ZW1wdHM6IDB1NjQucHJpdmF0ZSxcbiAgICAgKiAgIGhpdHM6IDB1NjQucHJpdmF0ZSxcbiAgICAgKiAgIF9ub25jZTogNTY2ODEwMDkxMjM5MTE4MjYyNDA3MzUwMDA5MzQzNjY2NDYzNTc2Nzc4ODg3NDMxNDA5NzY2Nzc0NjM1NDE4MTc4NDA0ODIwNDQxM2dyb3VwLnB1YmxpY1xuICAgICAqIH1cIik7XG4gICAgICpcbiAgICAgKiBsZXQgZXhwZWN0ZWRfb2JqZWN0ID0ge1xuICAgICAqICAgb3duZXI6IFwiYWxlbzFraDV0N20zMGRqbDBlY2RuNGY1dnV6cDdkeDB0Y3doN25jcXVxamttNG1hdGoycDJ6cXBxbTZhdDQ4XCIsXG4gICAgICogICBtZXRhZGF0YToge1xuICAgICAqICAgICBwbGF5ZXIxOiBcImFsZW8xa2g1dDdtMzBkamwwZWNkbjRmNXZ1enA3ZHgwdGN3aDduY3F1cWprbTRtYXRqMnAyenFwcW02YXQ0OFwiLFxuICAgICAqICAgICBwbGF5ZXIyOiBcImFsZW8xZHJldXhubWc5Y255OGVlOXYydTB3cjR2NGFmZm53bTA5dTJweXRmd3owZjJlbjJzaGdxc2RzZmpuNlwiLFxuICAgICAqICAgICBub25jZTogXCI2NjAzMTA2NDk3ODA3Mjg0ODY0ODkxODMyNjM5ODEzMjI4NDgzNTQwNzE5NzY1ODI4ODM4Nzk5MjY0MjYzMTk4MzI1MzQ4MzY1MzRmaWVsZFwiXG4gICAgICogICB9LFxuICAgICAqICAgaWQ6IFwiMTk1MzI3ODU4NTcxOTUyNTgxMTM1NTYxNzQwNDEzOTA5OTQxODg1NTA1MzExMjk2MDQ0MTcyNTI4NDAzMTQyNTk2MTAwMDE1MjQwNWZpZWxkXCIsXG4gICAgICogICBwb3NpdGlvbnM6IDUwNzk0MjcxLFxuICAgICAqICAgYXR0ZW1wdHM6IDAsXG4gICAgICogICBoaXRzOiAwLFxuICAgICAqICAgX25vbmNlOiBcIjU2NjgxMDA5MTIzOTExODI2MjQwNzM1MDAwOTM0MzY2NjQ2MzU3Njc3ODg4NzQzMTQwOTc2Njc3NDYzNTQxODE3ODQwNDgyMDQ0MTNncm91cFwiXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqICMgQ3JlYXRlIHRoZSBleHBlY3RlZCBvYmplY3RcbiAgICAgKiBsZXQgcmVjb3JkX3BsYWludGV4dF9vYmplY3QgPSByZWNvcmRfcGxhaW50ZXh0X3dhc20udG9fanNfb2JqZWN0KCk7XG4gICAgICogYXNzZXJ0KEpTT04uc3RyaW5naWZ5KHJlY29yZF9wbGFpbnRleHRfb2JqZWN0KSA9PSBKU09OLnN0cmluZ2lmeShleHBlY3RlZF9vYmplY3QpKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRvSnNPYmplY3QoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkcGxhaW50ZXh0X3RvSnNPYmplY3QocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVjb3JkIHBsYWludGV4dCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjb3JkIHBsYWludGV4dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnJlY29yZHBsYWludGV4dF90b1N0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBtaWNyb2NyZWRpdHMgaW4gdGhlIHJlY29yZFxuICAgICAqXG4gICAgICogQHJldHVybnMge3U2NH0gQW1vdW50IG9mIG1pY3JvY3JlZGl0cyBpbiB0aGUgcmVjb3JkXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBtaWNyb2NyZWRpdHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmVjb3JkcGxhaW50ZXh0X21pY3JvY3JlZGl0cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm9uY2Ugb2YgdGhlIHJlY29yZC4gVGhpcyBjYW4gYmUgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhIHJlY29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IE5vbmNlIG9mIHRoZSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5vbmNlKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yZWNvcmRwbGFpbnRleHRfbm9uY2UocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2VyaWFsIG51bWJlciBvZiBhIHJlY29yZCB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXMgaGFzIGJlZW4gc3BlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgUHJpdmF0ZSBrZXkgb2YgdGhlIGFjY291bnQgdGhhdCBvd25zIHRoZSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbV9pZCBQcm9ncmFtIElEIG9mIHRoZSBwcm9ncmFtIHRoYXQgdGhlIHJlY29yZCBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjb3JkX25hbWUgTmFtZSBvZiB0aGUgcmVjb3JkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTZXJpYWwgbnVtYmVyIG9mIHRoZSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1faWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjb3JkX25hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNlcmlhbE51bWJlclN0cmluZyhwcml2YXRlX2tleSwgcHJvZ3JhbV9pZCwgcmVjb3JkX25hbWUpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkNF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQ0XzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhwcml2YXRlX2tleSwgUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAocHJvZ3JhbV9pZCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzU3RyaW5nVG9XYXNtMChyZWNvcmRfbmFtZSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkcGxhaW50ZXh0X3NlcmlhbE51bWJlclN0cmluZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwcml2YXRlX2tleS5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjMgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4zID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIzID0gMDsgbGVuMyA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDRfMCA9IHB0cjM7XG4gICAgICAgICAgICBkZWZlcnJlZDRfMSA9IGxlbjM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjMsIGxlbjMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDRfMCwgZGVmZXJyZWQ0XzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGFnIG9mIHRoZSByZWNvcmQgdXNpbmcgdGhlIGdyYXBoIGtleS5cbiAgICAgKiBAcGFyYW0ge0dyYXBoS2V5fSBncmFwaF9rZXlcbiAgICAgKiBAcGFyYW0ge0ZpZWxkfSBjb21taXRtZW50XG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHRhZyhncmFwaF9rZXksIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGdyYXBoX2tleSwgR3JhcGhLZXkpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNvbW1pdG1lbnQsIEZpZWxkKTtcbiAgICAgICAgICAgIHZhciBwdHIwID0gY29tbWl0bWVudC5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgICAgIHdhc20ucmVjb3JkcGxhaW50ZXh0X3RhZyhyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBncmFwaF9rZXkuX193YmdfcHRyLCBwdHIwKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBTY2FsYXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193Ymdfc2NhbGFyX2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFNjYWxhciBmaWVsZCBlbGVtZW50LlxuICovXG5jbGFzcyBTY2FsYXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNjYWxhci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBTY2FsYXJGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgU2NhbGFyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zY2FsYXJfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2NhbGFyIG9iamVjdCBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc2NhbGFyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhncm91cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoZ3JvdXAsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnNjYWxhcl9mcm9tU3RyaW5nKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzY2FsYXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zY2FsYXJfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzY2FsYXIgZWxlbWVudCBmcm9tIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzTGUoYnl0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zY2FsYXJfZnJvbUJ5dGVzTGUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChieXRlcykpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgc2NhbGFyIGVsZW1lbnQgYXMgYSBVaW50OEFycmF5IG9mIGxlZnQgZW5kaWFuIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRvQnl0ZXNMZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5zY2FsYXJfdG9CeXRlc0xlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uc3RydWN0IGEgc2NhbGFyIGVsZW1lbnQgZnJvbSBhIGJvb2xlYW4gYXJyYXkgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBiaXRzXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJpdHNMZShiaXRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2NhbGFyX2Zyb21CaXRzTGUocmV0cHRyLCBhZGRCb3Jyb3dlZE9iamVjdChiaXRzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsZWZ0IGVuZGlhbiBib29sZWFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzY2FsYXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0b0JpdHNMZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfdG9CaXRzTGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwbGFpbnRleHQgZWxlbWVudCBmcm9tIGEgc2NhbGFyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1BsYWludGV4dH1cbiAgICAgKi9cbiAgICB0b1BsYWludGV4dCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfdG9QbGFpbnRleHQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUGxhaW50ZXh0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgc2NhbGFyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF9jbG9uZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIHNjYWxhciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgc3RhdGljIHJhbmRvbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfcmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0d28gc2NhbGFyIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgU2NhbGFyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfYWRkKHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gc2NhbGFyIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG90aGVyLCBTY2FsYXIpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNjYWxhcl9zdWJ0cmFjdCh0aGlzLl9fd2JnX3B0ciwgb3RoZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIHNjYWxhciBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge1NjYWxhcn0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7U2NhbGFyfVxuICAgICAqL1xuICAgIG11bHRpcGx5KG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgU2NhbGFyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfbXVsdGlwbHkodGhpcy5fX3diZ19wdHIsIG90aGVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gc2NhbGFyIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgZGl2aWRlKG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgU2NhbGFyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfZGl2aWRlKHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3VibGUgdGhlIHNjYWxhciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgZG91YmxlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNjYWxhcl9kb3VibGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3dlciBvZiBhIHNjYWxhciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U2NhbGFyfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgcG93KG90aGVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhvdGhlciwgU2NhbGFyKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfcG93KHRoaXMuX193YmdfcHRyLCBvdGhlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdGhlIHNjYWxhciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgaW52ZXJzZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zY2FsYXJfaW52ZXJzZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbXVsdGlwbGljYXRpdmUgaWRlbnRpdHkgb2YgdGhlIHNjYWxhciBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyB7U2NhbGFyfVxuICAgICAqL1xuICAgIHN0YXRpYyBvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2NhbGFyX29uZSgpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFkZGl0aXZlIGlkZW50aXR5IG9mIHRoZSBzY2FsYXIgZmllbGQuXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5maWVsZF96ZXJvKCk7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9uZSBzY2FsYXIgZWxlbWVudCBlcXVhbHMgYW5vdGhlci5cbiAgICAgKiBAcGFyYW0ge1NjYWxhcn0gb3RoZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG90aGVyLCBTY2FsYXIpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX2VxdWFscyh0aGlzLl9fd2JnX3B0ciwgb3RoZXIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IFNpZ25hdHVyZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zaWduYXR1cmVfZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogQ3J5cHRvZ3JhcGhpYyBzaWduYXR1cmUgb2YgYSBtZXNzYWdlIHNpZ25lZCBieSBhbiBBbGVvIGFjY291bnRcbiAqL1xuY2xhc3MgU2lnbmF0dXJlIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShTaWduYXR1cmUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2lnbmF0dXJlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFNpZ25hdHVyZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193Ymdfc2lnbmF0dXJlX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBhIG1lc3NhZ2Ugd2l0aCBhIHByaXZhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5IFRoZSBwcml2YXRlIGtleSB0byBzaWduIHRoZSBtZXNzYWdlIHdpdGhcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1lc3NhZ2UgQnl0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVzc2FnZSB0byBzaWduXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX0gU2lnbmF0dXJlIG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAgICovXG4gICAgc3RhdGljIHNpZ24ocHJpdmF0ZV9rZXksIG1lc3NhZ2UpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHByaXZhdGVfa2V5LCBQcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKG1lc3NhZ2UsIHdhc20uX193YmluZGdlbl9leHBvcnRfMyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucHJpdmF0ZWtleV9zaWduKHByaXZhdGVfa2V5Ll9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhZGRyZXNzIGZyb20gYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc30gQWRkcmVzcyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICB0b19hZGRyZXNzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZV90b19hZGRyZXNzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbGxlbmdlIG9mIGEgc2lnbmF0dXJlLlxuICAgICAqIEByZXR1cm5zIHtTY2FsYXJ9XG4gICAgICovXG4gICAgY2hhbGxlbmdlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmZpZWxkX2Nsb25lKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXNwb25zZSBvZiBhIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7U2NhbGFyfVxuICAgICAqL1xuICAgIHJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnNpZ25hdHVyZV9yZXNwb25zZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTY2FsYXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBhIHNpZ25hdHVyZSBvZiBhIG1lc3NhZ2Ugd2l0aCBhbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgd2l0aFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZSBCeXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXNzYWdlIHRvIHZlcmlmeVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHZlcmlmeShhZGRyZXNzLCBtZXNzYWdlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhZGRyZXNzLCBBZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKG1lc3NhZ2UsIHdhc20uX193YmluZGdlbl9leHBvcnRfMyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2lnbmF0dXJlX3ZlcmlmeSh0aGlzLl9fd2JnX3B0ciwgYWRkcmVzcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaWduYXR1cmUgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNpZ25hdHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfSBTaWduYXR1cmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge1NpZ25hdHVyZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbV9zdHJpbmcoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMChzaWduYXR1cmUsIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5zaWduYXR1cmVfZnJvbV9zdHJpbmcocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNpZ25hdHVyZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b19zdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnNpZ25hdHVyZV90b19zdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNhY3Rpb25fZnJlZShwdHIgPj4+IDAsIDEpKTtcbi8qKlxuICogV2ViYXNzZW1ibHkgUmVwcmVzZW50YXRpb24gb2YgYW4gQWxlbyB0cmFuc2FjdGlvblxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgd2hlbiBnZW5lcmF0aW5nIGFuIG9uLWNoYWluIGZ1bmN0aW9uIGRlcGxveW1lbnQgb3IgZXhlY3V0aW9uIGFuZCBpcyB0aGVcbiAqIG9iamVjdCB0aGF0IHNob3VsZCBiZSBzdWJtaXR0ZWQgdG8gdGhlIEFsZW8gTmV0d29yayBpbiBvcmRlciB0byBkZXBsb3kgb3IgZXhlY3V0ZSBhIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoVHJhbnNhY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNhY3Rpb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3RyYW5zYWN0aW9uX2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gZnJvbSBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh0cmFuc2FjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodHJhbnNhY3Rpb24sIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uX2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZyb20gYSBVaW50OEFycmF5IG9mIGxlZnQgZW5kaWFuIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBVaW50OEFycmF5IG9mIGxlZnQgZW5kaWFuIGJ5dGVzIGVuY29kaW5nIGEgVHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlc0xlKGJ5dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25fZnJvbUJ5dGVzTGUocmV0cHRyLCBhZGRIZWFwT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9uIGFzIGEgc3RyaW5nLiBJZiB5b3Ugd2FudCB0byBzdWJtaXQgdGhpcyB0cmFuc2FjdGlvbiB0byB0aGUgQWxlbyBOZXR3b3JrXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSB0aGUgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHN1Ym1pdHRlZCBpbiB0aGUgYFBPU1RgIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNhY3Rpb25fdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9uIGFzIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRvQnl0ZXNMZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2FjdGlvbl90b0J5dGVzTGUocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgZ2l2ZW4gc2VyaWFsIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGdpdmVuIHNlcmlhbCBudW1iZXIuXG4gICAgICogQHBhcmFtIHtGaWVsZH0gc2VyaWFsX251bWJlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0YWluc1NlcmlhbE51bWJlcihzZXJpYWxfbnVtYmVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzZXJpYWxfbnVtYmVyLCBGaWVsZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25fY29uc3RhaW5zU2VyaWFsTnVtYmVyKHRoaXMuX193YmdfcHRyLCBzZXJpYWxfbnVtYmVyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGdpdmVuIGNvbW1pdG1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBjb21taXRtZW50LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IGNvbW1pdG1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb25zdGFpbnNDb21taXRtZW50KGNvbW1pdG1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbW1pdG1lbnQsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9jb25zdGFpbnNDb21taXRtZW50KHRoaXMuX193YmdfcHRyLCBjb21taXRtZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSByZWNvcmQgaW4gdGhlIHRyYW5zYWN0aW9uIGJ5IHRoZSByZWNvcmQncyBjb21taXRtZW50LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IGNvbW1pdG1lbnRcbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkQ2lwaGVydGV4dCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmaW5kUmVjb3JkKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbW1pdG1lbnQsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9maW5kUmVjb3JkKHRoaXMuX193YmdfcHRyLCBjb21taXRtZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSZWNvcmRDaXBoZXJ0ZXh0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbidzIGJhc2UgZmVlLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgYmFzZUZlZUFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9iYXNlRmVlQW1vdW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCByZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbidzIHRvdGFsIGZlZS5cbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGZlZUFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9mZWVBbW91bnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uJ3MgcHJpb3JpdHkgZmVlLlxuICAgICAqXG4gICAgICogcmV0dXJucyB7YmlnaW50fSBUaGUgdHJhbnNhY3Rpb24ncyBwcmlvcml0eSBmZWUuXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBwcmlvcml0eUZlZUFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9wcmlvcml0eUZlZUFtb3VudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNVaW50Tig2NCwgcmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNEZXBsb3koKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25faXNEZXBsb3kodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGV4ZWN1dGlvbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBleGVjdXRpb24gdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0V4ZWN1dGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25faXNFeGVjdXRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGZlZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGZlZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uX2lzRmVlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvZ3JhbSBkZXBsb3llZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGRlcGxveW1lbnRcbiAgICAgKiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9ncmFtIHwgdW5kZWZpbmVkfSBUaGUgcHJvZ3JhbSBkZXBsb3llZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9ncmFtIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGRlcGxveWVkUHJvZ3JhbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl9kZXBsb3llZFByb2dyYW0odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUHJvZ3JhbS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXhlY3V0aW9uIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gKGlmIHByZXNlbnQpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0V4ZWN1dGlvbiB8IHVuZGVmaW5lZH0gVGhlIGV4ZWN1dGlvbiB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtFeGVjdXRpb24gfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZXhlY3V0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uX2V4ZWN1dGlvbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBFeGVjdXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVjb3JkIHBsYWludGV4dCBwcmVzZW50IGluIGEgdHJhbnNhY3Rpb24gb3duZWQgYnkgYSBzcGVjaWZpYyB2aWV3IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXkgVmlldyBrZXkgdXNlZCB0byBkZWNyeXB0IHRoZSBjaXBoZXJ0ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8UmVjb3JkUGxhaW50ZXh0Pn0gQXJyYXkgb2YgcmVjb3JkIHBsYWludGV4dCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtWaWV3S2V5fSB2aWV3X2tleVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIG93bmVkUmVjb3Jkcyh2aWV3X2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Modmlld19rZXksIFZpZXdLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uX293bmVkUmVjb3Jkcyh0aGlzLl9fd2JnX3B0ciwgdmlld19rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZWNvcmRzIHByZXNlbnQgaW4gYSB0cmFuc2FjdGlvbiBhbmQgdGhlaXIgY29tbWl0bWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8e2NvbW1pdG1lbnQ6IEZpZWxkLCByZWNvcmQ6IFJlY29yZENpcGhlcnRleHR9Pn0gQXJyYXkgb2YgcmVjb3JkIGNpcGhlcnRleHQgb2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHJlY29yZHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25fcmVjb3Jkcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN1bW1hcnkgb2YgdGhlIHRyYW5zYWN0aW9uIHdpdGhpbiBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGV4ZWN1dGlvbiB0cmFuc2FjdGlvbiwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIGxpc3Qgb2YgdGhlXG4gICAgICogdHJhbnNpdGlvbnMgYW5kIHRoZWlyIGlucHV0cyBhbmQgb3V0cHV0cy5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24sIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHByb2dyYW0gaWQgYW5kXG4gICAgICogYSBsaXN0IG9mIHRoZSBmdW5jdGlvbnMgYW5kIHRoZWlyIHZlcmlmeWluZyBrZXlzLCBjb25zdHJhaW50LCBhbmQgdmFyaWFibGUgY291bnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb252ZXJ0X3RvX2pzIElmIHRydWUgdGhlIGlucHV0cyBhbmQgb3V0cHV0cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBKUyBvYmplY3RzLFxuICAgICAqIGlmIGZhbHNlIHRoZSBpbnB1dHMgYW5kIG91dHB1dHMgd2lsbCBiZSBpbiB3YXNtIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRyYW5zYWN0aW9uIHN1bW1hcnlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbnZlcnRfdG9fanNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHN1bW1hcnkoY29udmVydF90b19qcykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zYWN0aW9uX3N1bW1hcnkodGhpcy5fX3diZ19wdHIsIGNvbnZlcnRfdG9fanMpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBpcyB0aGUgbWVya2xlIHJvb3Qgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgaW5jbHVzaW9uIHByb29mLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBjYW4gYmUgdXNlZCB0byBxdWVyeSB0aGUgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgQWxlbyBOZXR3b3JrIHRvIHNlZVxuICAgICAqIGlmIGl0IHdhcyBzdWNjZXNzZnVsLiBJZiBzdWNjZXNzZnVsLCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBpbmNsdWRlZCBpbiBhIGJsb2NrIGFuZCB0aGlzXG4gICAgICogdmFsdWUgY2FuIGJlIHVzZWQgdG8gbG9va3VwIHRoZSB0cmFuc2FjdGlvbiBkYXRhIG9uLWNoYWluLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVHJhbnNhY3Rpb25JZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgaWQoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uX2lkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZVxuICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gKHdpbGwgcmV0dXJuIFwiZGVwbG95XCIgb3IgXCJleGVjdXRlXCIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUcmFuc2FjdGlvbiB0eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvblR5cGUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zYWN0aW9uX3RyYW5zYWN0aW9uVHlwZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmVycmVkMV8wID0gcjA7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21XYXNtMChyMCwgcjEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDFfMCwgZGVmZXJyZWQxXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbnMgaW4gYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxUcmFuc2l0aW9uPn0gQXJyYXkgb2YgdHJhbnNpdGlvbiBvYmplY3RzXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNhY3Rpb25fdHJhbnNpdGlvbnModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZlcmlmeWluZyBrZXlzIGluIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gQXJyYXkgb2YgdmVyaWZ5aW5nIGtleXMuXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdmVyaWZ5aW5nS2V5cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2FjdGlvbl92ZXJpZnlpbmdLZXlzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFRyYW5zaXRpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdHJhbnNpdGlvbl9mcmVlKHB0ciA+Pj4gMCwgMSkpO1xuXG5jbGFzcyBUcmFuc2l0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFRyYW5zaXRpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVHJhbnNpdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfdHJhbnNpdGlvbl9mcmVlKHB0ciwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBJRFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zaXRpb24gSURcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2l0aW9uX2lkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvbiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0cmFuc2l0aW9uXG4gICAgICogQHJldHVybnMge1RyYW5zaXRpb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNpdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzU3RyaW5nVG9XYXNtMCh0cmFuc2l0aW9uLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS50cmFuc2l0aW9uX2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb24uX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcyBlbmNvZGluZyBhIFRyYW5zaXRpb24uXG4gICAgICogQHJldHVybnMge1RyYW5zaXRpb259XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtUcmFuc2l0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXNMZShieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zaXRpb25fZnJvbUJ5dGVzTGUocmV0cHRyLCBhZGRIZWFwT2JqZWN0KGJ5dGVzKSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uLl9fd3JhcChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBhcyBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gc3VibWl0IHRoaXMgdHJhbnNpdGlvbiB0byB0aGUgQWxlbyBOZXR3b3JrXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSB0aGUgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHN1Ym1pdHRlZCBpbiB0aGUgYFBPU1RgIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS50cmFuc2l0aW9uX3RvU3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuc2l0aW9uIGFzIGEgVWludDhBcnJheSBvZiBsZWZ0IGVuZGlhbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uXG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdG9CeXRlc0xlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zaXRpb25fdG9CeXRlc0xlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJvZ3JhbSBJRCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHByb2dyYW1JZCgpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20udHJhbnNpdGlvbl9wcm9ncmFtSWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbk5hbWUoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnRyYW5zaXRpb25fZnVuY3Rpb25OYW1lKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBjb21taXRtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBUcnVlIGlmIHRoZSB0cmFuc2l0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBjb21taXRtZW50LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IGNvbW1pdG1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc0NvbW1pdG1lbnQoY29tbWl0bWVudCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY29tbWl0bWVudCwgRmllbGQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zaXRpb25fY29udGFpbnNDb21taXRtZW50KHRoaXMuX193YmdfcHRyLCBjb21taXRtZW50Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0cmFuc2l0aW9uIGNvbnRhaW5zIGEgc2VyaWFsIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmllbGR9IHNlcmlhbF9udW1iZXIgVGhlIHNlcmlhbCBudW1iZXIgdG8gY2hlY2sgZm9yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH0gVHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBjb250YWlucyBhIHNlcmlhbCBudW1iZXIsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwYXJhbSB7RmllbGR9IHNlcmlhbF9udW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc1NlcmlhbE51bWJlcihzZXJpYWxfbnVtYmVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzZXJpYWxfbnVtYmVyLCBGaWVsZCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl9jb250YWluc1NlcmlhbE51bWJlcih0aGlzLl9fd2JnX3B0ciwgc2VyaWFsX251bWJlci5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgcmVjb3JkIGluIHRoZSB0cmFuc2l0aW9uIGJ5IHRoZSByZWNvcmQncyBjb21taXRtZW50LlxuICAgICAqIEBwYXJhbSB7RmllbGR9IGNvbW1pdG1lbnRcbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkQ2lwaGVydGV4dCB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmaW5kUmVjb3JkKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbW1pdG1lbnQsIEZpZWxkKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2l0aW9uX2ZpbmRSZWNvcmQodGhpcy5fX3diZ19wdHIsIGNvbW1pdG1lbnQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJlY29yZENpcGhlcnRleHQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVjb3JkIHBsYWludGV4dCBwcmVzZW50IGluIGEgdHJhbnNpdGlvbiBvd25lZCBieSBhIHNwZWNpZmljIHZpZXcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtWaWV3S2V5fSB2aWV3X2tleSBUaGUgdmlldyBrZXkgb2YgdGhlIHJlY29yZCBvd25lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxSZWNvcmRQbGFpbnRleHQ+fSBBcnJheSBvZiByZWNvcmQgcGxhaW50ZXh0IG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge1ZpZXdLZXl9IHZpZXdfa2V5XG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgb3duZWRSZWNvcmRzKHZpZXdfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2aWV3X2tleSwgVmlld0tleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl9vd25lZFJlY29yZHModGhpcy5fX3diZ19wdHIsIHZpZXdfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVjb3JkcyBwcmVzZW50IGluIGEgdHJhbnNpdGlvbiBhbmQgdGhlaXIgY29tbWl0bWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8e2NvbW1pdG1lbnQ6IEZpZWxkLCByZWNvcmQ6IFJlY29yZENpcGhlcnRleHR9Pn0gQXJyYXkgb2YgcmVjb3JkIGNpcGhlcnRleHQgb2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHJlY29yZHMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl9yZWNvcmRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnB1dHMgb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGNvbnZlcnRfdG9fanMgSWYgdHJ1ZSB0aGUgaW5wdXRzIHdpbGwgYmUgY29udmVydGVkIHRvIEpTIG9iamVjdHMsIGlmIGZhbHNlXG4gICAgICogdGhlIGlucHV0cyB3aWxsIGJlIGluIHdhc20gZm9ybWF0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbnZlcnRfdG9fanNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBpbnB1dHMoY29udmVydF90b19qcykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnRyYW5zaXRpb25faW5wdXRzKHRoaXMuX193YmdfcHRyLCBjb252ZXJ0X3RvX2pzKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvdXRwdXRzIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sfSBjb252ZXJ0X3RvX2pzIElmIHRydWUgdGhlIG91dHB1dHMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gSlMgb2JqZWN0cywgaWYgZmFsc2VcbiAgICAgKiB0aGUgb3V0cHV0cyB3aWxsIGJlIGluIHdhc20gZm9ybWF0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBvdXRwdXRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb252ZXJ0X3RvX2pzXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59XG4gICAgICovXG4gICAgb3V0cHV0cyhjb252ZXJ0X3RvX2pzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl9vdXRwdXRzKHRoaXMuX193YmdfcHRyLCBjb252ZXJ0X3RvX2pzKTtcbiAgICAgICAgcmV0dXJuIHRha2VPYmplY3QocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuc2l0aW9uIHB1YmxpYyBrZXkgb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHJldHVybnMge0dyb3VwfVxuICAgICAqL1xuICAgIHRwaygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5jb21wdXRla2V5X3BrX3NpZyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBHcm91cC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuc2l0aW9uIHZpZXcga2V5IG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7Vmlld0tleX0gdmlld19rZXlcbiAgICAgKiBAcmV0dXJucyB7RmllbGR9XG4gICAgICovXG4gICAgdHZrKHZpZXdfa2V5KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyh2aWV3X2tleSwgVmlld0tleSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl90dmsodGhpcy5fX3diZ19wdHIsIHZpZXdfa2V5Ll9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuc2l0aW9uIGNvbW1pdG1lbnQgb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHJldHVybnMge0ZpZWxkfVxuICAgICAqL1xuICAgIHRjbSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS50cmFuc2l0aW9uX3RjbSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBGaWVsZC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0cmFuc2l0aW9uIHNpZ25lciBjb21taXRtZW50IG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGaWVsZH1cbiAgICAgKi9cbiAgICBzY20oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udHJhbnNpdGlvbl9zY20odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gRmllbGQuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBWZXJpZnlpbmdLZXlGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfdmVyaWZ5aW5na2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG4vKipcbiAqIFZlcmlmeWluZyBrZXkgZm9yIGEgZnVuY3Rpb24gd2l0aGluIGFuIEFsZW8gcHJvZ3JhbVxuICovXG5jbGFzcyBWZXJpZnlpbmdLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFZlcmlmeWluZ0tleS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBWZXJpZnlpbmdLZXlGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgVmVyaWZ5aW5nS2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ192ZXJpZnlpbmdrZXlfZnJlZShwdHIsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgYm9uZF9wdWJsaWMgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBib25kX3B1YmxpYyBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGJvbmRQdWJsaWNWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfYm9uZFB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcmlmeWluZyBrZXkgZm9yIHRoZSBib25kX3ZhbGlkYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIGJvbmRfdmFsaWRhdG9yIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9uZFZhbGlkYXRvclZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9ib25kVmFsaWRhdG9yVmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIGNsYWltX2RlbGVnYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIGNsYWltX3VuYm9uZF9wdWJsaWMgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFpbVVuYm9uZFB1YmxpY1ZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9jbGFpbVVuYm9uZFB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcmlmeWluZyBrZXkgZm9yIHRoZSBmZWVfcHJpdmF0ZSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIGZlZV9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmVlUHJpdmF0ZVZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9mZWVQcml2YXRlVmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIGZlZV9wdWJsaWMgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBmZWVfcHVibGljIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmVlUHVibGljVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2ZlZVB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcmlmeWluZyBrZXkgZm9yIHRoZSBpbmNsdXNpb24gZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBpbmNsdXNpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdXNpb25WZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaW5jbHVzaW9uVmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIGpvaW4gZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBqb2luIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pblZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9qb2luVmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIHNldF92YWxpZGF0b3Jfc3RhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBzZXRfdmFsaWRhdG9yX3N0YXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VmFsaWRhdG9yU3RhdGVWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfc2V0VmFsaWRhdG9yU3RhdGVWZXJpZmllcigpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgc3BsaXQgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSBzcGxpdCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICovXG4gICAgc3RhdGljIHNwbGl0VmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X3NwbGl0VmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIHRyYW5zZmVyX3ByaXZhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmZXJQcml2YXRlVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X3RyYW5zZmVyUHJpdmF0ZVZlcmlmaWVyKCk7XG4gICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcmlmeWluZyBrZXkgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlX3RvX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIHRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmZXJQcml2YXRlVG9QdWJsaWNWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfdHJhbnNmZXJQcml2YXRlVG9QdWJsaWNWZXJpZmllcigpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgdHJhbnNmZXJfcHVibGljIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fSBWZXJpZnlpbmcga2V5IGZvciB0aGUgdHJhbnNmZXJfcHVibGljIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmZXJQdWJsaWNWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfdHJhbnNmZXJQdWJsaWNWZXJpZmllcigpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgdHJhbnNmZXJfcHVibGljX2FzX3NpZ25lciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIHRyYW5zZmVyX3B1YmxpY19hc19zaWduZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2ZlclB1YmxpY0FzU2lnbmVyVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X3RyYW5zZmVyUHVibGljQXNTaWduZXJWZXJpZmllcigpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZnlpbmcga2V5IGZvciB0aGUgdHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZmVyUHVibGljVG9Qcml2YXRlVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X3RyYW5zZmVyUHVibGljVG9Qcml2YXRlVmVyaWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIHVuYm9uZF9wdWJsaWMgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9IFZlcmlmeWluZyBrZXkgZm9yIHRoZSB1bmJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5ib25kUHVibGljVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X3VuYm9uZFB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcmlmeWluZyBrZXkgZm9yIHRoZSBib25kX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIGJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCb25kUHVibGljVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2lzQm9uZFB1YmxpY1ZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZ5aW5nIGtleSBmb3IgdGhlIGJvbmRfdmFsaWRhdG9yIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fSBWZXJpZnlpbmcga2V5IGZvciB0aGUgYm9uZF92YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0JvbmRWYWxpZGF0b3JWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaXNCb25kVmFsaWRhdG9yVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIGNsYWltX2RlbGVnYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDbGFpbVVuYm9uZFB1YmxpY1ZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc0NsYWltVW5ib25kUHVibGljVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIGZlZV9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZlZVByaXZhdGVWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaXNGZWVQcml2YXRlVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIGZlZV9wdWJsaWMgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlUHVibGljVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2lzRmVlUHVibGljVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIGluY2x1c2lvbiBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNJbmNsdXNpb25WZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaXNJbmNsdXNpb25WZXJpZmllcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNKb2luVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2lzSm9pblZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHZlcmlmeWluZyBrZXkgaXMgZm9yIHRoZSBzZXRfdmFsaWRhdG9yX3N0YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NldFZhbGlkYXRvclN0YXRlVmVyaWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2lzU2V0VmFsaWRhdG9yU3RhdGVWZXJpZmllcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGZvciB0aGUgc3BsaXQgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzU3BsaXRWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaXNTcGxpdFZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHZlcmlmeWluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RyYW5zZmVyUHJpdmF0ZVZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc1RyYW5zZmVyUHJpdmF0ZVZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHZlcmlmeWluZyBrZXkgaXMgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlX3RvX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUcmFuc2ZlclByaXZhdGVUb1B1YmxpY1ZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc1RyYW5zZmVyUHJpdmF0ZVRvUHVibGljVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIHRyYW5zZmVyX3B1YmxpYyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2x9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUcmFuc2ZlclB1YmxpY1ZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc1RyYW5zZmVyUHVibGljVmVyaWZpZXIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgdGhlIHRyYW5zZmVyX3B1YmxpY19hc19zaWduZXIgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVHJhbnNmZXJQdWJsaWNBc1NpZ25lclZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc1RyYW5zZmVyUHVibGljQXNTaWduZXJWZXJpZmllcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGZvciB0aGUgdHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGUgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVHJhbnNmZXJQdWJsaWNUb1ByaXZhdGVWZXJpZmllcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52ZXJpZnlpbmdrZXlfaXNUcmFuc2ZlclB1YmxpY1RvUHJpdmF0ZVZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIHZlcmlmeWluZyBrZXkgaXMgZm9yIHRoZSB1bmJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1VuYm9uZFB1YmxpY1ZlcmlmaWVyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnZlcmlmeWluZ2tleV9pc1VuYm9uZFB1YmxpY1ZlcmlmaWVyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGVja3N1bSBvZiB0aGUgdmVyaWZ5aW5nIGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ2hlY2tzdW0gb2YgdGhlIHZlcmlmeWluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNoZWNrc3VtKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS52ZXJpZnlpbmdrZXlfY2hlY2tzdW0ocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSB2ZXJpZnlpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fSBBIGNvcHkgb2YgdGhlIHZlcmlmeWluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7VmVyaWZ5aW5nS2V5fVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20udmVyaWZ5aW5na2V5X2NvcHkodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgdmVyaWZ5aW5nIGtleSBmcm9tIGEgYnl0ZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVyaWZ5aW5nIGtleVxuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtWZXJpZnlpbmdLZXl9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYnl0ZXMsIHdhc20uX193YmluZGdlbl9leHBvcnRfMyk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS52ZXJpZnlpbmdrZXlfZnJvbUJ5dGVzKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZXJpZnlpbmdLZXkuX193cmFwKHIwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmVyaWZ5aW5nIGtleSBmcm9tIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZXJpZnlpbmcga2V5XG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHJldHVybnMge1ZlcmlmeWluZ0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKHN0cmluZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udmVyaWZ5aW5na2V5X2Zyb21TdHJpbmcocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAwLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAxLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldERhdGFWaWV3TWVtb3J5MCgpLmdldEludDMyKHJldHB0ciArIDQgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5fX3dyYXAocjApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSB2ZXJpZnlpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnl0ZSByZXByZXNlbnRhdGlvbiBvZiBhIHZlcmlmeWluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0b0J5dGVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnZlcmlmeWluZ2tleV90b0J5dGVzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjEgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZXJpZnlpbmcga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlcmlmeWluZyBrZXlcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVmZXJyZWQxXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS52ZXJpZnlpbmdrZXlfdG9TdHJpbmcocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXREYXRhVmlld01lbW9yeTAoKS5nZXRJbnQzMihyZXRwdHIgKyA0ICogMSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzEgPSByMTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdGcm9tV2FzbTAocjAsIHIxKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0tleUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ192aWV3a2V5X2ZyZWUocHRyID4+PiAwLCAxKSk7XG5cbmNsYXNzIFZpZXdLZXkge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFZpZXdLZXkucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgVmlld0tleUZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBWaWV3S2V5RmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ192aWV3a2V5X2ZyZWUocHRyLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHZpZXcga2V5IGZyb20gYSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleSBQcml2YXRlIGtleVxuICAgICAqIEByZXR1cm5zIHtWaWV3S2V5fSBWaWV3IGtleVxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXlcbiAgICAgKiBAcmV0dXJucyB7Vmlld0tleX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbV9wcml2YXRlX2tleShwcml2YXRlX2tleSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocHJpdmF0ZV9rZXksIFByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnByaXZhdGVrZXlfdG9fdmlld19rZXkocHJpdmF0ZV9rZXkuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFZpZXdLZXkuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB2aWV3IGtleSBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmlldyBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3X2tleSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2aWV3IGtleVxuICAgICAqIEByZXR1cm5zIHtWaWV3S2V5fSBWaWV3IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3X2tleVxuICAgICAqIEByZXR1cm5zIHtWaWV3S2V5fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tX3N0cmluZyh2aWV3X2tleSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAodmlld19rZXksIHdhc20uX193YmluZGdlbl9leHBvcnRfMywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF80KTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS52aWV3a2V5X2Zyb21fc3RyaW5nKHB0cjAsIGxlbjApO1xuICAgICAgICByZXR1cm4gVmlld0tleS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmlldyBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZpZXcga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b19zdHJpbmcoKSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDFfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkMV8xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnZpZXdrZXlfdG9fc3RyaW5nKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgZGVmZXJyZWQxXzAgPSByMDtcbiAgICAgICAgICAgIGRlZmVycmVkMV8xID0gcjE7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKGRlZmVycmVkMV8wLCBkZWZlcnJlZDFfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRpbmcgdG8gYSB2aWV3IGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge0FkZHJlc3N9IEFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICB0b19hZGRyZXNzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLmFkZHJlc3NfZnJvbV92aWV3X2tleSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBBZGRyZXNzLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgc2NhbGFyIG9mIGEgdmlldyBrZXkuXG4gICAgICogQHJldHVybnMge1NjYWxhcn1cbiAgICAgKi9cbiAgICB0b19zY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZmllbGRfY2xvbmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gU2NhbGFyLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0IGEgcmVjb3JkIGNpcGhlcnRleHQgd2l0aCBhIHZpZXcga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2lwaGVydGV4dCBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSByZWNvcmQgY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHJlY29yZCBwbGFpbnRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGxldCBkZWZlcnJlZDNfMDtcbiAgICAgICAgbGV0IGRlZmVycmVkM18xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoY2lwaGVydGV4dCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20udmlld2tleV9kZWNyeXB0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDAsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDEsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDIsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0RGF0YVZpZXdNZW1vcnkwKCkuZ2V0SW50MzIocmV0cHRyICsgNCAqIDMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHB0cjIgPSByMDtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcjE7XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICBwdHIyID0gMDsgbGVuMiA9IDA7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZDNfMCA9IHB0cjI7XG4gICAgICAgICAgICBkZWZlcnJlZDNfMSA9IGxlbjI7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHB0cjIsIGxlbjIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMihkZWZlcnJlZDNfMCwgZGVmZXJyZWQzXzEsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19sb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIFdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2dldF9pbXBvcnRzKCkge1xuICAgIGNvbnN0IGltcG9ydHMgPSB7fTtcbiAgICBpbXBvcnRzLndiZyA9IHt9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2Fib3J0Xzc3NWVmMWQxN2ZjNjU4NjggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5hYm9ydCgpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYWRkcmVzc19uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEFkZHJlc3MuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYXBwZW5kXzhjN2RkOGQ2NDFhNWYwMWIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5hcHBlbmQoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzEsIGFyZzIpLCBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMywgYXJnNCkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19hcnJheUJ1ZmZlcl9kMWI0NGM0MzkwZGI0MjJmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYXN5bmNfOWZmNmQ5ZTQwNWYxMzc3MiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmFzeW5jO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5idWZmZXI7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jYWxsXzY3MmE0ZDIxNjM0ZDRhMjQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2NhbGxfN2NjY2RkNjllMDc5MWFlMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNhbGwoZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jaXBoZXJ0ZXh0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQ2lwaGVydGV4dC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19jcnlwdG9fZWQ1OGI4ZTEwYTI5MjgzOSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmNyeXB0bztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2RhdGFfNDMyZDljM2RmMjYzMDk0MiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmRhdGE7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19kb25lXzc2OWU1ZWRlNGIzMWM2N2IgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5kb25lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZXJyb3JfNzUzNGI4ZTlhMzZmMWFiNCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgbGV0IGRlZmVycmVkMF8wO1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMCA9IGFyZzA7XG4gICAgICAgICAgICBkZWZlcnJlZDBfMSA9IGFyZzE7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIoZGVmZXJyZWQwXzAsIGRlZmVycmVkMF8xLCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZXhlY3V0aW9ucmVzcG9uc2VfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBFeGVjdXRpb25SZXNwb25zZS5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19mZXRjaF81MDkwOTY1MzMwNzFjNjU3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuZmV0Y2goZ2V0T2JqZWN0KGFyZzEpKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZldGNoX2YxODU2YWZkYjQ5NDE1ZDEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGZldGNoKGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19maWVsZF9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEZpZWxkLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2ZpZWxkX3Vud3JhcCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gRmllbGQuX191bndyYXAodGFrZU9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRSYW5kb21WYWx1ZXNfYmNiNDkxMmYxNjAwMGRjNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLmdldFJhbmRvbVZhbHVlcyhnZXRPYmplY3QoYXJnMSkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfNjdiMmJhNjJmYzMwZGUxMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5nZXQoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19nZXRfYjliOTMwNDdmZTNjZjQ1YiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApW2FyZzEgPj4+IDBdO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfZ3JvdXBfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBHcm91cC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19oYXNfYTVlYTkxMTdmMjU4YTBlYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVmbGVjdC5oYXMoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19oZWFkZXJzXzljYjUxY2ZkMmFjNzgwYTQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfaW5zdGFuY2VvZl9SZXNwb25zZV9mMmNjMjBkOWY3ZGZkNjQ0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0T2JqZWN0KGFyZzApIGluc3RhbmNlb2YgUmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2l0ZXJhdG9yXzlhMjRjODhkZjg2MGRjNjUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfa2V5cGFpcl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEtleVBhaXIuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoX2E0NDYxOTNkYzIyYzEyZjggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19sZW5ndGhfZTJkMmE0OTEzMmMxYjI1NiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX2xvZ18xYWY3YWU3YmQ5YzZhZTE5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbXNDcnlwdG9fMGEzNmUyZWMzYTM0M2QyNiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLm1zQ3J5cHRvO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzAxOGRjYzJkNmM4YzJmNmEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzIzYTI2NjVmYWM4M2M2MTEgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUwID0ge2E6IGFyZzAsIGI6IGFyZzF9O1xuICAgICAgICAgICAgdmFyIGNiMCA9IChhcmcwLCBhcmcxKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHN0YXRlMC5hO1xuICAgICAgICAgICAgICAgIHN0YXRlMC5hID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX193YmdfYWRhcHRlcl80OTEoYSwgc3RhdGUwLmIsIGFyZzAsIGFyZzEpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlMC5hID0gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoY2IwKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzdGF0ZTAuYSA9IHN0YXRlMC5iID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3Xzc4ZmViMTA4YjY0NzI3MTMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfODYyMzFlMjI1Y2E2Yjk2MiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3XzhhNmYyMzhhNmVjZTg2ZWEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19iMWEzM2U1MDk1YWJmNjc4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgV29ya2VyKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld19lMjVlNWFhYjA5ZmY0NWRiID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3X2U5YTRhNjdkYmFiYWJlNTcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBJbnQzMkFycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXdub2FyZ3NfMTA1ZWQ0NzE0NzVhYWY1MCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEZ1bmN0aW9uKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9kOTdlNjM3ZWJlMTQ1YTlhID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCksIGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aGxlbmd0aF9hMzgxNjM0ZTkwYzI3NmQ0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShhcmcwID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld3dpdGhsZW5ndGhfYzRjNDE5ZWYwYmM4YTFmOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGFyZzAgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV3d2l0aHN0cmFuZGluaXRfMDZjNTM1ZTBhODY3YzYzNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFJlcXVlc3QoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpLCBnZXRPYmplY3QoYXJnMikpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19uZXh0XzI1ZmVhZGZjMDkxM2ZlYTkgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5uZXh0O1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfbmV4dF82NTc0ZTFhOGE2MmQxMDU1ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubmV4dCgpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19ub2RlXzAyOTk5NTMzYzRlYTAyZTMgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5ub2RlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb2ZfNGEwNTE5N2JmYzg5NTU2ZiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gQXJyYXkub2YoZ2V0T2JqZWN0KGFyZzApLCBnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19vcGVuXzEzYTU5OGVhNTBkODI5MjYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vcGVuKGdldFN0cmluZ0Zyb21XYXNtMChhcmcxLCBhcmcyKSwgZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzMsIGFyZzQpLCBhcmc1ICE9PSAwKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfb3ZlcnJpZGVNaW1lVHlwZV8zNmNlNWVlYWUyMGFmZjlmID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkub3ZlcnJpZGVNaW1lVHlwZShnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMikpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wbGFpbnRleHRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBQbGFpbnRleHQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcG9zdE1lc3NhZ2VfNmVkYWZhOGY3YjljMmY1MiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnBvc3RNZXNzYWdlKGdldE9iamVjdChhcmcxKSk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3Byb2Nlc3NfNWMxZDY3MGJjNTM2MTRiOCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnByb2Nlc3M7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19wdXNoXzczN2NmYzhjMTQzMmMyYzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5wdXNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19xdWV1ZU1pY3JvdGFza185N2Q5MmI0ZmNjOGE2MWM1ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhnZXRPYmplY3QoYXJnMCkpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcXVldWVNaWNyb3Rhc2tfZDMyMTlkZWY4MjU1MjQ4NSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnF1ZXVlTWljcm90YXNrO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmFuZG9tRmlsbFN5bmNfYWIyY2ZlNzllYmJmMjc0MCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnJhbmRvbUZpbGxTeW5jKHRha2VPYmplY3QoYXJnMSkpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWNvcmRjaXBoZXJ0ZXh0X25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gUmVjb3JkQ2lwaGVydGV4dC5fX3dyYXAoYXJnMCk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZWNvcmRwbGFpbnRleHRfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBSZWNvcmRQbGFpbnRleHQuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVxdWlyZV83OWIxZTkyNzRjZGUzYzg3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG1vZHVsZS5yZXF1aXJlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19yZXNvbHZlXzQ4NTE3ODVjOWM1ZjU3M2QgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFByb21pc2UucmVzb2x2ZShnZXRPYmplY3QoYXJnMCkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzcG9uc2VUZXh0X2FkMDUwYWE3ZjhhZmVjOWYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcxKS5yZXNwb25zZVRleHQ7XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAxLCBsZW4xLCB0cnVlKTtcbiAgICAgICAgZ2V0RGF0YVZpZXdNZW1vcnkwKCkuc2V0SW50MzIoYXJnMCArIDQgKiAwLCBwdHIxLCB0cnVlKTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfcmVzcG9uc2VfNDllMTBmOGVlN2Y0MThkYiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH0sIGFyZ3VtZW50cykgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZW5kXzQwYTQ3NjM2ZmY5MGY2NGQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGZ1bmN0aW9uIChhcmcwKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZW5kKCk7XG4gICAgfSwgYXJndW1lbnRzKSB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF8zNzgzNzAyM2YzZDc0MGU4ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBnZXRPYmplY3QoYXJnMClbYXJnMSA+Pj4gMF0gPSB0YWtlT2JqZWN0KGFyZzIpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0XzY1NTk1YmRkODY4YjMwMDkgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldF9iYjhjZWNmNmE2MmI5ZjQ2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBSZWZsZWN0LnNldChnZXRPYmplY3QoYXJnMCksIGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0Ym9keV81OTIzYjc4YTk1ZWVkZjI5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBnZXRPYmplY3QoYXJnMCkuYm9keSA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NldGNyZWRlbnRpYWxzX2MzYTIyZjFjZDEwNWEyYzYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5jcmVkZW50aWFscyA9IF9fd2JpbmRnZW5fZW51bV9SZXF1ZXN0Q3JlZGVudGlhbHNbYXJnMV07XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRoZWFkZXJzXzgzNGMwYmRiNmE4OTQ5YWQgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5oZWFkZXJzID0gZ2V0T2JqZWN0KGFyZzEpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0bWV0aG9kXzNjNTI4MGZlNWQ4OTA4NDIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5tZXRob2QgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMSwgYXJnMik7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRtb2RlXzVkYzMwMGI4NjUwNDRiNjUgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5tb2RlID0gX193YmluZGdlbl9lbnVtX1JlcXVlc3RNb2RlW2FyZzFdO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2V0b25tZXNzYWdlXzVhODg1YjE2YmRjNmRjYTYgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGdldE9iamVjdChhcmcwKS5vbm1lc3NhZ2UgPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zZXRzaWduYWxfNzViMjFlZjNhODFkZTkwNSA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgZ2V0T2JqZWN0KGFyZzApLnNpZ25hbCA9IGdldE9iamVjdChhcmcxKTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NpZ25hbF9hYWY5YWQ3NDExOWYyMGE0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuc2lnbmFsO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc2lnbmF0dXJlX25ldyA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gU2lnbmF0dXJlLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3NwYXduV29ya2VyX2E4ZTBmZmI3NDdlMjY0ZGUgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHNwYXduV29ya2VyKGdldE9iamVjdChhcmcwKSwgZ2V0T2JqZWN0KGFyZzEpLCBnZXRPYmplY3QoYXJnMiksIGFyZzMgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhY2tfMGVkNzVkNjg1NzViMGYzYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzEpLnN0YWNrO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMXzg4YTkwMmQxM2E1NTdkMDcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZ2xvYmFsO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9HTE9CQUxfVEhJU181NjU3OGJlN2U5ZjgzMmIwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBnbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gaXNMaWtlTm9uZShyZXQpID8gMCA6IGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3N0YXRpY19hY2Nlc3Nvcl9TRUxGXzM3YzVkNDE4ZTRiZjU4MTkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHNlbGY7XG4gICAgICAgIHJldHVybiBpc0xpa2VOb25lKHJldCkgPyAwIDogYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdGljX2FjY2Vzc29yX1dJTkRPV181ZGUzNzA0M2E5MWE5YzQwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbiAgICAgICAgcmV0dXJuIGlzTGlrZU5vbmUocmV0KSA/IDAgOiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdGF0dXNfMTJiY2Y4OGE4ZmY1MTQ3MCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN0YXR1cztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhdHVzX2Y2MzYwMzM2Y2E2ODZiZjAgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5zdGF0dXM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19zdHJpbmdpZnlfZjdlZDY5ODc5MzViNGEyNCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gSlNPTi5zdHJpbmdpZnkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9LCBhcmd1bWVudHMpIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3ViYXJyYXlfYWE5MDY1ZmE5ZGM1ZGY5NiA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnN1YmFycmF5KGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl80NGI3Mzk0NmQyZmIzZTdkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSkpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdGhlbl80OGI0MDY3NDk4NzhhNTMxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudGhlbihnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ190cmFuc2FjdGlvbl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFRyYW5zYWN0aW9uLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3RyYW5zaXRpb25fbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBUcmFuc2l0aW9uLl9fd3JhcChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX3VybF9hZTEwYzM0Y2EyMDk2ODFkID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMSkudXJsO1xuICAgICAgICBjb25zdCBwdHIxID0gcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMSwgbGVuMSwgdHJ1ZSk7XG4gICAgICAgIGdldERhdGFWaWV3TWVtb3J5MCgpLnNldEludDMyKGFyZzAgKyA0ICogMCwgcHRyMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192YWx1ZV9jZDFmZmE3YjFhYjc5NGYxID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmFsdWU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192YWx1ZV9kYWI3M2QzZDVkNGFiYWFmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkudmFsdWU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ192ZXJpZnlpbmdrZXlfbmV3ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBWZXJpZnlpbmdLZXkuX193cmFwKGFyZzApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmdfdmVyc2lvbnNfYzcxYWExNjI2YTkzZTBhMSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLnZlcnNpb25zO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfd2FpdEFzeW5jXzYxZjBhMDgxMDUzZGQzYzIgPSBmdW5jdGlvbihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEF0b21pY3Mud2FpdEFzeW5jKGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMik7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ193YWl0QXN5bmNfN2NlNmM4YTA0N2M3NTJjMyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBBdG9taWNzLndhaXRBc3luYztcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYmlnaW50X2Zyb21faTEyOCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMCA8PCBCaWdJbnQoNjQpIHwgQmlnSW50LmFzVWludE4oNjQsIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2JpZ2ludF9mcm9tX3UxMjggPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEJpZ0ludC5hc1VpbnROKDY0LCBhcmcwKSA8PCBCaWdJbnQoNjQpIHwgQmlnSW50LmFzVWludE4oNjQsIGFyZzEpO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9iaWdpbnRfZnJvbV91NjQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IEJpZ0ludC5hc1VpbnROKDY0LCBhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZih2KSA9PT0gJ2Jvb2xlYW4nID8gKHYgPyAxIDogMCkgOiAyO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jYl9kcm9wID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCBvYmogPSB0YWtlT2JqZWN0KGFyZzApLm9yaWdpbmFsO1xuICAgICAgICBpZiAob2JqLmNudC0tID09IDEpIHtcbiAgICAgICAgICAgIG9iai5hID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2MDQxID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCA1MTksIF9fd2JnX2FkYXB0ZXJfNDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI2MDQ3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCByZXQgPSBtYWtlTXV0Q2xvc3VyZShhcmcwLCBhcmcxLCA1MTksIF9fd2JnX2FkYXB0ZXJfNDApO1xuICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19mdW5jdGlvbiA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdHlwZW9mKGdldE9iamVjdChhcmcwKSkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX2lzX29iamVjdCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgICAgY29uc3QgdmFsID0gZ2V0T2JqZWN0KGFyZzApO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pc19zdHJpbmcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihnZXRPYmplY3QoYXJnMCkpID09PSAnc3RyaW5nJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5faXNfdW5kZWZpbmVkID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbGlua185NTc5ZjAxNmI0NTIyYTI0ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICBjb25zdCB2YWwgPSBgb25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBsZXQgW2lhLCBpbmRleCwgdmFsdWVdID0gZXYuZGF0YTtcbiAgICAgICAgICAgIGlhID0gbmV3IEludDMyQXJyYXkoaWEuYnVmZmVyKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBBdG9taWNzLndhaXQoaWEsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBgO1xuICAgICAgICBjb25zdCByZXQgPSB0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gJ3VuZGVmaW5lZCcgPyBcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpIDogVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbdmFsXSwgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiIH0pKTtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzQpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9tZW1vcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX21vZHVsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByZXQgPSBfX3diZ19pbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGU7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX251bWJlcl9uZXcgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGFyZzA7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB0YWtlT2JqZWN0KGFyZzApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9yZXRocm93ID0gZnVuY3Rpb24oYXJnMCkge1xuICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KGFyZzApO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCBvYmogPSBnZXRPYmplY3QoYXJnMSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHR5cGVvZihvYmopID09PSAnc3RyaW5nJyA/IG9iaiA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHJldCkgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocmV0LCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzMsIHdhc20uX193YmluZGdlbl9leHBvcnRfNCk7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfbmV3ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gICAgfTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGltcG9ydHM7XG59XG5cbmZ1bmN0aW9uIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMsIG1lbW9yeSkge1xuICAgIGltcG9ydHMud2JnLm1lbW9yeSA9IG1lbW9yeSB8fCBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjIzLG1heGltdW06NjU1MzYsc2hhcmVkOnRydWV9KTtcbn1cblxuZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlLCB0aHJlYWRfc3RhY2tfc2l6ZSkge1xuICAgIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICAgIF9fd2JnX2luaXQuX193YmluZGdlbl93YXNtX21vZHVsZSA9IG1vZHVsZTtcbiAgICBjYWNoZWREYXRhVmlld01lbW9yeTAgPSBudWxsO1xuICAgIGNhY2hlZFVpbnQ4QXJyYXlNZW1vcnkwID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgdGhyZWFkX3N0YWNrX3NpemUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgdGhyZWFkX3N0YWNrX3NpemUgIT09ICdudW1iZXInIHx8IHRocmVhZF9zdGFja19zaXplID09PSAwIHx8IHRocmVhZF9zdGFja19zaXplICUgNjU1MzYgIT09IDApKSB7IHRocm93ICdpbnZhbGlkIHN0YWNrIHNpemUnIH1cbiAgICB3YXNtLl9fd2JpbmRnZW5fc3RhcnQodGhyZWFkX3N0YWNrX3NpemUpO1xuICAgIHJldHVybiB3YXNtO1xufVxuXG5mdW5jdGlvbiBpbml0U3luYyhtb2R1bGUsIG1lbW9yeSkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG4gICAgbGV0IHRocmVhZF9zdGFja19zaXplO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICh7bW9kdWxlLCBtZW1vcnksIHRocmVhZF9zdGFja19zaXplfSA9IG1vZHVsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgYGluaXRTeW5jKClgOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRzID0gX193YmdfZ2V0X2ltcG9ydHMoKTtcblxuICAgIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMsIG1lbW9yeSk7XG5cbiAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpKSB7XG4gICAgICAgIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobW9kdWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSwgdGhyZWFkX3N0YWNrX3NpemUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19pbml0KG1vZHVsZV9vcl9wYXRoLCBtZW1vcnkpIHtcbiAgICBpZiAod2FzbSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gd2FzbTtcblxuICAgIGxldCB0aHJlYWRfc3RhY2tfc2l6ZTtcbiAgICBpZiAodHlwZW9mIG1vZHVsZV9vcl9wYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9vcl9wYXRoKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgKHttb2R1bGVfb3JfcGF0aCwgbWVtb3J5LCB0aHJlYWRfc3RhY2tfc2l6ZX0gPSBtb2R1bGVfb3JfcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGNvbnN0IGltcG9ydHMgPSBfX3diZ19nZXRfaW1wb3J0cygpO1xuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZV9vcl9wYXRoIGluc3RhbmNlb2YgUmVxdWVzdCkgfHwgKHR5cGVvZiBVUkwgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlX29yX3BhdGggaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIG1vZHVsZV9vcl9wYXRoID0gZmV0Y2gobW9kdWxlX29yX3BhdGgpO1xuICAgIH1cblxuICAgIF9fd2JnX2luaXRfbWVtb3J5KGltcG9ydHMsIG1lbW9yeSk7XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IF9fd2JnX2xvYWQoYXdhaXQgbW9kdWxlX29yX3BhdGgsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSwgdGhyZWFkX3N0YWNrX3NpemUpO1xufVxuXG5jb25zdCBtb2R1bGUkMSA9IG5ldyBVUkwoXCJhbGVvX3dhc20ud2FzbVwiLCBpbXBvcnQubWV0YS51cmwpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBfX3diZ19pbml0KHsgbW9kdWxlX29yX3BhdGg6IG1vZHVsZSQxIH0pO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0VGhyZWFkUG9vbCh0aHJlYWRzKSB7XG4gICAgaWYgKHRocmVhZHMgPT0gbnVsbCkge1xuICAgICAgICB0aHJlYWRzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgfVxuXG4gICAgY29uc29sZS5pbmZvKGBTcGF3bmluZyAke3RocmVhZHN9IHRocmVhZHNgKTtcblxuICAgIGF3YWl0IGluaXRUaHJlYWRQb29sJDEobmV3IFVSTChcIndvcmtlci5qc1wiLCBpbXBvcnQubWV0YS51cmwpLCB0aHJlYWRzKTtcbn1cblxuZXhwb3J0IHsgQWRkcmVzcywgQkhQMTAyNCwgQkhQMjU2LCBCSFA1MTIsIEJIUDc2OCwgQ2lwaGVydGV4dCwgQ29tcHV0ZUtleSwgRXhlY3V0aW9uLCBFeGVjdXRpb25SZXNwb25zZSwgRmllbGQsIEdyYXBoS2V5LCBHcm91cCwgS2V5UGFpciwgTWV0YWRhdGEsIE9mZmxpbmVRdWVyeSwgUGVkZXJzZW4xMjgsIFBlZGVyc2VuNjQsIFBsYWludGV4dCwgUG9zZWlkb24yLCBQb3NlaWRvbjQsIFBvc2VpZG9uOCwgUHJpdmF0ZUtleSwgUHJpdmF0ZUtleUNpcGhlcnRleHQsIFByb2dyYW0sIFByb2dyYW1NYW5hZ2VyLCBQcm92aW5nS2V5LCBSZWNvcmRDaXBoZXJ0ZXh0LCBSZWNvcmRQbGFpbnRleHQsIFNjYWxhciwgU2lnbmF0dXJlLCBUcmFuc2FjdGlvbiwgVHJhbnNpdGlvbiwgVmVyaWZ5aW5nS2V5LCBWaWV3S2V5LCBpbml0U3luYywgaW5pdFRocmVhZFBvb2wsIHJ1blJheW9uVGhyZWFkLCB2ZXJpZnlGdW5jdGlvbkV4ZWN1dGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/worker.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/worker.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/worker.dd4a4875.js";

/***/ })

};
;