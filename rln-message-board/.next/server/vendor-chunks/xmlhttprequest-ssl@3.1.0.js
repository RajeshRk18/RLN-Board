/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xmlhttprequest-ssl@3.1.0";
exports.ids = ["vendor-chunks/xmlhttprequest-ssl@3.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/xmlhttprequest-ssl@3.1.0/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/xmlhttprequest-ssl@3.1.0/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"buffer\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\n/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\n\n/**\n * Module exports.\n */\n\nmodule.exports = XMLHttpRequest;\n\n// backwards-compat\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\n *\n * @param {Object} opts optional \"options\" object\n */\n\nfunction XMLHttpRequest(opts) {\n  \"use strict\";\n\n  // defines a list of default options to prevent parameters pollution\n  var default_options = {\n    pfx: undefined,\n    key: undefined,\n    passphrase: undefined,\n    cert: undefined,\n    ca: undefined,\n    ciphers: undefined,\n    rejectUnauthorized: true,\n    autoUnref: false,\n    agent: undefined,\n    allowFileSystemResources: true,\n    maxRedirects: 20, // Chrome standard\n    origin: undefined\n  };\n\n  opts = Object.assign(default_options, opts);\n\n  var sslOptions = {\n    pfx: opts.pfx,\n    key: opts.key,\n    passphrase: opts.passphrase,\n    cert: opts.cert,\n    ca: opts.ca,\n    ciphers: opts.ciphers,\n    rejectUnauthorized: opts.rejectUnauthorized !== false\n  };\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = __webpack_require__(/*! http */ \"http\");\n  var https = __webpack_require__(/*! https */ \"https\");\n\n  var maxRedirects = opts.maxRedirects;\n  if (typeof maxRedirects !== 'number' || Number.isNaN(maxRedirects)) maxRedirects = 20;\n  else maxRedirects = Math.max(maxRedirects, 0);\n\n  var redirectCount = 0;\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n\n  var headers = Object.assign({}, defaultHeaders);\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n  var abortedFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.responseURL = \"\";\n  this.response = Buffer.alloc(0);\n  this.status = null;\n  this.statusText = null;\n\n  // xhr.responseType is supported:\n  //   When responseType is 'text' or '', self.responseText will be utf8 decoded text.\n  //   When responseType is 'json', self.responseText initially will be utf8 decoded text,\n  //   which is then JSON parsed into self.response.\n  //   When responseType is 'arraybuffer', self.response is an ArrayBuffer.\n  //   When responseType is 'blob', self.response is a Blob.\n  // cf. section 3.6, subsections 8,9,10,11 of https://xhr.spec.whatwg.org/#the-response-attribute\n  this.responseType = \"\"; /* 'arraybuffer' or 'text' or '' or 'json' or 'blob' */\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * When xhr.responseType === 'arraybuffer', xhr.response must have type ArrayBuffer according\n   * to section 3.6.9 of https://xhr.spec.whatwg.org/#the-response-attribute .\n   * However, bufTotal = Buffer.concat(...) often has byteOffset > 0, so bufTotal.buffer is larger\n   * than the useable region in bufTotal. This means that a new copy of bufTotal would need to be\n   * created to get the correct ArrayBuffer. Instead, do the concat by hand to create the right\n   * sized ArrayBuffer in the first place.\n   *\n   * The return type is Uint8Array,\n   * because often Buffer will have Buffer.length < Buffer.buffer.byteLength.\n   *\n   * @param {Array<Buffer>} bufferArray\n   * @returns {Uint8Array}\n   */\n  var concat = function(bufferArray) {\n    let length = 0, offset = 0;\n    for (let k = 0; k < bufferArray.length; k++)\n      length += bufferArray[k].length;\n    const result = new Uint8Array(length);\n    for (let k = 0; k < bufferArray.length; k++)\n    {\n      result.set(bufferArray[k], offset);\n      offset += bufferArray[k].length;\n    }\n    return result;\n  };\n\n  /**\n   * When xhr.responseType === 'arraybuffer', xhr.response must have type ArrayBuffer according\n   * to section 3.6.9 of https://xhr.spec.whatwg.org/#the-response-attribute .\n   * However, buf = Buffer.from(str) often has byteOffset > 0, so buf.buffer is larger than the\n   * usable region in buf. This means that a new copy of buf would need to be created to get the\n   * correct arrayBuffer. Instead, do it by hand to create the right sized ArrayBuffer in the\n   * first place.\n   *\n   * @param {string} str\n   * @returns {Buffer}\n   */\n  var stringToBuffer = function(str) {\n    const ab = new ArrayBuffer(str.length)\n    const buf = Buffer.from(ab);\n    for (let k = 0; k < str.length; k++)\n      buf[k] = Number(str.charCodeAt(k));\n    return buf;\n  }\n\n  /**\n   * Given a Buffer buf, check whether buf.buffer.byteLength > buf.length and if so,\n   * create a new ArrayBuffer whose byteLength is buf.length, containing the bytes.\n   * of buf. This function shouldn't usually be needed, unless there's a future\n   * behavior change where buf.buffer.byteLength > buf.length unexpectedly.\n   *\n   * @param {Buffer} buf\n   * @returns {ArrayBuffer}\n   */\n  var checkAndShrinkBuffer = function(buf) {\n    if (buf.length === buf.buffer.byteLength)\n      return buf.buffer;\n    const ab = new ArrayBuffer(buf.length);\n    const result = Buffer.from(ab);\n    for (let k = 0; k < buf.length; k++)\n      result[k] = buf[k];\n    return ab;\n  }\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n    abortedFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method.toUpperCase(),\n      \"url\": url,\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    // parse origin\n    try {\n      settings.origin = new URL(opts.origin);\n    }\n    catch (e) {\n      settings.origin = null;\n    }\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return false;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    headers[header] = value;\n    return true;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    // in case of local request, headers are not present\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n      && response\n      && response.headers\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    // in case of local request, headers are not present\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag || !response || !response.headers) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.slice(0, -2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Convert from Data URI to Buffer\n   * @param {URL} url URI to parse\n   * @returns {Buffer} buffer\n   */\n\n  var bufferFromDataUri = function (url) {\n    // Triming from original url object for more consistency\n    var data = url.href.slice(5);\n\n    // separator between header and actual data\n    var parts = data.split(\",\", 2);\n\n    if (parts.length < 2) throw \"Invalid URL\";\n\n    // check if header part has base64 (from 2nd header onwards)\n    var base64 = parts[0].split(\";\").some(function (dataHeader, index) {\n      return index > 0 && dataHeader.toLowerCase() === \"base64\";\n    });\n\n    var responseData, inputData = decodeURIComponent(parts[1]);\n\n    if (base64) {\n      // remove any ASCII whitespaces\n      inputData = inputData.replace(/(\\s|\\t|\\r|\\n|\\v|\\f)+/g, \"\");\n      // check padding amount\n      let padding = inputData.match(/=*$/)[0];\n      if (padding.length + (inputData.length - padding.length) % 4 > 4) throw \"invalid padding\";\n      inputData = inputData.slice(0, inputData.length - padding.length);\n      responseData = Buffer.from(inputData, \"base64\");\n      if (responseData.toString(\"base64\").replace(/=+$/, \"\") !== inputData) throw \"malformed base64 encoding\";\n      return responseData;\n    }\n    else {\n      return Buffer.from(inputData);\n    }\n  }\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var isSsl = false, isLocal = false, isDataUri = false;\n    var url;\n    try {\n      if (settings.origin) {\n        url = new URL(settings.url, settings.origin);\n      }\n      else {\n        url = new URL(settings.url);\n      }\n      settings.url = url.href;\n    }\n    catch (e) {\n      // URL parsing throws TypeError, here we only want to take its message\n      self.handleError(new Error(e.message));\n      return;\n    }\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case 'https:':\n        isSsl = true;\n        // SSL & non-SSL both need host, no break here.\n      case 'http:':\n        host = url.hostname;\n        break;\n\n      case 'data:':\n        isDataUri = true;\n      \n      case 'file:':\n        isLocal = true;\n        break;\n\n      case undefined:\n      case '':\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    // or data from Data URI (data:)\n    if (isLocal) {\n      if (isDataUri) try {\n        self.status = 200;\n        self.responseURL = settings.url;\n        self.createFileOrSyncResponse(bufferFromDataUri(url));\n        setState(self.DONE);\n        return;\n      }\n      catch (e) {\n        self.handleError(new Error(\"Invalid data URI\"));\n        return;\n      }\n\n      if (!opts.allowFileSystemResources) {\n        self.handleError(new Error(\"Not allowed to load local resource: \" + url.href));\n        return;\n      }\n\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(unescape(url.pathname), function(error, data) {\n          if (error) {\n            self.handleError(error, error.errno || -1);\n          } else {\n            self.status = 200;\n            self.responseURL = settings.url;\n            // Use self.responseType to create the correct self.responseType, self.response.\n            self.createFileOrSyncResponse(data);\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.status = 200;\n          const syncData = fs.readFileSync(unescape(url.pathname));\n          // Use self.responseType to create the correct self.responseType, self.response.\n          this.responseURL = settings.url;\n          this.createFileOrSyncResponse(syncData);\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e, e.errno || -1);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (isSsl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search || '');\n\n    // Set the Host header or the server may reject the request\n    headers[\"Host\"] = host;\n    if (!((isSsl && port === 443) || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = Buffer.from(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      var headersKeys = Object.keys(headers);\n      if (!headersKeys.some(function (h) { return h.toLowerCase() === 'content-type' })) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: opts.agent || false\n    };\n\n    // Reset error flag\n    errorFlag = false;\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = isSsl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function(resp) {\n        // Check for redirect\n        if (\n          resp.statusCode === 301 ||\n          resp.statusCode === 302 ||\n          resp.statusCode === 303 ||\n          resp.statusCode === 307 ||\n          resp.statusCode === 308\n        ) {\n          ++redirectCount;\n          // end the response\n          resp.destroy();\n          if (redirectCount > maxRedirects) {\n            self.handleError(new Error(\"Too many redirects\"));\n            return;\n          }\n          // Change URL to the redirect location\n          var url;\n          try {\n            url = new URL(resp.headers.location, settings.url);\n            // reject redirects to any protocols other than http and https\n            if (url.protocol !== \"https:\" && url.protocol !== \"http:\") throw \"bad protocol\";\n            settings.url = url.href;\n          }\n          catch (e) {\n            self.handleError(new Error(\"Unsafe redirect\"));\n            return;\n          }\n          // change request options again to match with new redirect protocol\n          isSsl = url.protocol === \"https:\";\n          doRequest = isSsl ? https.request : http.request;\n\n          // Set host and port var in case it's used later\n          host = url.hostname;\n          port = url.port || (isSsl ? 443 : 80);\n\n          headers[\"Host\"] = host;\n          if (!((isSsl && port === 443) || port === 80)) {\n            headers[\"Host\"] += ':' + url.port;\n          }\n\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: port,\n            path: url.pathname + (url.search || ''),\n            method: resp.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers\n          };\n\n          // Issue the new request\n          createRequest(newOptions);\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Collect buffers and concatenate once.\n        const buffers = [];\n\n        setState(self.HEADERS_RECEIVED);\n\n        // When responseType is 'text' or '', self.responseText will be utf8 decoded text.\n        // When responseType is 'json', self.responseText initially will be utf8 decoded text,\n        // which is then JSON parsed into self.response.\n        // When responseType is 'arraybuffer', self.response is an ArrayBuffer.\n        // When responseType is 'blob', self.response is a Blob.\n        // cf. section 3.6, subsections 8,9,10,11 of https://xhr.spec.whatwg.org/#the-response-attribute\n        const isUtf8 = self.responseType === \"\" || self.responseType === \"text\" || self.responseType === \"json\";\n        if (isUtf8 && response.setEncoding) {\n          response.setEncoding(\"utf8\");\n        }\n\n        self.status = response.statusCode;\n\n        response.on('data', function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            if (isUtf8) {\n              // When responseType is 'text', '', 'json',\n              //   then each chunk is already utf8 decoded.\n              self.responseText += chunk;\n            } else {\n              // Otherwise collect the chunk buffers.\n              buffers.push(chunk);\n            }\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        }.bind(response));\n\n        response.on('end', function() {\n          if (sendFlag) {\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n            sendFlag = false;\n            // Create the correct response for responseType.\n            self.createResponse(buffers);\n            self.statusText = this.statusMessage;\n            self.responseURL = settings.url;\n            // Discard the 'end' event if the connection has been aborted\n            setState(self.DONE);\n          }\n        }.bind(response));\n\n        response.on('error', function(error) {\n          self.handleError(error);\n        }.bind(response));\n      }\n\n      // Error handler for the request\n      var errorHandler = function(error) {\n        // In the case of https://nodejs.org/api/http.html#requestreusedsocket triggering an ECONNRESET,\n        // don't fail the xhr request, attempt again.\n        if (request.reusedSocket && error.code === 'ECONNRESET')\n          return doRequest(options, responseHandler).on('error', errorHandler);\n        self.handleError(error);\n      }\n\n      var createRequest = function (opt) {\n        opt = Object.assign({}, opt);\n        if (isSsl) Object.assign(opt, sslOptions);\n\n        request = doRequest(opt, responseHandler).on('error', errorHandler);\n\n        if (opts.autoUnref) {\n          request.on('socket', function (socket) {\n            socket.unref();\n          });\n        }\n\n        // Node 0.4 and later won't accept empty data. Make sure it's needed.\n        if (data) {\n          request.write(data);\n        }\n\n        request.end();\n      }\n\n      // Create the request\n      createRequest(options);\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"'use strict';\"\n        + \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"function concat(bufferArray) {\"\n        + \"  let length = 0, offset = 0;\"\n        + \"  for (let k = 0; k < bufferArray.length; k++)\"\n        + \"    length += bufferArray[k].length;\"\n        + \"  const result = Buffer.alloc(length);\"\n        + \"  for (let k = 0; k < bufferArray.length; k++) {\"\n        + \"    for (let i = 0; i < bufferArray[k].length; i++) {\"\n        + \"      result[offset+i] = bufferArray[k][i]\"\n        + \"    }\"\n        + \"    offset += bufferArray[k].length;\"\n        + \"  }\"\n        + \"  return result;\"\n        + \"};\"\n        + \"var doRequest = http\" + (isSsl ? \"s\" : \"\") + \".request;\"\n        + \"var isSsl = \" + !!isSsl + \";\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var sslOptions = \" + JSON.stringify(sslOptions) + \";\"\n        + \"var responseData = Buffer.alloc(0);\"\n        + \"var buffers = [];\"\n        + \"var url = new URL(\" + JSON.stringify(settings.url) + \");\"\n        + \"var maxRedirects = \" + maxRedirects + \", redirects_count = 0;\"\n        + \"var makeRequest = function () {\"\n        + \"  var opt = Object.assign({}, options);\"\n        + \"  if (isSsl) Object.assign(opt, sslOptions);\"\n        + \"  var req = doRequest(opt, function(response) {\"\n        + \"    if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307 || response.statusCode === 308) {\"\n        + \"      response.destroy();\"\n        + \"      ++redirects_count;\"\n        + \"      if (redirects_count > maxRedirects) {\"\n        + \"        fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR-REDIRECT: Too many redirects', 'utf8');\"\n        + \"        fs.unlinkSync('\" + syncFile + \"');\"\n        + \"        return;\"\n        + \"      }\"\n        + \"      try {\"\n        + \"        url = new URL(response.headers.location, url);\"\n        + \"        if (url.protocol !== 'https:' && url.protocol !== 'http:') throw 'bad protocol';\"\n        + \"      }\"\n        + \"      catch (e) {\"\n        + \"        fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR-REDIRECT: Unsafe redirect', 'utf8');\"\n        + \"        fs.unlinkSync('\" + syncFile + \"');\"\n        + \"        return;\"\n        + \"      };\"\n        + \"      isSsl = url.protocol === 'https:';\"\n        + \"      doRequest = isSsl ? https.request : http.request;\"\n        + \"      var port = url.port;\"\n        + \"      options = {\"\n        + \"        hostname: url.hostname,\"\n        + \"        port: port,\"\n        + \"        path: url.pathname + (url.search || ''),\"\n        + \"        method: response.statusCode === 303 ? 'GET' : options.method,\"\n        + \"        headers: options.headers\"\n        + \"      };\"\n        + \"      options.headers['Host'] = url.host;\"\n        + \"      if (!((isSsl && port === 443) || port === 80)) options.headers['Host'] += ':' + port;\"\n        + \"      makeRequest();\"\n        + \"      return;\"\n        + \"    }\"\n        + \"    response.on('data', function(chunk) {\"\n        + \"      buffers.push(chunk);\"\n        + \"    });\"\n        + \"    response.on('end', function() {\"\n        + \"      responseData = concat(buffers);\"\n        + \"      fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {url: url.href, statusCode: response.statusCode, statusText: response.statusMessage, headers: response.headers, data: responseData.toString('utf8')}}), 'utf8');\"\n        + \"      fs.unlinkSync('\" + syncFile + \"');\"\n        + \"    });\"\n        + \"    response.on('error', function(error) {\"\n        + \"      fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"      fs.unlinkSync('\" + syncFile + \"');\"\n        + \"    });\"\n        + \"  }).on('error', function(error) {\"\n        + \"    fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"    fs.unlinkSync('\" + syncFile + \"');\"\n        + \"  });\"\n        + \"  \" + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"  req.end();\"\n        + \"};\"\n        + \"makeRequest();\"\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      self.responseText = fs.readFileSync(contentFile, 'utf8');\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR(-REDIRECT){0,1}:/)) {\n        // If the file returned an error, handle it\n        if (self.responseText.startsWith('NODE-XMLHTTPREQUEST-ERROR-REDIRECT')) {\n          self.handleError(new Error(self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR-REDIRECT: /, \"\")));\n        }\n        else {\n          var errorObj = JSON.parse(self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\"));\n          self.handleError(errorObj, 503);\n        }\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        const resp = JSON.parse(self.responseText);\n        self.status = resp.data.statusCode;\n        self.statusText = resp.data.statusText;\n        self.responseURL = resp.data.url;\n        self.response = stringToBuffer(resp.data.data);\n        // Use self.responseType to create the correct self.responseType, self.response, self.responseXML.\n        self.createFileOrSyncResponse(self.response);\n        // Set up response correctly.\n        response = {\n          statusCode: self.status,\n          headers: resp.data.headers\n        };\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\n   */\n  this.handleError = function(error, status) {\n    this.status = status || 0;\n    this.statusText = error.message || \"\";\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    this.responseURL = \"\";\n    this.response = Buffer.alloc(0);\n    errorFlag = true;\n    setState(this.DONE);\n    if (!settings.async) throw error;\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = Object.assign({}, defaultHeaders);\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    this.response = Buffer.alloc(0);\n\n    errorFlag = abortedFlag = true\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function (event) {\n    let argument = { type: event };\n    if (typeof self[\"on\" + event] === \"function\") {\n      if (this.readyState === this.DONE && settings.async)\n        setTimeout(function() { self[\"on\" + event](argument) }, 0)\n      else\n        self[\"on\" + event](argument)\n    }\n    if (event in listeners) {\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\n        if (this.readyState === this.DONE)\n          setTimeout(function() { listeners[event][i].call(self, argument) }, 0)\n        else\n          listeners[event][i].call(self, argument)\n      }\n    }\n  };\n\n  /**\n   * Construct the correct form of response, given responseType when in non-file based, asynchronous mode.\n   *\n   * When self.responseType is \"\", \"text\", \"json\", self.responseText is a utf8 string.\n   * When self.responseType is \"arraybuffer\", \"blob\", the response is in the buffers parameter,\n   * an Array of Buffers. Then concat(buffers) is Uint8Array, from which checkAndShrinkBuffer\n   * extracts the correct sized ArrayBuffer.\n   *\n   * @param {Array<Buffer>} buffers\n   */\n  this.createResponse = function(buffers) {\n    self.responseXML = '';\n    switch (self.responseType) {\n      case \"\":\n      case \"text\":\n        self.response = self.responseText;\n        break;\n      case 'json':\n        self.response = JSON.parse(self.responseText);\n        self.responseText = '';\n        break;\n      default:\n        self.responseText = '';\n        const totalResponse = concat(buffers);\n        // When self.responseType === 'arraybuffer', self.response is an ArrayBuffer.\n        // Get the correct sized ArrayBuffer.\n        self.response = checkAndShrinkBuffer(totalResponse);\n        if (self.responseType === 'blob' && typeof Blob === 'function') {\n          // Construct the Blob object that contains response.\n          self.response = new Blob([self.response]);\n        }\n        break;\n    }\n  }\n\n  /**\n   * Construct the correct form of response, given responseType when in synchronous mode or file based.\n   *\n   * The input is the response parameter which is a Buffer.\n   * When self.responseType is \"\", \"text\", \"json\",\n   *   the input is further refined to be: response.toString('utf8').\n   * When self.responseType is \"arraybuffer\", \"blob\",\n   *   the input is further refined to be: checkAndShrinkBuffer(response).\n   *\n   * @param {Buffer} response\n   */\n  this.createFileOrSyncResponse = function(response) {\n    self.responseText = '';\n    self.responseXML = '';\n    switch (self.responseType) {\n      case \"\":\n      case \"text\":\n        self.responseText = response.toString('utf8');\n        self.response = self.responseText;\n        break;\n      case 'json':\n        self.response = JSON.parse(response.toString('utf8'));\n        break;\n      default:\n        // When self.responseType === 'arraybuffer', self.response is an ArrayBuffer.\n        // Get the correct sized ArrayBuffer.\n        self.response = checkAndShrinkBuffer(response);\n        if (self.responseType === 'blob' && typeof Blob === 'function') {\n          // Construct the Blob object that contains response.\n          self.response = new Blob([self.response]);\n        }\n        break;\n    }\n  }\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if ((self.readyState === state) || (self.readyState === self.UNSENT && abortedFlag))\n      return\n\n    self.readyState = state;\n\n    if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n      self.dispatchEvent(\"readystatechange\");\n    }\n\n    if (self.readyState === self.DONE) {\n      let fire\n\n      if (abortedFlag)\n        fire = \"abort\"\n      else if (errorFlag)\n        fire = \"error\"\n      else\n        fire = \"load\"\n\n      self.dispatchEvent(fire)\n\n      // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n      self.dispatchEvent(\"loadend\");\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0veG1saHR0cHJlcXVlc3Qtc3NsQDMuMS4wL25vZGVfbW9kdWxlcy94bWxodHRwcmVxdWVzdC1zc2wvbGliL1hNTEh0dHBSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFlBQVksaUVBQThCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0MsTUFBTSxnQ0FBZ0MsTUFBTTs7QUFFOUU7QUFDQSwyQ0FBMkMsMkNBQTJDO0FBQ3RGLDhDQUE4QztBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0EsMERBQTBELE9BQU87QUFDakUsb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxvRkFBb0Y7QUFDcEYseUNBQXlDO0FBQ3pDLHdDQUF3QztBQUN4Qyw2QkFBNkIsd0JBQXdCO0FBQ3JELCtDQUErQztBQUMvQyxpREFBaUQ7QUFDakQsNkJBQTZCLHdCQUF3QixNQUFNO0FBQzNELCtCQUErQiwyQkFBMkIsTUFBTTtBQUNoRTtBQUNBLGdCQUFnQjtBQUNoQiwrQ0FBK0M7QUFDL0MsY0FBYztBQUNkLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2Isa0VBQWtFO0FBQ2xFLHVDQUF1QztBQUN2Qyx5REFBeUQ7QUFDekQsK0RBQStEO0FBQy9ELDhDQUE4QztBQUM5Qyw0QkFBNEI7QUFDNUIsbUVBQW1FO0FBQ25FLHdFQUF3RTtBQUN4RSwwQ0FBMEM7QUFDMUMsdUNBQXVDLFdBQVc7QUFDbEQsdURBQXVEO0FBQ3ZELDBEQUEwRDtBQUMxRCw2S0FBNks7QUFDN0ssb0NBQW9DO0FBQ3BDLG1DQUFtQztBQUNuQyxzREFBc0Q7QUFDdEQsNkhBQTZIO0FBQzdILHFEQUFxRDtBQUNyRCwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixpRUFBaUU7QUFDakUsbUdBQW1HO0FBQ25HLGtCQUFrQjtBQUNsQiw0QkFBNEI7QUFDNUIsMEhBQTBIO0FBQzFILHFEQUFxRDtBQUNyRCwwQkFBMEI7QUFDMUIsbUJBQW1CO0FBQ25CLG1EQUFtRDtBQUNuRCxrRUFBa0U7QUFDbEUscUNBQXFDO0FBQ3JDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9EQUFvRDtBQUNwRCxzR0FBc0c7QUFDdEcsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QixnQkFBZ0I7QUFDaEIsb0RBQW9EO0FBQ3BELHFDQUFxQztBQUNyQyxnQkFBZ0IsRUFBRTtBQUNsQiw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hELHlFQUF5RSxrQkFBa0Isb0pBQW9KLFdBQVc7QUFDMVAsbURBQW1EO0FBQ25ELGdCQUFnQixFQUFFO0FBQ2xCLHFEQUFxRDtBQUNyRCx1SEFBdUg7QUFDdkgsbURBQW1EO0FBQ25ELGdCQUFnQixFQUFFO0FBQ2xCLGNBQWMsK0JBQStCO0FBQzdDLHFIQUFxSDtBQUNySCxpREFBaUQ7QUFDakQsY0FBYyxFQUFFO0FBQ2hCLHFHQUFxRztBQUNyRyx1QkFBdUI7QUFDdkIsYUFBYTtBQUNiLHlCQUF5QjtBQUN6QjtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixNQUFNOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvdXNlcm5hbWUvYWxlby9yYXRlLWxpbWl0aW5nLW51bGxpZmllci9ybG4tbWVzc2FnZS1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0veG1saHR0cHJlcXVlc3Qtc3NsQDMuMS4wL25vZGVfbW9kdWxlcy94bWxodHRwcmVxdWVzdC1zc2wvbGliL1hNTEh0dHBSZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV3JhcHBlciBmb3IgYnVpbHQtaW4gaHR0cC5qcyB0byBlbXVsYXRlIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcbiAqIGFsbG93IHRoZSB1c2Ugb2YgZXhpc3RpbmcgbGlicmFyaWVzLlxuICpcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxuICpcbiAqIEBhdXRob3IgRGFuIERlRmVsaXBwaSA8ZGFuQGRyaXZlcmRhbi5jb20+XG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcblxuLy8gYmFja3dhcmRzLWNvbXBhdFxuWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcblxuLyoqXG4gKiBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGZvciB0aGUgYG9wdHNgIG9iamVjdCBhcmU6XG4gKlxuICogIC0gYGFnZW50YDogQW4gaHR0cC5BZ2VudCBpbnN0YW5jZTsgaHR0cC5nbG9iYWxBZ2VudCBtYXkgYmUgdXNlZDsgaWYgJ3VuZGVmaW5lZCcsIGFnZW50IHVzYWdlIGlzIGRpc2FibGVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9uYWwgXCJvcHRpb25zXCIgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBkZWZpbmVzIGEgbGlzdCBvZiBkZWZhdWx0IG9wdGlvbnMgdG8gcHJldmVudCBwYXJhbWV0ZXJzIHBvbGx1dGlvblxuICB2YXIgZGVmYXVsdF9vcHRpb25zID0ge1xuICAgIHBmeDogdW5kZWZpbmVkLFxuICAgIGtleTogdW5kZWZpbmVkLFxuICAgIHBhc3NwaHJhc2U6IHVuZGVmaW5lZCxcbiAgICBjZXJ0OiB1bmRlZmluZWQsXG4gICAgY2E6IHVuZGVmaW5lZCxcbiAgICBjaXBoZXJzOiB1bmRlZmluZWQsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0cnVlLFxuICAgIGF1dG9VbnJlZjogZmFsc2UsXG4gICAgYWdlbnQ6IHVuZGVmaW5lZCxcbiAgICBhbGxvd0ZpbGVTeXN0ZW1SZXNvdXJjZXM6IHRydWUsXG4gICAgbWF4UmVkaXJlY3RzOiAyMCwgLy8gQ2hyb21lIHN0YW5kYXJkXG4gICAgb3JpZ2luOiB1bmRlZmluZWRcbiAgfTtcblxuICBvcHRzID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0X29wdGlvbnMsIG9wdHMpO1xuXG4gIHZhciBzc2xPcHRpb25zID0ge1xuICAgIHBmeDogb3B0cy5wZngsXG4gICAga2V5OiBvcHRzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogb3B0cy5jZXJ0LFxuICAgIGNhOiBvcHRzLmNhLFxuICAgIGNpcGhlcnM6IG9wdHMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkICE9PSBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbiAgdmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcblxuICB2YXIgbWF4UmVkaXJlY3RzID0gb3B0cy5tYXhSZWRpcmVjdHM7XG4gIGlmICh0eXBlb2YgbWF4UmVkaXJlY3RzICE9PSAnbnVtYmVyJyB8fCBOdW1iZXIuaXNOYU4obWF4UmVkaXJlY3RzKSkgbWF4UmVkaXJlY3RzID0gMjA7XG4gIGVsc2UgbWF4UmVkaXJlY3RzID0gTWF0aC5tYXgobWF4UmVkaXJlY3RzLCAwKTtcblxuICB2YXIgcmVkaXJlY3RDb3VudCA9IDA7XG5cbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXG4gIHZhciByZXF1ZXN0O1xuICB2YXIgcmVzcG9uc2U7XG5cbiAgLy8gUmVxdWVzdCBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSB7fTtcblxuICAvLyBEaXNhYmxlIGhlYWRlciBibGFja2xpc3QuXG4gIC8vIE5vdCBwYXJ0IG9mIFhIUiBzcGVjcy5cbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xuXG4gIC8vIFNldCBzb21lIGRlZmF1bHQgaGVhZGVyc1xuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJVc2VyLUFnZW50XCI6IFwibm9kZS1YTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiQWNjZXB0XCI6IFwiKi8qXCJcbiAgfTtcblxuICB2YXIgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIZWFkZXJzKTtcblxuICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBub3QgdXNlciBzZXRhYmxlLlxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSBhbGxvd2VkIGJ1dCBiYW5uZWQgaW4gdGhlIHNwZWM6XG4gIC8vICogdXNlci1hZ2VudFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ2aWFcIlxuICBdO1xuXG4gIC8vIFRoZXNlIHJlcXVlc3QgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWRcbiAgdmFyIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzID0gW1xuICAgIFwiVFJBQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJDT05ORUNUXCJcbiAgXTtcblxuICAvLyBTZW5kIGZsYWdcbiAgdmFyIHNlbmRGbGFnID0gZmFsc2U7XG4gIC8vIEVycm9yIGZsYWcsIHVzZWQgd2hlbiBlcnJvcnMgb2NjdXIgb3IgYWJvcnQgaXMgY2FsbGVkXG4gIHZhciBlcnJvckZsYWcgPSBmYWxzZTtcbiAgdmFyIGFib3J0ZWRGbGFnID0gZmFsc2U7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIHRoaXMuVU5TRU5UID0gMDtcbiAgdGhpcy5PUEVORUQgPSAxO1xuICB0aGlzLkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuICB0aGlzLkxPQURJTkcgPSAzO1xuICB0aGlzLkRPTkUgPSA0O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgdmFyc1xuICAgKi9cblxuICAvLyBDdXJyZW50IHN0YXRlXG4gIHRoaXMucmVhZHlTdGF0ZSA9IHRoaXMuVU5TRU5UO1xuXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxuICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcbiAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICB0aGlzLnJlc3BvbnNlWE1MID0gXCJcIjtcbiAgdGhpcy5yZXNwb25zZVVSTCA9IFwiXCI7XG4gIHRoaXMucmVzcG9uc2UgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHRoaXMuc3RhdHVzID0gbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gbnVsbDtcblxuICAvLyB4aHIucmVzcG9uc2VUeXBlIGlzIHN1cHBvcnRlZDpcbiAgLy8gICBXaGVuIHJlc3BvbnNlVHlwZSBpcyAndGV4dCcgb3IgJycsIHNlbGYucmVzcG9uc2VUZXh0IHdpbGwgYmUgdXRmOCBkZWNvZGVkIHRleHQuXG4gIC8vICAgV2hlbiByZXNwb25zZVR5cGUgaXMgJ2pzb24nLCBzZWxmLnJlc3BvbnNlVGV4dCBpbml0aWFsbHkgd2lsbCBiZSB1dGY4IGRlY29kZWQgdGV4dCxcbiAgLy8gICB3aGljaCBpcyB0aGVuIEpTT04gcGFyc2VkIGludG8gc2VsZi5yZXNwb25zZS5cbiAgLy8gICBXaGVuIHJlc3BvbnNlVHlwZSBpcyAnYXJyYXlidWZmZXInLCBzZWxmLnJlc3BvbnNlIGlzIGFuIEFycmF5QnVmZmVyLlxuICAvLyAgIFdoZW4gcmVzcG9uc2VUeXBlIGlzICdibG9iJywgc2VsZi5yZXNwb25zZSBpcyBhIEJsb2IuXG4gIC8vIGNmLiBzZWN0aW9uIDMuNiwgc3Vic2VjdGlvbnMgOCw5LDEwLDExIG9mIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jdGhlLXJlc3BvbnNlLWF0dHJpYnV0ZVxuICB0aGlzLnJlc3BvbnNlVHlwZSA9IFwiXCI7IC8qICdhcnJheWJ1ZmZlcicgb3IgJ3RleHQnIG9yICcnIG9yICdqc29uJyBvciAnYmxvYicgKi9cblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIGhlYWRlciBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBIZWFkZXIgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICByZXR1cm4gZGlzYWJsZUhlYWRlckNoZWNrIHx8IChoZWFkZXIgJiYgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBtZXRob2QgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBtZXRob2QgUmVxdWVzdCBtZXRob2QgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybiBib29sZWFuIEZhbHNlIGlmIG5vdCBhbGxvd2VkLCBvdGhlcndpc2UgdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQWxsb3dlZEh0dHBNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICByZXR1cm4gKG1ldGhvZCAmJiBmb3JiaWRkZW5SZXF1ZXN0TWV0aG9kcy5pbmRleE9mKG1ldGhvZCkgPT09IC0xKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInLCB4aHIucmVzcG9uc2UgbXVzdCBoYXZlIHR5cGUgQXJyYXlCdWZmZXIgYWNjb3JkaW5nXG4gICAqIHRvIHNlY3Rpb24gMy42Ljkgb2YgaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyN0aGUtcmVzcG9uc2UtYXR0cmlidXRlIC5cbiAgICogSG93ZXZlciwgYnVmVG90YWwgPSBCdWZmZXIuY29uY2F0KC4uLikgb2Z0ZW4gaGFzIGJ5dGVPZmZzZXQgPiAwLCBzbyBidWZUb3RhbC5idWZmZXIgaXMgbGFyZ2VyXG4gICAqIHRoYW4gdGhlIHVzZWFibGUgcmVnaW9uIGluIGJ1ZlRvdGFsLiBUaGlzIG1lYW5zIHRoYXQgYSBuZXcgY29weSBvZiBidWZUb3RhbCB3b3VsZCBuZWVkIHRvIGJlXG4gICAqIGNyZWF0ZWQgdG8gZ2V0IHRoZSBjb3JyZWN0IEFycmF5QnVmZmVyLiBJbnN0ZWFkLCBkbyB0aGUgY29uY2F0IGJ5IGhhbmQgdG8gY3JlYXRlIHRoZSByaWdodFxuICAgKiBzaXplZCBBcnJheUJ1ZmZlciBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdHlwZSBpcyBVaW50OEFycmF5LFxuICAgKiBiZWNhdXNlIG9mdGVuIEJ1ZmZlciB3aWxsIGhhdmUgQnVmZmVyLmxlbmd0aCA8IEJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBidWZmZXJBcnJheVxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIHZhciBjb25jYXQgPSBmdW5jdGlvbihidWZmZXJBcnJheSkge1xuICAgIGxldCBsZW5ndGggPSAwLCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYnVmZmVyQXJyYXkubGVuZ3RoOyBrKyspXG4gICAgICBsZW5ndGggKz0gYnVmZmVyQXJyYXlba10ubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBidWZmZXJBcnJheS5sZW5ndGg7IGsrKylcbiAgICB7XG4gICAgICByZXN1bHQuc2V0KGJ1ZmZlckFycmF5W2tdLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlckFycmF5W2tdLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInLCB4aHIucmVzcG9uc2UgbXVzdCBoYXZlIHR5cGUgQXJyYXlCdWZmZXIgYWNjb3JkaW5nXG4gICAqIHRvIHNlY3Rpb24gMy42Ljkgb2YgaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyN0aGUtcmVzcG9uc2UtYXR0cmlidXRlIC5cbiAgICogSG93ZXZlciwgYnVmID0gQnVmZmVyLmZyb20oc3RyKSBvZnRlbiBoYXMgYnl0ZU9mZnNldCA+IDAsIHNvIGJ1Zi5idWZmZXIgaXMgbGFyZ2VyIHRoYW4gdGhlXG4gICAqIHVzYWJsZSByZWdpb24gaW4gYnVmLiBUaGlzIG1lYW5zIHRoYXQgYSBuZXcgY29weSBvZiBidWYgd291bGQgbmVlZCB0byBiZSBjcmVhdGVkIHRvIGdldCB0aGVcbiAgICogY29ycmVjdCBhcnJheUJ1ZmZlci4gSW5zdGVhZCwgZG8gaXQgYnkgaGFuZCB0byBjcmVhdGUgdGhlIHJpZ2h0IHNpemVkIEFycmF5QnVmZmVyIGluIHRoZVxuICAgKiBmaXJzdCBwbGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgdmFyIHN0cmluZ1RvQnVmZmVyID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgY29uc3QgYWIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aClcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShhYik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBzdHIubGVuZ3RoOyBrKyspXG4gICAgICBidWZba10gPSBOdW1iZXIoc3RyLmNoYXJDb2RlQXQoaykpO1xuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBCdWZmZXIgYnVmLCBjaGVjayB3aGV0aGVyIGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCA+IGJ1Zi5sZW5ndGggYW5kIGlmIHNvLFxuICAgKiBjcmVhdGUgYSBuZXcgQXJyYXlCdWZmZXIgd2hvc2UgYnl0ZUxlbmd0aCBpcyBidWYubGVuZ3RoLCBjb250YWluaW5nIHRoZSBieXRlcy5cbiAgICogb2YgYnVmLiBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndCB1c3VhbGx5IGJlIG5lZWRlZCwgdW5sZXNzIHRoZXJlJ3MgYSBmdXR1cmVcbiAgICogYmVoYXZpb3IgY2hhbmdlIHdoZXJlIGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCA+IGJ1Zi5sZW5ndGggdW5leHBlY3RlZGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIHZhciBjaGVja0FuZFNocmlua0J1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgICBjb25zdCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihidWYubGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuZnJvbShhYik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBidWYubGVuZ3RoOyBrKyspXG4gICAgICByZXN1bHRba10gPSBidWZba107XG4gICAgcmV0dXJuIGFiO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBjb25uZWN0aW9uLiBDdXJyZW50bHkgc3VwcG9ydHMgbG9jYWwgc2VydmVyIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxuICAgKiBAcGFyYW0gc3RyaW5nIHVybCBVUkwgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gYm9vbGVhbiBhc3luYyBBc3luY2hyb25vdXMgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0gc3RyaW5nIHVzZXIgVXNlcm5hbWUgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICogQHBhcmFtIHN0cmluZyBwYXNzd29yZCBQYXNzd29yZCBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcbiAgICBhYm9ydGVkRmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHZhbGlkIHJlcXVlc3QgbWV0aG9kXG4gICAgaWYgKCFpc0FsbG93ZWRIdHRwTWV0aG9kKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlY3VyaXR5RXJyb3I6IFJlcXVlc3QgbWV0aG9kIG5vdCBhbGxvd2VkXCIpO1xuICAgIH1cblxuICAgIHNldHRpbmdzID0ge1xuICAgICAgXCJtZXRob2RcIjogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBcInVybFwiOiB1cmwsXG4gICAgICBcImFzeW5jXCI6ICh0eXBlb2YgYXN5bmMgIT09IFwiYm9vbGVhblwiID8gdHJ1ZSA6IGFzeW5jKSxcbiAgICAgIFwidXNlclwiOiB1c2VyIHx8IG51bGwsXG4gICAgICBcInBhc3N3b3JkXCI6IHBhc3N3b3JkIHx8IG51bGxcbiAgICB9O1xuXG4gICAgLy8gcGFyc2Ugb3JpZ2luXG4gICAgdHJ5IHtcbiAgICAgIHNldHRpbmdzLm9yaWdpbiA9IG5ldyBVUkwob3B0cy5vcmlnaW4pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgc2V0dGluZ3Mub3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRTdGF0ZSh0aGlzLk9QRU5FRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIG9yIGVuYWJsZXMgaXNBbGxvd2VkSHR0cEhlYWRlcigpIGNoZWNrIHRoZSByZXF1ZXN0LiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqIFRoaXMgZG9lcyBub3QgY29uZm9ybSB0byB0aGUgVzNDIHNwZWMuXG4gICAqXG4gICAqIEBwYXJhbSBib29sZWFuIHN0YXRlIEVuYWJsZSBvciBkaXNhYmxlIGhlYWRlciBjaGVja2luZy5cbiAgICovXG4gIHRoaXMuc2V0RGlzYWJsZUhlYWRlckNoZWNrID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBzdGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBIZWFkZXIgYWRkZWRcbiAgICovXG4gIHRoaXMuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2V0UmVxdWVzdEhlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiBzdGF0ZSBpcyBPUEVOXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBIZWFkZXIoaGVhZGVyKSkge1xuICAgICAgY29uc29sZS53YXJuKCdSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFwiJyArIGhlYWRlciArICdcIicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGZsYWcgaXMgdHJ1ZVwiKTtcbiAgICB9XG4gICAgaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBOYW1lIG9mIGhlYWRlciB0byBnZXQuXG4gICAqIEByZXR1cm4gc3RyaW5nIFRleHQgb2YgdGhlIGhlYWRlciBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICB0aGlzLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBsb2NhbCByZXF1ZXN0LCBoZWFkZXJzIGFyZSBub3QgcHJlc2VudFxuICAgIGlmICh0eXBlb2YgaGVhZGVyID09PSBcInN0cmluZ1wiXG4gICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgPiB0aGlzLk9QRU5FRFxuICAgICAgJiYgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV1cbiAgICAgICYmICFlcnJvckZsYWdcbiAgICAgICYmIHJlc3BvbnNlXG4gICAgICAmJiByZXNwb25zZS5oZWFkZXJzXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHN0cmluZyBBIHN0cmluZyB3aXRoIGFsbCByZXNwb25zZSBoZWFkZXJzIHNlcGFyYXRlZCBieSBDUitMRlxuICAgKi9cbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGxvY2FsIHJlcXVlc3QsIGhlYWRlcnMgYXJlIG5vdCBwcmVzZW50XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8IHRoaXMuSEVBREVSU19SRUNFSVZFRCB8fCBlcnJvckZsYWcgfHwgIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIC8vIENvb2tpZSBoZWFkZXJzIGFyZSBleGNsdWRlZFxuICAgICAgaWYgKGkgIT09IFwic2V0LWNvb2tpZVwiICYmIGkgIT09IFwic2V0LWNvb2tpZTJcIikge1xuICAgICAgICByZXN1bHQgKz0gaSArIFwiOiBcIiArIHJlc3BvbnNlLmhlYWRlcnNbaV0gKyBcIlxcclxcblwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIC0yKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHJlcXVlc3QgaGVhZGVyXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbmFtZSBOYW1lIG9mIGhlYWRlciB0byBnZXRcbiAgICogQHJldHVybiBzdHJpbmcgUmV0dXJucyB0aGUgcmVxdWVzdCBoZWFkZXIgb3IgZW1wdHkgc3RyaW5nIGlmIG5vdCBzZXRcbiAgICovXG4gIHRoaXMuZ2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAvLyBAVE9ETyBNYWtlIHRoaXMgY2FzZSBpbnNlbnNpdGl2ZVxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBoZWFkZXJzW25hbWVdKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIjtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBmcm9tIERhdGEgVVJJIHRvIEJ1ZmZlclxuICAgKiBAcGFyYW0ge1VSTH0gdXJsIFVSSSB0byBwYXJzZVxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBidWZmZXJcbiAgICovXG5cbiAgdmFyIGJ1ZmZlckZyb21EYXRhVXJpID0gZnVuY3Rpb24gKHVybCkge1xuICAgIC8vIFRyaW1pbmcgZnJvbSBvcmlnaW5hbCB1cmwgb2JqZWN0IGZvciBtb3JlIGNvbnNpc3RlbmN5XG4gICAgdmFyIGRhdGEgPSB1cmwuaHJlZi5zbGljZSg1KTtcblxuICAgIC8vIHNlcGFyYXRvciBiZXR3ZWVuIGhlYWRlciBhbmQgYWN0dWFsIGRhdGFcbiAgICB2YXIgcGFydHMgPSBkYXRhLnNwbGl0KFwiLFwiLCAyKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB0aHJvdyBcIkludmFsaWQgVVJMXCI7XG5cbiAgICAvLyBjaGVjayBpZiBoZWFkZXIgcGFydCBoYXMgYmFzZTY0IChmcm9tIDJuZCBoZWFkZXIgb253YXJkcylcbiAgICB2YXIgYmFzZTY0ID0gcGFydHNbMF0uc3BsaXQoXCI7XCIpLnNvbWUoZnVuY3Rpb24gKGRhdGFIZWFkZXIsIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggPiAwICYmIGRhdGFIZWFkZXIudG9Mb3dlckNhc2UoKSA9PT0gXCJiYXNlNjRcIjtcbiAgICB9KTtcblxuICAgIHZhciByZXNwb25zZURhdGEsIGlucHV0RGF0YSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG5cbiAgICBpZiAoYmFzZTY0KSB7XG4gICAgICAvLyByZW1vdmUgYW55IEFTQ0lJIHdoaXRlc3BhY2VzXG4gICAgICBpbnB1dERhdGEgPSBpbnB1dERhdGEucmVwbGFjZSgvKFxcc3xcXHR8XFxyfFxcbnxcXHZ8XFxmKSsvZywgXCJcIik7XG4gICAgICAvLyBjaGVjayBwYWRkaW5nIGFtb3VudFxuICAgICAgbGV0IHBhZGRpbmcgPSBpbnB1dERhdGEubWF0Y2goLz0qJC8pWzBdO1xuICAgICAgaWYgKHBhZGRpbmcubGVuZ3RoICsgKGlucHV0RGF0YS5sZW5ndGggLSBwYWRkaW5nLmxlbmd0aCkgJSA0ID4gNCkgdGhyb3cgXCJpbnZhbGlkIHBhZGRpbmdcIjtcbiAgICAgIGlucHV0RGF0YSA9IGlucHV0RGF0YS5zbGljZSgwLCBpbnB1dERhdGEubGVuZ3RoIC0gcGFkZGluZy5sZW5ndGgpO1xuICAgICAgcmVzcG9uc2VEYXRhID0gQnVmZmVyLmZyb20oaW5wdXREYXRhLCBcImJhc2U2NFwiKTtcbiAgICAgIGlmIChyZXNwb25zZURhdGEudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvPSskLywgXCJcIikgIT09IGlucHV0RGF0YSkgdGhyb3cgXCJtYWxmb3JtZWQgYmFzZTY0IGVuY29kaW5nXCI7XG4gICAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGRhdGEgT3B0aW9uYWwgZGF0YSB0byBzZW5kIGFzIHJlcXVlc3QgYm9keS5cbiAgICovXG4gIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogY29ubmVjdGlvbiBtdXN0IGJlIG9wZW5lZCBiZWZvcmUgc2VuZCgpIGlzIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZW5kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBpc1NzbCA9IGZhbHNlLCBpc0xvY2FsID0gZmFsc2UsIGlzRGF0YVVyaSA9IGZhbHNlO1xuICAgIHZhciB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzZXR0aW5ncy5vcmlnaW4pIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChzZXR0aW5ncy51cmwsIHNldHRpbmdzLm9yaWdpbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChzZXR0aW5ncy51cmwpO1xuICAgICAgfVxuICAgICAgc2V0dGluZ3MudXJsID0gdXJsLmhyZWY7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyBVUkwgcGFyc2luZyB0aHJvd3MgVHlwZUVycm9yLCBoZXJlIHdlIG9ubHkgd2FudCB0byB0YWtlIGl0cyBtZXNzYWdlXG4gICAgICBzZWxmLmhhbmRsZUVycm9yKG5ldyBFcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGhvc3Q7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzZXJ2ZXJcbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgaXNTc2wgPSB0cnVlO1xuICAgICAgICAvLyBTU0wgJiBub24tU1NMIGJvdGggbmVlZCBob3N0LCBubyBicmVhayBoZXJlLlxuICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGF0YTonOlxuICAgICAgICBpc0RhdGFVcmkgPSB0cnVlO1xuICAgICAgXG4gICAgICBjYXNlICdmaWxlOic6XG4gICAgICAgIGlzTG9jYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICcnOlxuICAgICAgICBob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cblxuICAgIC8vIExvYWQgZmlsZXMgb2ZmIHRoZSBsb2NhbCBmaWxlc3lzdGVtIChmaWxlOi8vKVxuICAgIC8vIG9yIGRhdGEgZnJvbSBEYXRhIFVSSSAoZGF0YTopXG4gICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgIGlmIChpc0RhdGFVcmkpIHRyeSB7XG4gICAgICAgIHNlbGYuc3RhdHVzID0gMjAwO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVVJMID0gc2V0dGluZ3MudXJsO1xuICAgICAgICBzZWxmLmNyZWF0ZUZpbGVPclN5bmNSZXNwb25zZShidWZmZXJGcm9tRGF0YVVyaSh1cmwpKTtcbiAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJJXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdHMuYWxsb3dGaWxlU3lzdGVtUmVzb3VyY2VzKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlRXJyb3IobmV3IEVycm9yKFwiTm90IGFsbG93ZWQgdG8gbG9hZCBsb2NhbCByZXNvdXJjZTogXCIgKyB1cmwuaHJlZikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3Q6IE9ubHkgR0VUIG1ldGhvZCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5hc3luYykge1xuICAgICAgICBmcy5yZWFkRmlsZSh1bmVzY2FwZSh1cmwucGF0aG5hbWUpLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvciwgZXJyb3IuZXJybm8gfHwgLTEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VVUkwgPSBzZXR0aW5ncy51cmw7XG4gICAgICAgICAgICAvLyBVc2Ugc2VsZi5yZXNwb25zZVR5cGUgdG8gY3JlYXRlIHRoZSBjb3JyZWN0IHNlbGYucmVzcG9uc2VUeXBlLCBzZWxmLnJlc3BvbnNlLlxuICAgICAgICAgICAgc2VsZi5jcmVhdGVGaWxlT3JTeW5jUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjAwO1xuICAgICAgICAgIGNvbnN0IHN5bmNEYXRhID0gZnMucmVhZEZpbGVTeW5jKHVuZXNjYXBlKHVybC5wYXRobmFtZSkpO1xuICAgICAgICAgIC8vIFVzZSBzZWxmLnJlc3BvbnNlVHlwZSB0byBjcmVhdGUgdGhlIGNvcnJlY3Qgc2VsZi5yZXNwb25zZVR5cGUsIHNlbGYucmVzcG9uc2UuXG4gICAgICAgICAgdGhpcy5yZXNwb25zZVVSTCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUZpbGVPclN5bmNSZXNwb25zZShzeW5jRGF0YSk7XG4gICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlLCBlLmVycm5vIHx8IC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBwb3J0IDgwLiBJZiBhY2Nlc3NpbmcgbG9jYWxob3N0IG9uIGFub3RoZXIgcG9ydCBiZSBzdXJlXG4gICAgLy8gdG8gdXNlIGh0dHA6Ly9sb2NhbGhvc3Q6cG9ydC9wYXRoXG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydCB8fCAoaXNTc2wgPyA0NDMgOiA4MCk7XG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgdXNlZFxuICAgIHZhciB1cmkgPSB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCB8fCAnJyk7XG5cbiAgICAvLyBTZXQgdGhlIEhvc3QgaGVhZGVyIG9yIHRoZSBzZXJ2ZXIgbWF5IHJlamVjdCB0aGUgcmVxdWVzdFxuICAgIGhlYWRlcnNbXCJIb3N0XCJdID0gaG9zdDtcbiAgICBpZiAoISgoaXNTc2wgJiYgcG9ydCA9PT0gNDQzKSB8fCBwb3J0ID09PSA4MCkpIHtcbiAgICAgIGhlYWRlcnNbXCJIb3N0XCJdICs9ICc6JyArIHVybC5wb3J0O1xuICAgIH1cblxuICAgIC8vIFNldCBCYXNpYyBBdXRoIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChzZXR0aW5ncy51c2VyKSB7XG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnBhc3N3b3JkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldHRpbmdzLnBhc3N3b3JkID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRoQnVmID0gQnVmZmVyLmZyb20oc2V0dGluZ3MudXNlciArIFwiOlwiICsgc2V0dGluZ3MucGFzc3dvcmQpO1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiICsgYXV0aEJ1Zi50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29udGVudCBsZW5ndGggaGVhZGVyXG4gICAgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBzZXR0aW5ncy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIHZhciBoZWFkZXJzS2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgaWYgKCFoZWFkZXJzS2V5cy5zb21lKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnIH0pKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgLy8gRm9yIGEgcG9zdCB3aXRoIG5vIGRhdGEgc2V0IENvbnRlbnQtTGVuZ3RoOiAwLlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSBidWdneSBzZXJ2ZXJzIHRoYXQgZG9uJ3QgbWVldCB0aGUgc3BlY3MuXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogaG9zdCxcbiAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICBwYXRoOiB1cmksXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogb3B0cy5hZ2VudCB8fCBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBSZXNldCBlcnJvciBmbGFnXG4gICAgZXJyb3JGbGFnID0gZmFsc2U7XG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAvLyBVc2UgdGhlIHByb3BlciBwcm90b2NvbFxuICAgICAgdmFyIGRvUmVxdWVzdCA9IGlzU3NsID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcblxuICAgICAgLy8gUmVxdWVzdCBpcyBiZWluZyBzZW50LCBzZXQgc2VuZCBmbGFnXG4gICAgICBzZW5kRmxhZyA9IHRydWU7XG5cbiAgICAgIC8vIEFzIHBlciBzcGVjLCB0aGlzIGlzIGNhbGxlZCBoZXJlIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJyZWFkeXN0YXRlY2hhbmdlXCIpO1xuXG4gICAgICAvLyBIYW5kbGVyIGZvciB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVzcC5zdGF0dXNDb2RlID09PSAzMDEgfHxcbiAgICAgICAgICByZXNwLnN0YXR1c0NvZGUgPT09IDMwMiB8fFxuICAgICAgICAgIHJlc3Auc3RhdHVzQ29kZSA9PT0gMzAzIHx8XG4gICAgICAgICAgcmVzcC5zdGF0dXNDb2RlID09PSAzMDcgfHxcbiAgICAgICAgICByZXNwLnN0YXR1c0NvZGUgPT09IDMwOFxuICAgICAgICApIHtcbiAgICAgICAgICArK3JlZGlyZWN0Q291bnQ7XG4gICAgICAgICAgLy8gZW5kIHRoZSByZXNwb25zZVxuICAgICAgICAgIHJlc3AuZGVzdHJveSgpO1xuICAgICAgICAgIGlmIChyZWRpcmVjdENvdW50ID4gbWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKG5ldyBFcnJvcihcIlRvbyBtYW55IHJlZGlyZWN0c1wiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENoYW5nZSBVUkwgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uXG4gICAgICAgICAgdmFyIHVybDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsID0gbmV3IFVSTChyZXNwLmhlYWRlcnMubG9jYXRpb24sIHNldHRpbmdzLnVybCk7XG4gICAgICAgICAgICAvLyByZWplY3QgcmVkaXJlY3RzIHRvIGFueSBwcm90b2NvbHMgb3RoZXIgdGhhbiBodHRwIGFuZCBodHRwc1xuICAgICAgICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gXCJodHRwczpcIiAmJiB1cmwucHJvdG9jb2wgIT09IFwiaHR0cDpcIikgdGhyb3cgXCJiYWQgcHJvdG9jb2xcIjtcbiAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IHVybC5ocmVmO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihuZXcgRXJyb3IoXCJVbnNhZmUgcmVkaXJlY3RcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGFuZ2UgcmVxdWVzdCBvcHRpb25zIGFnYWluIHRvIG1hdGNoIHdpdGggbmV3IHJlZGlyZWN0IHByb3RvY29sXG4gICAgICAgICAgaXNTc2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgICAgICAgZG9SZXF1ZXN0ID0gaXNTc2wgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xuXG4gICAgICAgICAgLy8gU2V0IGhvc3QgYW5kIHBvcnQgdmFyIGluIGNhc2UgaXQncyB1c2VkIGxhdGVyXG4gICAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgICBwb3J0ID0gdXJsLnBvcnQgfHwgKGlzU3NsID8gNDQzIDogODApO1xuXG4gICAgICAgICAgaGVhZGVyc1tcIkhvc3RcIl0gPSBob3N0O1xuICAgICAgICAgIGlmICghKChpc1NzbCAmJiBwb3J0ID09PSA0NDMpIHx8IHBvcnQgPT09IDgwKSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIkhvc3RcIl0gKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3B0aW9ucyBmb3IgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogcG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHVybC5wYXRobmFtZSArICh1cmwuc2VhcmNoIHx8ICcnKSxcbiAgICAgICAgICAgIG1ldGhvZDogcmVzcC5zdGF0dXNDb2RlID09PSAzMDMgPyAnR0VUJyA6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgY3JlYXRlUmVxdWVzdChuZXdPcHRpb25zKTtcbiAgICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiBhbiBYSFIgZXZlbnQgbmVlZHMgdG8gYmUgZmlyZWQgaGVyZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXG4gICAgICAgIC8vIFRoaXMgaXMgc28gaXQgcmVtYWlucyBhY2Nlc3NhYmxlIG91dHNpZGUgdGhpcyBzY29wZVxuICAgICAgICByZXNwb25zZSA9IHJlc3A7XG4gICAgICAgIC8vIENvbGxlY3QgYnVmZmVycyBhbmQgY29uY2F0ZW5hdGUgb25jZS5cbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuXG4gICAgICAgIHNldFN0YXRlKHNlbGYuSEVBREVSU19SRUNFSVZFRCk7XG5cbiAgICAgICAgLy8gV2hlbiByZXNwb25zZVR5cGUgaXMgJ3RleHQnIG9yICcnLCBzZWxmLnJlc3BvbnNlVGV4dCB3aWxsIGJlIHV0ZjggZGVjb2RlZCB0ZXh0LlxuICAgICAgICAvLyBXaGVuIHJlc3BvbnNlVHlwZSBpcyAnanNvbicsIHNlbGYucmVzcG9uc2VUZXh0IGluaXRpYWxseSB3aWxsIGJlIHV0ZjggZGVjb2RlZCB0ZXh0LFxuICAgICAgICAvLyB3aGljaCBpcyB0aGVuIEpTT04gcGFyc2VkIGludG8gc2VsZi5yZXNwb25zZS5cbiAgICAgICAgLy8gV2hlbiByZXNwb25zZVR5cGUgaXMgJ2FycmF5YnVmZmVyJywgc2VsZi5yZXNwb25zZSBpcyBhbiBBcnJheUJ1ZmZlci5cbiAgICAgICAgLy8gV2hlbiByZXNwb25zZVR5cGUgaXMgJ2Jsb2InLCBzZWxmLnJlc3BvbnNlIGlzIGEgQmxvYi5cbiAgICAgICAgLy8gY2YuIHNlY3Rpb24gMy42LCBzdWJzZWN0aW9ucyA4LDksMTAsMTEgb2YgaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyN0aGUtcmVzcG9uc2UtYXR0cmlidXRlXG4gICAgICAgIGNvbnN0IGlzVXRmOCA9IHNlbGYucmVzcG9uc2VUeXBlID09PSBcIlwiIHx8IHNlbGYucmVzcG9uc2VUeXBlID09PSBcInRleHRcIiB8fCBzZWxmLnJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCI7XG4gICAgICAgIGlmIChpc1V0ZjggJiYgcmVzcG9uc2Uuc2V0RW5jb2RpbmcpIHtcbiAgICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSdzIHNvbWUgZGF0YVxuICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgaWYgKGlzVXRmOCkge1xuICAgICAgICAgICAgICAvLyBXaGVuIHJlc3BvbnNlVHlwZSBpcyAndGV4dCcsICcnLCAnanNvbicsXG4gICAgICAgICAgICAgIC8vICAgdGhlbiBlYWNoIGNodW5rIGlzIGFscmVhZHkgdXRmOCBkZWNvZGVkLlxuICAgICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjb2xsZWN0IHRoZSBjaHVuayBidWZmZXJzLlxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb24ndCBlbWl0IHN0YXRlIGNoYW5nZXMgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuTE9BRElORyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQocmVzcG9uc2UpKTtcblxuICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2VuZEZsYWcgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBzZXRTdGF0ZSBpcyBjYWxsZWQuICBPdGhlcndpc2UgaWYgd2UgYXJlIGNoYWluaW5nIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gdGhlcmUgY2FuIGJlIGEgdGltaW5nIGlzc3VlICh0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGFuZCBhIG5ldyBjYWxsIGlzIG1hZGUgYmVmb3JlIHRoZSBmbGFnIGlzIHJlc2V0KS5cbiAgICAgICAgICAgIHNlbmRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNvcnJlY3QgcmVzcG9uc2UgZm9yIHJlc3BvbnNlVHlwZS5cbiAgICAgICAgICAgIHNlbGYuY3JlYXRlUmVzcG9uc2UoYnVmZmVycyk7XG4gICAgICAgICAgICBzZWxmLnN0YXR1c1RleHQgPSB0aGlzLnN0YXR1c01lc3NhZ2U7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVVJMID0gc2V0dGluZ3MudXJsO1xuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZChyZXNwb25zZSkpO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH0uYmluZChyZXNwb25zZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBoYW5kbGVyIGZvciB0aGUgcmVxdWVzdFxuICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI3JlcXVlc3RyZXVzZWRzb2NrZXQgdHJpZ2dlcmluZyBhbiBFQ09OTlJFU0VULFxuICAgICAgICAvLyBkb24ndCBmYWlsIHRoZSB4aHIgcmVxdWVzdCwgYXR0ZW1wdCBhZ2Fpbi5cbiAgICAgICAgaWYgKHJlcXVlc3QucmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJylcbiAgICAgICAgICByZXR1cm4gZG9SZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICBvcHQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHQpO1xuICAgICAgICBpZiAoaXNTc2wpIE9iamVjdC5hc3NpZ24ob3B0LCBzc2xPcHRpb25zKTtcblxuICAgICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG9wdCwgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXG4gICAgICAgIGlmIChvcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgIHJlcXVlc3Qub24oJ3NvY2tldCcsIGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgICAgIHNvY2tldC51bnJlZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9kZSAwLjQgYW5kIGxhdGVyIHdvbid0IGFjY2VwdCBlbXB0eSBkYXRhLiBNYWtlIHN1cmUgaXQncyBuZWVkZWQuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgcmVxdWVzdC53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgICAgY3JlYXRlUmVxdWVzdChvcHRpb25zKTtcblxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuICAgIH0gZWxzZSB7IC8vIFN5bmNocm9ub3VzXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBvdGhlciBOb2RlIHByb2Nlc3NcbiAgICAgIHZhciBjb250ZW50RmlsZSA9IFwiLm5vZGUteG1saHR0cHJlcXVlc3QtY29udGVudC1cIiArIHByb2Nlc3MucGlkO1xuICAgICAgdmFyIHN5bmNGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1zeW5jLVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHN5bmNGaWxlLCBcIlwiLCBcInV0ZjhcIik7XG4gICAgICAvLyBUaGUgYXN5bmMgcmVxdWVzdCB0aGUgb3RoZXIgTm9kZSBwcm9jZXNzIGV4ZWN1dGVzXG4gICAgICB2YXIgZXhlY1N0cmluZyA9IFwiJ3VzZSBzdHJpY3QnO1wiXG4gICAgICAgICsgXCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKSwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XCJcbiAgICAgICAgKyBcImZ1bmN0aW9uIGNvbmNhdChidWZmZXJBcnJheSkge1wiXG4gICAgICAgICsgXCIgIGxldCBsZW5ndGggPSAwLCBvZmZzZXQgPSAwO1wiXG4gICAgICAgICsgXCIgIGZvciAobGV0IGsgPSAwOyBrIDwgYnVmZmVyQXJyYXkubGVuZ3RoOyBrKyspXCJcbiAgICAgICAgKyBcIiAgICBsZW5ndGggKz0gYnVmZmVyQXJyYXlba10ubGVuZ3RoO1wiXG4gICAgICAgICsgXCIgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1wiXG4gICAgICAgICsgXCIgIGZvciAobGV0IGsgPSAwOyBrIDwgYnVmZmVyQXJyYXkubGVuZ3RoOyBrKyspIHtcIlxuICAgICAgICArIFwiICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyQXJyYXlba10ubGVuZ3RoOyBpKyspIHtcIlxuICAgICAgICArIFwiICAgICAgcmVzdWx0W29mZnNldCtpXSA9IGJ1ZmZlckFycmF5W2tdW2ldXCJcbiAgICAgICAgKyBcIiAgICB9XCJcbiAgICAgICAgKyBcIiAgICBvZmZzZXQgKz0gYnVmZmVyQXJyYXlba10ubGVuZ3RoO1wiXG4gICAgICAgICsgXCIgIH1cIlxuICAgICAgICArIFwiICByZXR1cm4gcmVzdWx0O1wiXG4gICAgICAgICsgXCJ9O1wiXG4gICAgICAgICsgXCJ2YXIgZG9SZXF1ZXN0ID0gaHR0cFwiICsgKGlzU3NsID8gXCJzXCIgOiBcIlwiKSArIFwiLnJlcXVlc3Q7XCJcbiAgICAgICAgKyBcInZhciBpc1NzbCA9IFwiICsgISFpc1NzbCArIFwiO1wiXG4gICAgICAgICsgXCJ2YXIgb3B0aW9ucyA9IFwiICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykgKyBcIjtcIlxuICAgICAgICArIFwidmFyIHNzbE9wdGlvbnMgPSBcIiArIEpTT04uc3RyaW5naWZ5KHNzbE9wdGlvbnMpICsgXCI7XCJcbiAgICAgICAgKyBcInZhciByZXNwb25zZURhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XCJcbiAgICAgICAgKyBcInZhciBidWZmZXJzID0gW107XCJcbiAgICAgICAgKyBcInZhciB1cmwgPSBuZXcgVVJMKFwiICsgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MudXJsKSArIFwiKTtcIlxuICAgICAgICArIFwidmFyIG1heFJlZGlyZWN0cyA9IFwiICsgbWF4UmVkaXJlY3RzICsgXCIsIHJlZGlyZWN0c19jb3VudCA9IDA7XCJcbiAgICAgICAgKyBcInZhciBtYWtlUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcIlxuICAgICAgICArIFwiICB2YXIgb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XCJcbiAgICAgICAgKyBcIiAgaWYgKGlzU3NsKSBPYmplY3QuYXNzaWduKG9wdCwgc3NsT3B0aW9ucyk7XCJcbiAgICAgICAgKyBcIiAgdmFyIHJlcSA9IGRvUmVxdWVzdChvcHQsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XCJcbiAgICAgICAgKyBcIiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA3IHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwOCkge1wiXG4gICAgICAgICsgXCIgICAgICByZXNwb25zZS5kZXN0cm95KCk7XCJcbiAgICAgICAgKyBcIiAgICAgICsrcmVkaXJlY3RzX2NvdW50O1wiXG4gICAgICAgICsgXCIgICAgICBpZiAocmVkaXJlY3RzX2NvdW50ID4gbWF4UmVkaXJlY3RzKSB7XCJcbiAgICAgICAgKyBcIiAgICAgICAgZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgJ05PREUtWE1MSFRUUFJFUVVFU1QtRVJST1ItUkVESVJFQ1Q6IFRvbyBtYW55IHJlZGlyZWN0cycsICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcIiAgICAgICAgZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIiAgICAgICAgcmV0dXJuO1wiXG4gICAgICAgICsgXCIgICAgICB9XCJcbiAgICAgICAgKyBcIiAgICAgIHRyeSB7XCJcbiAgICAgICAgKyBcIiAgICAgICAgdXJsID0gbmV3IFVSTChyZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uLCB1cmwpO1wiXG4gICAgICAgICsgXCIgICAgICAgIGlmICh1cmwucHJvdG9jb2wgIT09ICdodHRwczonICYmIHVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JykgdGhyb3cgJ2JhZCBwcm90b2NvbCc7XCJcbiAgICAgICAgKyBcIiAgICAgIH1cIlxuICAgICAgICArIFwiICAgICAgY2F0Y2ggKGUpIHtcIlxuICAgICAgICArIFwiICAgICAgICBmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCAnTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUi1SRURJUkVDVDogVW5zYWZlIHJlZGlyZWN0JywgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiICAgICAgICBmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwiICAgICAgICByZXR1cm47XCJcbiAgICAgICAgKyBcIiAgICAgIH07XCJcbiAgICAgICAgKyBcIiAgICAgIGlzU3NsID0gdXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcIlxuICAgICAgICArIFwiICAgICAgZG9SZXF1ZXN0ID0gaXNTc2wgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1wiXG4gICAgICAgICsgXCIgICAgICB2YXIgcG9ydCA9IHVybC5wb3J0O1wiXG4gICAgICAgICsgXCIgICAgICBvcHRpb25zID0ge1wiXG4gICAgICAgICsgXCIgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXCJcbiAgICAgICAgKyBcIiAgICAgICAgcG9ydDogcG9ydCxcIlxuICAgICAgICArIFwiICAgICAgICBwYXRoOiB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCB8fCAnJyksXCJcbiAgICAgICAgKyBcIiAgICAgICAgbWV0aG9kOiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgPyAnR0VUJyA6IG9wdGlvbnMubWV0aG9kLFwiXG4gICAgICAgICsgXCIgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVyc1wiXG4gICAgICAgICsgXCIgICAgICB9O1wiXG4gICAgICAgICsgXCIgICAgICBvcHRpb25zLmhlYWRlcnNbJ0hvc3QnXSA9IHVybC5ob3N0O1wiXG4gICAgICAgICsgXCIgICAgICBpZiAoISgoaXNTc2wgJiYgcG9ydCA9PT0gNDQzKSB8fCBwb3J0ID09PSA4MCkpIG9wdGlvbnMuaGVhZGVyc1snSG9zdCddICs9ICc6JyArIHBvcnQ7XCJcbiAgICAgICAgKyBcIiAgICAgIG1ha2VSZXF1ZXN0KCk7XCJcbiAgICAgICAgKyBcIiAgICAgIHJldHVybjtcIlxuICAgICAgICArIFwiICAgIH1cIlxuICAgICAgICArIFwiICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcIlxuICAgICAgICArIFwiICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcIlxuICAgICAgICArIFwiICAgIH0pO1wiXG4gICAgICAgICsgXCIgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1wiXG4gICAgICAgICsgXCIgICAgICByZXNwb25zZURhdGEgPSBjb25jYXQoYnVmZmVycyk7XCJcbiAgICAgICAgKyBcIiAgICAgIGZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsIEpTT04uc3RyaW5naWZ5KHtlcnI6IG51bGwsIGRhdGE6IHt1cmw6IHVybC5ocmVmLCBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNNZXNzYWdlLCBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLCBkYXRhOiByZXNwb25zZURhdGEudG9TdHJpbmcoJ3V0ZjgnKX19KSwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiICAgICAgZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIiAgICB9KTtcIlxuICAgICAgICArIFwiICAgIHJlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcIiAgICAgIGZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcIiAgICAgIGZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCIgICAgfSk7XCJcbiAgICAgICAgKyBcIiAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxuICAgICAgICArIFwiICAgIGZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcIiAgICBmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwiICB9KTtcIlxuICAgICAgICArIFwiICBcIiArIChkYXRhID8gXCJyZXEud3JpdGUoJ1wiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkuc2xpY2UoMSwtMSkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpICsgXCInKTtcIjpcIlwiKVxuICAgICAgICArIFwiICByZXEuZW5kKCk7XCJcbiAgICAgICAgKyBcIn07XCJcbiAgICAgICAgKyBcIm1ha2VSZXF1ZXN0KCk7XCJcbiAgICAgIC8vIFN0YXJ0IHRoZSBvdGhlciBOb2RlIFByb2Nlc3MsIGV4ZWN1dGluZyB0aGlzIHN0cmluZ1xuICAgICAgdmFyIHN5bmNQcm9jID0gc3Bhd24ocHJvY2Vzcy5hcmd2WzBdLCBbXCItZVwiLCBleGVjU3RyaW5nXSk7XG4gICAgICB3aGlsZShmcy5leGlzdHNTeW5jKHN5bmNGaWxlKSkge1xuICAgICAgICAvLyBXYWl0IHdoaWxlIHRoZSBzeW5jIGZpbGUgaXMgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKGNvbnRlbnRGaWxlLCAndXRmOCcpO1xuICAgICAgLy8gS2lsbCB0aGUgY2hpbGQgcHJvY2VzcyBvbmNlIHRoZSBmaWxlIGhhcyBkYXRhXG4gICAgICBzeW5jUHJvYy5zdGRpbi5lbmQoKTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIGZzLnVubGlua1N5bmMoY29udGVudEZpbGUpO1xuICAgICAgaWYgKHNlbGYucmVzcG9uc2VUZXh0Lm1hdGNoKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUigtUkVESVJFQ1QpezAsMX06LykpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgcmV0dXJuZWQgYW4gZXJyb3IsIGhhbmRsZSBpdFxuICAgICAgICBpZiAoc2VsZi5yZXNwb25zZVRleHQuc3RhcnRzV2l0aCgnTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUi1SRURJUkVDVCcpKSB7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihuZXcgRXJyb3Ioc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtRVJST1ItUkVESVJFQ1Q6IC8sIFwiXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGVycm9yT2JqID0gSlNPTi5wYXJzZShzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovLCBcIlwiKSk7XG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvck9iaiwgNTAzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgcmV0dXJuZWQgb2theSwgcGFyc2UgaXRzIGRhdGEgYW5kIG1vdmUgdG8gdGhlIERPTkUgc3RhdGVcbiAgICAgICAgY29uc3QgcmVzcCA9IEpTT04ucGFyc2Uoc2VsZi5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3AuZGF0YS5zdGF0dXNDb2RlO1xuICAgICAgICBzZWxmLnN0YXR1c1RleHQgPSByZXNwLmRhdGEuc3RhdHVzVGV4dDtcbiAgICAgICAgc2VsZi5yZXNwb25zZVVSTCA9IHJlc3AuZGF0YS51cmw7XG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSBzdHJpbmdUb0J1ZmZlcihyZXNwLmRhdGEuZGF0YSk7XG4gICAgICAgIC8vIFVzZSBzZWxmLnJlc3BvbnNlVHlwZSB0byBjcmVhdGUgdGhlIGNvcnJlY3Qgc2VsZi5yZXNwb25zZVR5cGUsIHNlbGYucmVzcG9uc2UsIHNlbGYucmVzcG9uc2VYTUwuXG4gICAgICAgIHNlbGYuY3JlYXRlRmlsZU9yU3luY1Jlc3BvbnNlKHNlbGYucmVzcG9uc2UpO1xuICAgICAgICAvLyBTZXQgdXAgcmVzcG9uc2UgY29ycmVjdGx5LlxuICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICBzdGF0dXNDb2RlOiBzZWxmLnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiByZXNwLmRhdGEuaGVhZGVyc1xuICAgICAgICB9O1xuICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgdG8gZGVhbCB3aXRoIGl0LlxuICAgKiBAcGFyYW0gIHN0YXR1cyAge251bWJlcn0gICAgSFRUUCBzdGF0dXMgY29kZSB0byB1c2UgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgKDApIGZvciBYSFIgZXJyb3JzLlxuICAgKi9cbiAgdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cyB8fCAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGVycm9yLm1lc3NhZ2UgfHwgXCJcIjtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZVVSTCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuICAgIHNldFN0YXRlKHRoaXMuRE9ORSk7XG4gICAgaWYgKCFzZXR0aW5ncy5hc3luYykgdGhyb3cgZXJyb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QuXG4gICAqL1xuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGVhZGVycyk7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xuICAgIHRoaXMucmVzcG9uc2VYTUwgPSBcIlwiO1xuICAgIHRoaXMucmVzcG9uc2UgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICBlcnJvckZsYWcgPSBhYm9ydGVkRmxhZyA9IHRydWVcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLlVOU0VOVFxuICAgICAgICAmJiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCB8fCBzZW5kRmxhZylcbiAgICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLkRPTkUpIHtcbiAgICAgIHNlbmRGbGFnID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSB0aGlzLlVOU0VOVDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci4gUHJlZmVycmVkIG1ldGhvZCBvZiBiaW5kaW5nIHRvIGV2ZW50cy5cbiAgICovXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGV2ZW50IGluIGxpc3RlbmVycykpIHtcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgLy8gQ3VycmVudGx5IGFsbG93cyBkdXBsaWNhdGUgY2FsbGJhY2tzLiBTaG91bGQgaXQ/XG4gICAgbGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGNhbGxiYWNrIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cbiAgICogT25seSB3b3JrcyBvbiB0aGUgbWF0Y2hpbmcgZnVuY2l0b24sIGNhbm5vdCBiZSBhIGNvcHkuXG4gICAqL1xuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAvLyBGaWx0ZXIgd2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCB0aGUgY2FsbGJhY2sgcmVtb3ZlZFxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyc1tldmVudF0uZmlsdGVyKGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHJldHVybiBldiAhPT0gY2FsbGJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGFueSBldmVudHMsIGluY2x1ZGluZyBib3RoIFwib25cIiBtZXRob2RzIGFuZCBldmVudHMgYXR0YWNoZWQgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cbiAgICovXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGxldCBhcmd1bWVudCA9IHsgdHlwZTogZXZlbnQgfTtcbiAgICBpZiAodHlwZW9mIHNlbGZbXCJvblwiICsgZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSAmJiBzZXR0aW5ncy5hc3luYylcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZltcIm9uXCIgKyBldmVudF0oYXJndW1lbnQpIH0sIDApXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGZbXCJvblwiICsgZXZlbnRdKGFyZ3VtZW50KVxuICAgIH1cbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgbGlzdGVuZXJzW2V2ZW50XVtpXS5jYWxsKHNlbGYsIGFyZ3VtZW50KSB9LCAwKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XVtpXS5jYWxsKHNlbGYsIGFyZ3VtZW50KVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBjb3JyZWN0IGZvcm0gb2YgcmVzcG9uc2UsIGdpdmVuIHJlc3BvbnNlVHlwZSB3aGVuIGluIG5vbi1maWxlIGJhc2VkLCBhc3luY2hyb25vdXMgbW9kZS5cbiAgICpcbiAgICogV2hlbiBzZWxmLnJlc3BvbnNlVHlwZSBpcyBcIlwiLCBcInRleHRcIiwgXCJqc29uXCIsIHNlbGYucmVzcG9uc2VUZXh0IGlzIGEgdXRmOCBzdHJpbmcuXG4gICAqIFdoZW4gc2VsZi5yZXNwb25zZVR5cGUgaXMgXCJhcnJheWJ1ZmZlclwiLCBcImJsb2JcIiwgdGhlIHJlc3BvbnNlIGlzIGluIHRoZSBidWZmZXJzIHBhcmFtZXRlcixcbiAgICogYW4gQXJyYXkgb2YgQnVmZmVycy4gVGhlbiBjb25jYXQoYnVmZmVycykgaXMgVWludDhBcnJheSwgZnJvbSB3aGljaCBjaGVja0FuZFNocmlua0J1ZmZlclxuICAgKiBleHRyYWN0cyB0aGUgY29ycmVjdCBzaXplZCBBcnJheUJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBidWZmZXJzXG4gICAqL1xuICB0aGlzLmNyZWF0ZVJlc3BvbnNlID0gZnVuY3Rpb24oYnVmZmVycykge1xuICAgIHNlbGYucmVzcG9uc2VYTUwgPSAnJztcbiAgICBzd2l0Y2ggKHNlbGYucmVzcG9uc2VUeXBlKSB7XG4gICAgICBjYXNlIFwiXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBzZWxmLnJlc3BvbnNlID0gc2VsZi5yZXNwb25zZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSBKU09OLnBhcnNlKHNlbGYucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9ICcnO1xuICAgICAgICBjb25zdCB0b3RhbFJlc3BvbnNlID0gY29uY2F0KGJ1ZmZlcnMpO1xuICAgICAgICAvLyBXaGVuIHNlbGYucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInLCBzZWxmLnJlc3BvbnNlIGlzIGFuIEFycmF5QnVmZmVyLlxuICAgICAgICAvLyBHZXQgdGhlIGNvcnJlY3Qgc2l6ZWQgQXJyYXlCdWZmZXIuXG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSBjaGVja0FuZFNocmlua0J1ZmZlcih0b3RhbFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHNlbGYucmVzcG9uc2VUeXBlID09PSAnYmxvYicgJiYgdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIEJsb2Igb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzcG9uc2UuXG4gICAgICAgICAgc2VsZi5yZXNwb25zZSA9IG5ldyBCbG9iKFtzZWxmLnJlc3BvbnNlXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgY29ycmVjdCBmb3JtIG9mIHJlc3BvbnNlLCBnaXZlbiByZXNwb25zZVR5cGUgd2hlbiBpbiBzeW5jaHJvbm91cyBtb2RlIG9yIGZpbGUgYmFzZWQuXG4gICAqXG4gICAqIFRoZSBpbnB1dCBpcyB0aGUgcmVzcG9uc2UgcGFyYW1ldGVyIHdoaWNoIGlzIGEgQnVmZmVyLlxuICAgKiBXaGVuIHNlbGYucmVzcG9uc2VUeXBlIGlzIFwiXCIsIFwidGV4dFwiLCBcImpzb25cIixcbiAgICogICB0aGUgaW5wdXQgaXMgZnVydGhlciByZWZpbmVkIHRvIGJlOiByZXNwb25zZS50b1N0cmluZygndXRmOCcpLlxuICAgKiBXaGVuIHNlbGYucmVzcG9uc2VUeXBlIGlzIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsXG4gICAqICAgdGhlIGlucHV0IGlzIGZ1cnRoZXIgcmVmaW5lZCB0byBiZTogY2hlY2tBbmRTaHJpbmtCdWZmZXIocmVzcG9uc2UpLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcmVzcG9uc2VcbiAgICovXG4gIHRoaXMuY3JlYXRlRmlsZU9yU3luY1Jlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICBzZWxmLnJlc3BvbnNlVGV4dCA9ICcnO1xuICAgIHNlbGYucmVzcG9uc2VYTUwgPSAnJztcbiAgICBzd2l0Y2ggKHNlbGYucmVzcG9uc2VUeXBlKSB7XG4gICAgICBjYXNlIFwiXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHJlc3BvbnNlLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSBzZWxmLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgc2VsZi5yZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2UudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gV2hlbiBzZWxmLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJywgc2VsZi5yZXNwb25zZSBpcyBhbiBBcnJheUJ1ZmZlci5cbiAgICAgICAgLy8gR2V0IHRoZSBjb3JyZWN0IHNpemVkIEFycmF5QnVmZmVyLlxuICAgICAgICBzZWxmLnJlc3BvbnNlID0gY2hlY2tBbmRTaHJpbmtCdWZmZXIocmVzcG9uc2UpO1xuICAgICAgICBpZiAoc2VsZi5yZXNwb25zZVR5cGUgPT09ICdibG9iJyAmJiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgQmxvYiBvYmplY3QgdGhhdCBjb250YWlucyByZXNwb25zZS5cbiAgICAgICAgICBzZWxmLnJlc3BvbnNlID0gbmV3IEJsb2IoW3NlbGYucmVzcG9uc2VdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgc3RhdGUgTmV3IHN0YXRlXG4gICAqL1xuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICgoc2VsZi5yZWFkeVN0YXRlID09PSBzdGF0ZSkgfHwgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5VTlNFTlQgJiYgYWJvcnRlZEZsYWcpKVxuICAgICAgcmV0dXJuXG5cbiAgICBzZWxmLnJlYWR5U3RhdGUgPSBzdGF0ZTtcblxuICAgIGlmIChzZXR0aW5ncy5hc3luYyB8fCBzZWxmLnJlYWR5U3RhdGUgPCBzZWxmLk9QRU5FRCB8fCBzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuRE9ORSkge1xuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5yZWFkeVN0YXRlID09PSBzZWxmLkRPTkUpIHtcbiAgICAgIGxldCBmaXJlXG5cbiAgICAgIGlmIChhYm9ydGVkRmxhZylcbiAgICAgICAgZmlyZSA9IFwiYWJvcnRcIlxuICAgICAgZWxzZSBpZiAoZXJyb3JGbGFnKVxuICAgICAgICBmaXJlID0gXCJlcnJvclwiXG4gICAgICBlbHNlXG4gICAgICAgIGZpcmUgPSBcImxvYWRcIlxuXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZmlyZSlcblxuICAgICAgLy8gQFRPRE8gZmlndXJlIG91dCBJbnNwZWN0b3JJbnN0cnVtZW50YXRpb246OmRpZExvYWRYSFIoY29va2llKVxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZGVuZFwiKTtcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/xmlhttprequest-ssl@3.1.0/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\n");

/***/ })

};
;