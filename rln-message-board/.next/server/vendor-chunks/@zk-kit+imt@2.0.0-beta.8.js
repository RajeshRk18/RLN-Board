"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zk-kit+imt@2.0.0-beta.8";
exports.ids = ["vendor-chunks/@zk-kit+imt@2.0.0-beta.8"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zk-kit+imt@2.0.0-beta.8/node_modules/@zk-kit/imt/dist/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zk-kit+imt@2.0.0-beta.8/node_modules/@zk-kit/imt/dist/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IMT: () => (/* binding */ IMT)\n/* harmony export */ });\n/* harmony import */ var _zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zk-kit/utils/error-handlers */ \"(ssr)/./node_modules/.pnpm/@zk-kit+utils@1.3.0/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\");\n/**\n * @module @zk-kit/imt\n * @version 2.0.0-beta.8\n * @file Incremental Merkle tree implementation in TypeScript.\n * @copyright Ethereum Foundation 2025\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/imt}\n*/\n\n\n/**\n * An {@link IMT} (aka Incremental Merkle Tree) is a type of data structure used in cryptography and\n * computer science for efficiently verifying the integrity of a large set of data,\n * especially in situations where new data is added over time. It is based on the concept\n * of a Merkle tree, and its key feature is its ability to efficiently update the tree\n * when new data is added or existing data is modified.\n * In this implementation, the tree is constructed using a fixed {@link IMT#depth}\n * value, and a list of {@link IMT#zeroes} (one for each level) is used to compute the\n * hash of a node when not all of its children are defined. The number of children for each\n * node can also be specified with the {@link IMT#arity} parameter.\n */\nclass IMT {\n    /**\n     * It initializes the tree with an hash function, the depth, the zero value to use for zeroes\n     * and the arity (i.e. the number of children for each node). It also takes an optional parameter\n     * to initialize the tree with a list of leaves.\n     * @param hash The hash function used to create nodes.\n     * @param depth The tree depth.\n     * @param zeroValue The zero value used to create zeroes.\n     * @param arity The number of children for each node.\n     * @param leaves The list of initial leaves.\n     */\n    constructor(hash, depth, zeroValue, arity = 2, leaves = []) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(depth, \"depth\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(zeroValue, \"zeroValue\", [\"number\", \"string\", \"bigint\"]);\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(arity, \"arity\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireObject)(leaves, \"leaves\");\n        if (leaves.length > arity ** depth) {\n            throw new Error(`The tree cannot contain more than ${arity ** depth} leaves`);\n        }\n        // Initialize the attributes.\n        this._hash = hash;\n        this._depth = depth;\n        this._zeroes = [];\n        this._nodes = [];\n        this._arity = arity;\n        for (let level = 0; level < depth; level += 1) {\n            this._zeroes.push(zeroValue);\n            this._nodes[level] = [];\n            // There must be a zero value for each tree level (except the root).\n            zeroValue = hash(Array(this._arity).fill(zeroValue));\n        }\n        this._nodes[depth] = [];\n        // It initializes the tree with a list of leaves if there are any.\n        if (leaves.length > 0) {\n            this._nodes[0] = leaves;\n            for (let level = 0; level < depth; level += 1) {\n                for (let index = 0; index < Math.ceil(this._nodes[level].length / arity); index += 1) {\n                    const position = index * arity;\n                    const children = [];\n                    for (let i = 0; i < arity; i += 1) {\n                        children.push(this._nodes[level][position + i] ?? this.zeroes[level]);\n                    }\n                    this._nodes[level + 1][index] = hash(children);\n                }\n            }\n        }\n        else {\n            // If there are no leaves, the default root is the last zero value.\n            this._nodes[depth][0] = zeroValue;\n        }\n        // Freeze the array objects. It prevents unintentional changes.\n        Object.freeze(this._zeroes);\n        Object.freeze(this._nodes);\n    }\n    /**\n     * The root of the tree. This value doesn't need to be stored as\n     * it is always the first and unique element of the last level of the tree.\n     * Its value can be retrieved in {@link IMT#_nodes}.\n     * @returns The root hash of the tree.\n     */\n    get root() {\n        return this._nodes[this.depth][0];\n    }\n    /**\n     * The depth of the tree, which equals the number of levels - 1.\n     * @returns The depth of the tree.\n     */\n    get depth() {\n        return this._depth;\n    }\n    /**\n     * The leaves of the tree. They can be retrieved from the first\n     * level of the tree using {@link IMT#_nodes}. The returned\n     * value is a copy of the array and not the original object.\n     * @returns The list of tree leaves.\n     */\n    get leaves() {\n        return this._nodes[0].slice();\n    }\n    /**\n     * The list of zero values calculated during the initialization of the tree.\n     * @returns The list of pre-computed zeroes.\n     */\n    get zeroes() {\n        return this._zeroes;\n    }\n    /**\n     * The number of children per node.\n     * @returns The number of children per node.\n     */\n    get arity() {\n        return this._arity;\n    }\n    /**\n     * It returns the index of the first occurrence of a leaf in the tree.\n     * If the leaf does not exist it returns -1.\n     * @param leaf A leaf of the tree.\n     * @returns The index of the leaf.\n     */\n    indexOf(leaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(leaf, \"leaf\", [\"number\", \"string\", \"bigint\"]);\n        return this._nodes[0].indexOf(leaf);\n    }\n    /**\n     * The leaves are inserted incrementally. If 'i' is the index of the last\n     * leaf, the new one will be inserted at position 'i + 1'. Every time a\n     * new leaf is inserted, the nodes that separate the new leaf from the root\n     * of the tree are created or updated if they already exist, from bottom to top.\n     * When a node has only one child (the left one), its value is the hash of that\n     * node and the zero value of that level. Otherwise, the hash of the children\n     * is calculated.\n     * @param leaf The new leaf to be inserted in the tree.\n     */\n    insert(leaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(leaf, \"leaf\", [\"number\", \"string\", \"bigint\"]);\n        if (this._nodes[0].length >= this.arity ** this.depth) {\n            throw new Error(\"The tree is full\");\n        }\n        let node = leaf;\n        let index = this._nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this._nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this._nodes[level].length) {\n                    children.push(this._nodes[level][i]);\n                }\n                else {\n                    children.push(this._zeroes[level]);\n                }\n            }\n            node = this._hash(children);\n            index = Math.floor(index / this.arity);\n        }\n        this._nodes[this.depth][0] = node;\n    }\n    /**\n     * It deletes a leaf from the tree. It does not remove the leaf from\n     * the data structure, but rather it sets the leaf to be deleted to the zero value.\n     * @param index The index of the leaf to be deleted.\n     */\n    delete(index) {\n        this.update(index, this.zeroes[0]);\n    }\n    /**\n     * It updates a leaf in the tree. It's very similar to the {@link IMT#insert} function.\n     * @param index The index of the leaf to be updated.\n     * @param newLeaf The new leaf to be inserted.\n     */\n    update(index, newLeaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this._nodes[0].length) {\n            throw new Error(\"The leaf does not exist in this tree\");\n        }\n        if (newLeaf === this._nodes[0][index])\n            return;\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this._nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this._nodes[level].length) {\n                    children.push(this._nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this._hash(children);\n            index = Math.floor(index / this.arity);\n        }\n        this._nodes[this.depth][0] = node;\n    }\n    /**\n     * It creates a {@link IMTMerkleProof} for a leaf of the tree.\n     * That proof can be verified by this tree using the same hash function.\n     * @param index The index of the leaf for which a Merkle proof will be generated.\n     * @returns The Merkle proof of the leaf.\n     */\n    createProof(index) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this._nodes[0].length) {\n            throw new Error(\"The leaf does not exist in this tree\");\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i !== index) {\n                    if (i < this._nodes[level].length) {\n                        siblings[level].push(this._nodes[level][i]);\n                    }\n                    else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return { root: this.root, leaf: this._nodes[0][leafIndex], pathIndices, siblings, leafIndex };\n    }\n    /**\n     * It verifies a {@link IMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.  Does not verify that the node belongs to this\n     * tree in particular.  Equivalent to `IMT.verifyProof(proof, this._hash)`.\n     *\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    verifyProof(proof) {\n        return IMT.verifyProof(proof, this._hash);\n    }\n    /**\n     * It verifies a {@link IMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.\n     * @param proof The Merkle tree proof.\n     * @param hash The hash function used to compute the tree nodes.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    static verifyProof(proof, hash) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireObject)(proof, \"proof\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(proof.root, \"proof.root\", [\"number\", \"string\", \"bigint\"]);\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireTypes)(proof.leaf, \"proof.leaf\", [\"number\", \"string\", \"bigint\"]);\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.siblings, \"proof.siblings\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.pathIndices, \"proof.pathIndices\");\n        let node = proof.leaf;\n        for (let i = 0; i < proof.siblings.length; i += 1) {\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = hash(children);\n        }\n        return proof.root === node;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHprLWtpdCtpbXRAMi4wLjAtYmV0YS44L25vZGVfbW9kdWxlcy9Aemsta2l0L2ltdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ3lIOztBQUV6SDtBQUNBLE9BQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkVBQWU7QUFDdkIsUUFBUSwyRUFBYTtBQUNyQixRQUFRLDBFQUFZO0FBQ3BCLFFBQVEsMkVBQWE7QUFDckIsUUFBUSwyRUFBYTtBQUNyQjtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQyxvQ0FBb0Msc0RBQXNEO0FBQzFGO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkVBQWE7QUFDckIsUUFBUSwwRUFBWTtBQUNwQixRQUFRLDBFQUFZO0FBQ3BCLFFBQVEsMEVBQVk7QUFDcEIsUUFBUSwwRUFBWTtBQUNwQjtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXJuYW1lL2FsZW8vcmF0ZS1saW1pdGluZy1udWxsaWZpZXIvcmxuLW1lc3NhZ2UtYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL0B6ay1raXQraW10QDIuMC4wLWJldGEuOC9ub2RlX21vZHVsZXMvQHprLWtpdC9pbXQvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC9pbXRcbiAqIEB2ZXJzaW9uIDIuMC4wLWJldGEuOFxuICogQGZpbGUgSW5jcmVtZW50YWwgTWVya2xlIHRyZWUgaW1wbGVtZW50YXRpb24gaW4gVHlwZVNjcmlwdC5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI1XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy9pbXR9XG4qL1xuaW1wb3J0IHsgcmVxdWlyZUZ1bmN0aW9uLCByZXF1aXJlTnVtYmVyLCByZXF1aXJlVHlwZXMsIHJlcXVpcmVPYmplY3QsIHJlcXVpcmVBcnJheSB9IGZyb20gJ0B6ay1raXQvdXRpbHMvZXJyb3ItaGFuZGxlcnMnO1xuXG4vKipcbiAqIEFuIHtAbGluayBJTVR9IChha2EgSW5jcmVtZW50YWwgTWVya2xlIFRyZWUpIGlzIGEgdHlwZSBvZiBkYXRhIHN0cnVjdHVyZSB1c2VkIGluIGNyeXB0b2dyYXBoeSBhbmRcbiAqIGNvbXB1dGVyIHNjaWVuY2UgZm9yIGVmZmljaWVudGx5IHZlcmlmeWluZyB0aGUgaW50ZWdyaXR5IG9mIGEgbGFyZ2Ugc2V0IG9mIGRhdGEsXG4gKiBlc3BlY2lhbGx5IGluIHNpdHVhdGlvbnMgd2hlcmUgbmV3IGRhdGEgaXMgYWRkZWQgb3ZlciB0aW1lLiBJdCBpcyBiYXNlZCBvbiB0aGUgY29uY2VwdFxuICogb2YgYSBNZXJrbGUgdHJlZSwgYW5kIGl0cyBrZXkgZmVhdHVyZSBpcyBpdHMgYWJpbGl0eSB0byBlZmZpY2llbnRseSB1cGRhdGUgdGhlIHRyZWVcbiAqIHdoZW4gbmV3IGRhdGEgaXMgYWRkZWQgb3IgZXhpc3RpbmcgZGF0YSBpcyBtb2RpZmllZC5cbiAqIEluIHRoaXMgaW1wbGVtZW50YXRpb24sIHRoZSB0cmVlIGlzIGNvbnN0cnVjdGVkIHVzaW5nIGEgZml4ZWQge0BsaW5rIElNVCNkZXB0aH1cbiAqIHZhbHVlLCBhbmQgYSBsaXN0IG9mIHtAbGluayBJTVQjemVyb2VzfSAob25lIGZvciBlYWNoIGxldmVsKSBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBoYXNoIG9mIGEgbm9kZSB3aGVuIG5vdCBhbGwgb2YgaXRzIGNoaWxkcmVuIGFyZSBkZWZpbmVkLiBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciBlYWNoXG4gKiBub2RlIGNhbiBhbHNvIGJlIHNwZWNpZmllZCB3aXRoIHRoZSB7QGxpbmsgSU1UI2FyaXR5fSBwYXJhbWV0ZXIuXG4gKi9cbmNsYXNzIElNVCB7XG4gICAgLyoqXG4gICAgICogSXQgaW5pdGlhbGl6ZXMgdGhlIHRyZWUgd2l0aCBhbiBoYXNoIGZ1bmN0aW9uLCB0aGUgZGVwdGgsIHRoZSB6ZXJvIHZhbHVlIHRvIHVzZSBmb3IgemVyb2VzXG4gICAgICogYW5kIHRoZSBhcml0eSAoaS5lLiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciBlYWNoIG5vZGUpLiBJdCBhbHNvIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlclxuICAgICAqIHRvIGluaXRpYWxpemUgdGhlIHRyZWUgd2l0aCBhIGxpc3Qgb2YgbGVhdmVzLlxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXNoIGZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIG5vZGVzLlxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgdHJlZSBkZXB0aC5cbiAgICAgKiBAcGFyYW0gemVyb1ZhbHVlIFRoZSB6ZXJvIHZhbHVlIHVzZWQgdG8gY3JlYXRlIHplcm9lcy5cbiAgICAgKiBAcGFyYW0gYXJpdHkgVGhlIG51bWJlciBvZiBjaGlsZHJlbiBmb3IgZWFjaCBub2RlLlxuICAgICAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgaW5pdGlhbCBsZWF2ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCwgZGVwdGgsIHplcm9WYWx1ZSwgYXJpdHkgPSAyLCBsZWF2ZXMgPSBbXSkge1xuICAgICAgICByZXF1aXJlRnVuY3Rpb24oaGFzaCwgXCJoYXNoXCIpO1xuICAgICAgICByZXF1aXJlTnVtYmVyKGRlcHRoLCBcImRlcHRoXCIpO1xuICAgICAgICByZXF1aXJlVHlwZXMoemVyb1ZhbHVlLCBcInplcm9WYWx1ZVwiLCBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJiaWdpbnRcIl0pO1xuICAgICAgICByZXF1aXJlTnVtYmVyKGFyaXR5LCBcImFyaXR5XCIpO1xuICAgICAgICByZXF1aXJlT2JqZWN0KGxlYXZlcywgXCJsZWF2ZXNcIik7XG4gICAgICAgIGlmIChsZWF2ZXMubGVuZ3RoID4gYXJpdHkgKiogZGVwdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHRyZWUgY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuICR7YXJpdHkgKiogZGVwdGh9IGxlYXZlc2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGF0dHJpYnV0ZXMuXG4gICAgICAgIHRoaXMuX2hhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLl9kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLl96ZXJvZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXJpdHkgPSBhcml0eTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl96ZXJvZXMucHVzaCh6ZXJvVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWxdID0gW107XG4gICAgICAgICAgICAvLyBUaGVyZSBtdXN0IGJlIGEgemVybyB2YWx1ZSBmb3IgZWFjaCB0cmVlIGxldmVsIChleGNlcHQgdGhlIHJvb3QpLlxuICAgICAgICAgICAgemVyb1ZhbHVlID0gaGFzaChBcnJheSh0aGlzLl9hcml0eSkuZmlsbCh6ZXJvVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlc1tkZXB0aF0gPSBbXTtcbiAgICAgICAgLy8gSXQgaW5pdGlhbGl6ZXMgdGhlIHRyZWUgd2l0aCBhIGxpc3Qgb2YgbGVhdmVzIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIGlmIChsZWF2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbMF0gPSBsZWF2ZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgTWF0aC5jZWlsKHRoaXMuX25vZGVzW2xldmVsXS5sZW5ndGggLyBhcml0eSk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAqIGFyaXR5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyaXR5OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5fbm9kZXNbbGV2ZWxdW3Bvc2l0aW9uICsgaV0gPz8gdGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tsZXZlbCArIDFdW2luZGV4XSA9IGhhc2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBsZWF2ZXMsIHRoZSBkZWZhdWx0IHJvb3QgaXMgdGhlIGxhc3QgemVybyB2YWx1ZS5cbiAgICAgICAgICAgIHRoaXMuX25vZGVzW2RlcHRoXVswXSA9IHplcm9WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcmVlemUgdGhlIGFycmF5IG9iamVjdHMuIEl0IHByZXZlbnRzIHVuaW50ZW50aW9uYWwgY2hhbmdlcy5cbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLl96ZXJvZXMpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMuX25vZGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3Qgb2YgdGhlIHRyZWUuIFRoaXMgdmFsdWUgZG9lc24ndCBuZWVkIHRvIGJlIHN0b3JlZCBhc1xuICAgICAqIGl0IGlzIGFsd2F5cyB0aGUgZmlyc3QgYW5kIHVuaXF1ZSBlbGVtZW50IG9mIHRoZSBsYXN0IGxldmVsIG9mIHRoZSB0cmVlLlxuICAgICAqIEl0cyB2YWx1ZSBjYW4gYmUgcmV0cmlldmVkIGluIHtAbGluayBJTVQjX25vZGVzfS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm9vdCBoYXNoIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXB0aCBvZiB0aGUgdHJlZSwgd2hpY2ggZXF1YWxzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIC0gMS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUuIFRoZXkgY2FuIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGxldmVsIG9mIHRoZSB0cmVlIHVzaW5nIHtAbGluayBJTVQjX25vZGVzfS4gVGhlIHJldHVybmVkXG4gICAgICogdmFsdWUgaXMgYSBjb3B5IG9mIHRoZSBhcnJheSBhbmQgbm90IHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgb2YgdHJlZSBsZWF2ZXMuXG4gICAgICovXG4gICAgZ2V0IGxlYXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdLnNsaWNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHplcm8gdmFsdWVzIGNhbGN1bGF0ZWQgZHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgdHJlZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBwcmUtY29tcHV0ZWQgemVyb2VzLlxuICAgICAqL1xuICAgIGdldCB6ZXJvZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ZXJvZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gcGVyIG5vZGUuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGlsZHJlbiBwZXIgbm9kZS5cbiAgICAgKi9cbiAgICBnZXQgYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcml0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBsZWFmIGluIHRoZSB0cmVlLlxuICAgICAqIElmIHRoZSBsZWFmIGRvZXMgbm90IGV4aXN0IGl0IHJldHVybnMgLTEuXG4gICAgICogQHBhcmFtIGxlYWYgQSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbGVhZi5cbiAgICAgKi9cbiAgICBpbmRleE9mKGxlYWYpIHtcbiAgICAgICAgcmVxdWlyZVR5cGVzKGxlYWYsIFwibGVhZlwiLCBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJiaWdpbnRcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0uaW5kZXhPZihsZWFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxlYXZlcyBhcmUgaW5zZXJ0ZWQgaW5jcmVtZW50YWxseS4gSWYgJ2knIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdFxuICAgICAqIGxlYWYsIHRoZSBuZXcgb25lIHdpbGwgYmUgaW5zZXJ0ZWQgYXQgcG9zaXRpb24gJ2kgKyAxJy4gRXZlcnkgdGltZSBhXG4gICAgICogbmV3IGxlYWYgaXMgaW5zZXJ0ZWQsIHRoZSBub2RlcyB0aGF0IHNlcGFyYXRlIHRoZSBuZXcgbGVhZiBmcm9tIHRoZSByb290XG4gICAgICogb2YgdGhlIHRyZWUgYXJlIGNyZWF0ZWQgb3IgdXBkYXRlZCBpZiB0aGV5IGFscmVhZHkgZXhpc3QsIGZyb20gYm90dG9tIHRvIHRvcC5cbiAgICAgKiBXaGVuIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQgKHRoZSBsZWZ0IG9uZSksIGl0cyB2YWx1ZSBpcyB0aGUgaGFzaCBvZiB0aGF0XG4gICAgICogbm9kZSBhbmQgdGhlIHplcm8gdmFsdWUgb2YgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlLCB0aGUgaGFzaCBvZiB0aGUgY2hpbGRyZW5cbiAgICAgKiBpcyBjYWxjdWxhdGVkLlxuICAgICAqIEBwYXJhbSBsZWFmIFRoZSBuZXcgbGVhZiB0byBiZSBpbnNlcnRlZCBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBpbnNlcnQobGVhZikge1xuICAgICAgICByZXF1aXJlVHlwZXMobGVhZiwgXCJsZWFmXCIsIFtcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcImJpZ2ludFwiXSk7XG4gICAgICAgIGlmICh0aGlzLl9ub2Rlc1swXS5sZW5ndGggPj0gdGhpcy5hcml0eSAqKiB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHJlZSBpcyBmdWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gbGVhZjtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fbm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5fbm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5femVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF0gPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBkZWxldGVzIGEgbGVhZiBmcm9tIHRoZSB0cmVlLiBJdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxlYWYgZnJvbVxuICAgICAqIHRoZSBkYXRhIHN0cnVjdHVyZSwgYnV0IHJhdGhlciBpdCBzZXRzIHRoZSBsZWFmIHRvIGJlIGRlbGV0ZWQgdG8gdGhlIHplcm8gdmFsdWUuXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShpbmRleCkge1xuICAgICAgICB0aGlzLnVwZGF0ZShpbmRleCwgdGhpcy56ZXJvZXNbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB1cGRhdGVzIGEgbGVhZiBpbiB0aGUgdHJlZS4gSXQncyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHtAbGluayBJTVQjaW5zZXJ0fSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBsZWFmIHRvIGJlIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIG5ld0xlYWYgVGhlIG5ldyBsZWFmIHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZShpbmRleCwgbmV3TGVhZikge1xuICAgICAgICByZXF1aXJlTnVtYmVyKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX25vZGVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxlYWYgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMZWFmID09PSB0aGlzLl9ub2Rlc1swXVtpbmRleF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBub2RlID0gbmV3TGVhZjtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsXVtpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5fbm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuX25vZGVzW2xldmVsXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuemVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2goY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF0gPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBjcmVhdGVzIGEge0BsaW5rIElNVE1lcmtsZVByb29mfSBmb3IgYSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIFRoYXQgcHJvb2YgY2FuIGJlIHZlcmlmaWVkIGJ5IHRoaXMgdHJlZSB1c2luZyB0aGUgc2FtZSBoYXNoIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGxlYWYgZm9yIHdoaWNoIGEgTWVya2xlIHByb29mIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcHJvb2Ygb2YgdGhlIGxlYWYuXG4gICAgICovXG4gICAgY3JlYXRlUHJvb2YoaW5kZXgpIHtcbiAgICAgICAgcmVxdWlyZU51bWJlcihpbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9ub2Rlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWFmIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJlZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBwYXRoSW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBsZWFmSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgcGF0aEluZGljZXNbbGV2ZWxdID0gcG9zaXRpb247XG4gICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0ucHVzaCh0aGlzLl9ub2Rlc1tsZXZlbF1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3NbbGV2ZWxdLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHRoaXMucm9vdCwgbGVhZjogdGhpcy5fbm9kZXNbMF1bbGVhZkluZGV4XSwgcGF0aEluZGljZXMsIHNpYmxpbmdzLCBsZWFmSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgdmVyaWZpZXMgYSB7QGxpbmsgSU1UTWVya2xlUHJvb2Z9IHRvIGNvbmZpcm0gdGhhdCBhIGxlYWYgaW5kZWVkXG4gICAgICogYmVsb25ncyB0byBhIHRyZWUuICBEb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgbm9kZSBiZWxvbmdzIHRvIHRoaXNcbiAgICAgKiB0cmVlIGluIHBhcnRpY3VsYXIuICBFcXVpdmFsZW50IHRvIGBJTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9vZiBUaGUgTWVya2xlIHRyZWUgcHJvb2YuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbGVhZiBpcyBwYXJ0IG9mIHRoZSB0cmVlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZlcmlmeVByb29mKHByb29mKSB7XG4gICAgICAgIHJldHVybiBJTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB2ZXJpZmllcyBhIHtAbGluayBJTVRNZXJrbGVQcm9vZn0gdG8gY29uZmlybSB0aGF0IGEgbGVhZiBpbmRlZWRcbiAgICAgKiBiZWxvbmdzIHRvIGEgdHJlZS5cbiAgICAgKiBAcGFyYW0gcHJvb2YgVGhlIE1lcmtsZSB0cmVlIHByb29mLlxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXNoIGZ1bmN0aW9uIHVzZWQgdG8gY29tcHV0ZSB0aGUgdHJlZSBub2Rlcy5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeVByb29mKHByb29mLCBoYXNoKSB7XG4gICAgICAgIHJlcXVpcmVPYmplY3QocHJvb2YsIFwicHJvb2ZcIik7XG4gICAgICAgIHJlcXVpcmVUeXBlcyhwcm9vZi5yb290LCBcInByb29mLnJvb3RcIiwgW1wibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwiYmlnaW50XCJdKTtcbiAgICAgICAgcmVxdWlyZVR5cGVzKHByb29mLmxlYWYsIFwicHJvb2YubGVhZlwiLCBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJiaWdpbnRcIl0pO1xuICAgICAgICByZXF1aXJlQXJyYXkocHJvb2Yuc2libGluZ3MsIFwicHJvb2Yuc2libGluZ3NcIik7XG4gICAgICAgIHJlcXVpcmVBcnJheShwcm9vZi5wYXRoSW5kaWNlcywgXCJwcm9vZi5wYXRoSW5kaWNlc1wiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBwcm9vZi5sZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLnNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb29mLnNpYmxpbmdzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UocHJvb2YucGF0aEluZGljZXNbaV0sIDAsIG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IGhhc2goY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZi5yb290ID09PSBub2RlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgSU1UIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zk-kit+imt@2.0.0-beta.8/node_modules/@zk-kit/imt/dist/index.js\n");

/***/ })

};
;