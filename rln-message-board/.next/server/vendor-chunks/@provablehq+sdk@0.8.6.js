"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@provablehq+sdk@0.8.6";
exports.ids = ["vendor-chunks/@provablehq+sdk@0.8.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/browser.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/browser.js ***!
  \*******************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   Address: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Address),\n/* harmony export */   AleoKeyProvider: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.A),\n/* harmony export */   AleoKeyProviderParams: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   AleoNetworkClient: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.b),\n/* harmony export */   BHP1024: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.BHP1024),\n/* harmony export */   BHP256: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.BHP256),\n/* harmony export */   BHP512: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.BHP512),\n/* harmony export */   BHP768: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.BHP768),\n/* harmony export */   BlockHeightSearch: () => (/* binding */ BlockHeightSearch),\n/* harmony export */   CREDITS_PROGRAM_KEYS: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C),\n/* harmony export */   Ciphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Ciphertext),\n/* harmony export */   ComputeKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ComputeKey),\n/* harmony export */   ExecutionResponse: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ExecutionResponse),\n/* harmony export */   Field: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Field),\n/* harmony export */   FunctionExecution: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Execution),\n/* harmony export */   Group: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Group),\n/* harmony export */   KEY_STORE: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.K),\n/* harmony export */   NetworkRecordProvider: () => (/* binding */ NetworkRecordProvider),\n/* harmony export */   OfflineKeyProvider: () => (/* binding */ OfflineKeyProvider),\n/* harmony export */   OfflineQuery: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.OfflineQuery),\n/* harmony export */   OfflineSearchParams: () => (/* binding */ OfflineSearchParams),\n/* harmony export */   PRIVATE_TO_PUBLIC_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.d),\n/* harmony export */   PRIVATE_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   PRIVATE_TRANSFER_TYPES: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   PUBLIC_TO_PRIVATE_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.h),\n/* harmony export */   PUBLIC_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.f),\n/* harmony export */   PUBLIC_TRANSFER_AS_SIGNER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.g),\n/* harmony export */   Pedersen128: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Pedersen128),\n/* harmony export */   Pedersen64: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Pedersen64),\n/* harmony export */   Plaintext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Plaintext),\n/* harmony export */   Poseidon2: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Poseidon2),\n/* harmony export */   Poseidon4: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Poseidon4),\n/* harmony export */   Poseidon8: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Poseidon8),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey),\n/* harmony export */   PrivateKeyCiphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKeyCiphertext),\n/* harmony export */   Program: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Program),\n/* harmony export */   ProgramManager: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.P),\n/* harmony export */   ProgramManagerBase: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ProgramManager),\n/* harmony export */   ProvingKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ProvingKey),\n/* harmony export */   RecordCiphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.RecordCiphertext),\n/* harmony export */   RecordPlaintext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.RecordPlaintext),\n/* harmony export */   Scalar: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Scalar),\n/* harmony export */   Signature: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Signature),\n/* harmony export */   Transaction: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Transaction),\n/* harmony export */   Transition: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Transition),\n/* harmony export */   VALID_TRANSFER_TYPES: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.V),\n/* harmony export */   VerifyingKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey),\n/* harmony export */   ViewKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ViewKey),\n/* harmony export */   createAleoWorker: () => (/* binding */ createAleoWorker),\n/* harmony export */   initThreadPool: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.initThreadPool),\n/* harmony export */   initializeWasm: () => (/* binding */ initializeWasm),\n/* harmony export */   logAndThrow: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.l),\n/* harmony export */   verifyFunctionExecution: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.verifyFunctionExecution)\n/* harmony export */ });\n/* harmony import */ var core_js_proposals_json_parse_with_source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/proposals/json-parse-with-source.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/proposals/json-parse-with-source.js\");\n/* harmony import */ var _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @provablehq/wasm/testnet.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js\");\n/* harmony import */ var _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./program-manager-CjvnOyfn.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js\");\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! comlink */ \"(ssr)/./node_modules/.pnpm/comlink@4.4.2/node_modules/comlink/dist/esm/comlink.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n/**\n * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from\n * an existing private key or seed, and message signing and verification functionality.\n *\n * An Aleo Account is generated from a randomly generated seed (number) from which an account private key, view key,\n * and a public account address are derived. The private key lies at the root of an Aleo account. It is a highly\n * sensitive secret and should be protected as it allows for creation of Aleo Program executions and arbitrary value\n * transfers. The View Key allows for decryption of a user's activity on the blockchain. The Address is the public\n * address to which other users of Aleo can send Aleo credits and other records to. This class should only be used\n * environments where the safety of the underlying key material can be assured.\n *\n * @example\n * // Create a new account\n * const myRandomAccount = new Account();\n *\n * // Create an account from a randomly generated seed\n * const seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);\n * const mySeededAccount = new Account({seed: seed});\n *\n * // Create an account from an existing private key\n * const myExistingAccount = new Account({privateKey: 'myExistingPrivateKey'})\n *\n * // Sign a message\n * const hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n * const signature = myRandomAccount.sign(hello_world)\n *\n * // Verify a signature\n * myRandomAccount.verify(hello_world, signature)\n */\nclass Account {\n    _privateKey;\n    _viewKey;\n    _computeKey;\n    _address;\n    constructor(params = {}) {\n        try {\n            this._privateKey = this.privateKeyFromParams(params);\n        }\n        catch (e) {\n            console.error(\"Wrong parameter\", e);\n            throw new Error(\"Wrong Parameter\");\n        }\n        this._viewKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ViewKey.from_private_key(this._privateKey);\n        this._computeKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ComputeKey.from_private_key(this._privateKey);\n        this._address = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.Address.from_private_key(this._privateKey);\n    }\n    /**\n     * Attempts to create an account from a private key ciphertext\n     * @param {PrivateKeyCiphertext | string} ciphertext\n     * @param {string} password\n     * @returns {PrivateKey}\n     *\n     * @example\n     * const ciphertext = PrivateKey.newEncrypted(\"password\");\n     * const account = Account.fromCiphertext(ciphertext, \"password\");\n     */\n    static fromCiphertext(ciphertext, password) {\n        try {\n            ciphertext = (typeof ciphertext === \"string\") ? _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;\n            const _privateKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);\n            return new Account({ privateKey: _privateKey.to_string() });\n        }\n        catch (e) {\n            throw new Error(\"Wrong password or invalid ciphertext\");\n        }\n    }\n    privateKeyFromParams(params) {\n        if (params.seed) {\n            return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_seed_unchecked(params.seed);\n        }\n        if (params.privateKey) {\n            return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_string(params.privateKey);\n        }\n        return new _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey();\n    }\n    privateKey() {\n        return this._privateKey;\n    }\n    viewKey() {\n        return this._viewKey;\n    }\n    computeKey() {\n        return this._computeKey;\n    }\n    address() {\n        return this._address;\n    }\n    clone() {\n        return new Account({ privateKey: this._privateKey.to_string() });\n    }\n    toString() {\n        return this.address().to_string();\n    }\n    /**\n     * Encrypt the account's private key with a password\n     * @param {string} ciphertext\n     * @returns {PrivateKeyCiphertext}\n     *\n     * @example\n     * const account = new Account();\n     * const ciphertext = account.encryptAccount(\"password\");\n     */\n    encryptAccount(password) {\n        return this._privateKey.toCiphertext(password);\n    }\n    /**\n     * Decrypts a Record in ciphertext form into plaintext\n     * @param {string} ciphertext\n     * @returns {Record}\n     *\n     * @example\n     * const account = new Account();\n     * const record = account.decryptRecord(\"record1ciphertext\");\n     */\n    decryptRecord(ciphertext) {\n        return this._viewKey.decrypt(ciphertext);\n    }\n    /**\n     * Decrypts an array of Records in ciphertext form into plaintext\n     * @param {string[]} ciphertexts\n     * @returns {Record[]}\n     *\n     * @example\n     * const account = new Account();\n     * const record = account.decryptRecords([\"record1ciphertext\", \"record2ciphertext\"]);\n     */\n    decryptRecords(ciphertexts) {\n        return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));\n    }\n    /**\n     * Determines whether the account owns a ciphertext record\n     * @param {RecordCipherText | string} ciphertext\n     * @returns {boolean}\n     *\n     * @example\n     * // Create a connection to the Aleo network and an account\n     * const connection = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const account = Account.fromCiphertext(\"ciphertext\", \"password\");\n     *\n     * // Get a record from the network\n     * const record = connection.getBlock(1234);\n     * const recordCipherText = record.transactions[0].execution.transitions[0].id;\n     *\n     * // Check if the account owns the record\n     * if account.ownsRecord(recordCipherText) {\n     *     // Then one can do something like:\n     *     // Decrypt the record and check if it's spent\n     *     // Store the record in a local database\n     *     // Etc.\n     * }\n     */\n    ownsRecordCiphertext(ciphertext) {\n        if (typeof ciphertext === 'string') {\n            try {\n                const ciphertextObject = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.RecordCiphertext.fromString(ciphertext);\n                return ciphertextObject.isOwner(this._viewKey);\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return ciphertext.isOwner(this._viewKey);\n        }\n    }\n    /**\n     * Signs a message with the account's private key.\n     * Returns a Signature.\n     *\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     *\n     * @example\n     * const account = new Account();\n     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * account.sign(message);\n     */\n    sign(message) {\n        return this._privateKey.sign(message);\n    }\n    /**\n     * Verifies the Signature on a message.\n     *\n     * @param {Uint8Array} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     *\n     * @example\n     * const account = new Account();\n     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * const signature = account.sign(message);\n     * account.verify(message, signature);\n     */\n    verify(message, signature) {\n        return this._address.verify(message, signature);\n    }\n}\n\n/**\n * Search parameters for the offline key provider. This class implements the KeySearchParams interface and includes\n * a convenience method for creating a new instance of this class for each function of the credits.aleo program.\n *\n * @example\n * // If storing a key for a custom program function\n * offlineSearchParams = new OfflineSearchParams(\"myprogram.aleo/myfunction\");\n *\n * // If storing a key for a credits.aleo program function\n * bondPublicKeyParams = OfflineSearchParams.bondPublicKeyParams();\n */\nclass OfflineSearchParams {\n    cacheKey;\n    verifyCreditsKeys;\n    /**\n     * Create a new OfflineSearchParams instance.\n     *\n     * @param {string} cacheKey - Key used to store the local function proving & verifying keys. This should be stored\n     * under the naming convention \"programName/functionName\" (i.e. \"myprogram.aleo/myfunction\")\n     * @param {boolean} verifyCreditsKeys - Whether to verify the keys against the credits.aleo program,\n     * defaults to false, but should be set to true if using keys from the credits.aleo program\n     */\n    constructor(cacheKey, verifyCreditsKeys = false) {\n        this.cacheKey = cacheKey;\n        this.verifyCreditsKeys = verifyCreditsKeys;\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the bond_public function of the credits.aleo program.\n     */\n    static bondPublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.bond_public.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the bond_validator function of the credits.aleo program.\n     */\n    static bondValidatorKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.bond_validator.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the claim_unbond_public function of the\n     */\n    static claimUnbondPublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.claim_unbond_public.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the fee_private function of the credits.aleo program.\n     */\n    static feePrivateKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_private.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the fee_public function of the credits.aleo program.\n     */\n    static feePublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_public.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the inclusion prover function.\n     */\n    static inclusionKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.inclusion.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the join function of the credits.aleo program.\n     */\n    static joinKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.join.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the set_validator_state function of the credits.aleo program.\n     */\n    static setValidatorStateKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.set_validator_state.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the split function of the credits.aleo program.\n     */\n    static splitKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.split.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_private function of the credits.aleo program.\n     */\n    static transferPrivateKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_private_to_public function of the credits.aleo program.\n     */\n    static transferPrivateToPublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private_to_public.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public function of the credits.aleo program.\n     */\n    static transferPublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public_as_signer function of the credits.aleo program.\n     */\n    static transferPublicAsSignerKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public_as_signer.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the transfer_public_to_private function of the credits.aleo program.\n     */\n    static transferPublicToPrivateKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public_to_private.locator, true);\n    }\n    /**\n     * Create a new OfflineSearchParams instance for the unbond_public function of the credits.aleo program.\n     */\n    static unbondPublicKeyParams() {\n        return new OfflineSearchParams(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.unbond_public.locator, true);\n    }\n}\n/**\n * A key provider meant for building transactions offline on devices such as hardware wallets. This key provider is not\n * able to contact the internet for key material and instead relies on the user to insert Aleo function proving &\n * verifying keys from local storage prior to usage.\n *\n * @example\n * // Create an offline program manager\n * const programManager = new ProgramManager();\n *\n * // Create a temporary account for the execution of the program\n * const account = new Account();\n * programManager.setAccount(account);\n *\n * // Create the proving keys from the key bytes on the offline machine\n * console.log(\"Creating proving keys from local key files\");\n * const program = \"program hello_hello.aleo; function hello: input r0 as u32.public; input r1 as u32.private; add r0 r1 into r2; output r2 as u32.private;\";\n * const myFunctionProver = await getLocalKey(\"/path/to/my/function/hello_hello.prover\");\n * const myFunctionVerifier = await getLocalKey(\"/path/to/my/function/hello_hello.verifier\");\n * const feePublicProvingKeyBytes = await getLocalKey(\"/path/to/credits.aleo/feePublic.prover\");\n *\n * myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProver);\n * myFunctionVerifyingKey = VerifyingKey.fromBytes(myFunctionVerifier);\n * const feePublicProvingKey = ProvingKey.fromBytes(feePublicKeyBytes);\n *\n * // Create an offline key provider\n * console.log(\"Creating offline key provider\");\n * const offlineKeyProvider = new OfflineKeyProvider();\n *\n * // Cache the keys\n * // Cache the proving and verifying keys for the custom hello function\n * OfflineKeyProvider.cacheKeys(\"hello_hello.aleo/hello\", myFunctionProvingKey, myFunctionVerifyingKey);\n *\n * // Cache the proving key for the fee_public function (the verifying key is automatically cached)\n * OfflineKeyProvider.insertFeePublicKey(feePublicProvingKey);\n *\n * // Create an offline query using the latest state root in order to create the inclusion proof\n * const offlineQuery = new OfflineQuery(\"latestStateRoot\");\n *\n * // Insert the key provider into the program manager\n * programManager.setKeyProvider(offlineKeyProvider);\n *\n * // Create the offline search params\n * const offlineSearchParams = new OfflineSearchParams(\"hello_hello.aleo/hello\");\n *\n * // Create the offline transaction\n * const offlineExecuteTx = <Transaction>await this.buildExecutionTransaction(\"hello_hello.aleo\", \"hello\", 1, false, [\"5u32\", \"5u32\"], undefined, offlineSearchParams, undefined, undefined, undefined, undefined, offlineQuery, program);\n *\n * // Broadcast the transaction later on a machine with internet access\n * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n * const txId = await networkClient.broadcastTransaction(offlineExecuteTx);\n */\nclass OfflineKeyProvider {\n    cache;\n    constructor() {\n        this.cache = new Map();\n    }\n    /**\n     * Get bond_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondPublicKeys() {\n        return this.functionKeys(OfflineSearchParams.bondPublicKeyParams());\n    }\n    ;\n    /**\n     * Get bond_validator function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function\n     */\n    bondValidatorKeys() {\n        return this.functionKeys(OfflineSearchParams.bondValidatorKeyParams());\n    }\n    ;\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId, keys) {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    }\n    ;\n    /**\n     * Get unbond_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function\n     */\n    claimUnbondPublicKeys() {\n        return this.functionKeys(OfflineSearchParams.claimUnbondPublicKeyParams());\n    }\n    ;\n    /**\n     * Get arbitrary function key from the offline key provider cache.\n     *\n     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * /// First cache the keys from local offline resources\n     * const offlineKeyProvider = new OfflineKeyProvider();\n     * const myFunctionVerifyingKey = VerifyingKey.fromString(\"verifier...\");\n     * const myFunctionProvingKeyBytes = await readBinaryFile('./resources/myfunction.prover');\n     * const myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProvingKeyBytes);\n     *\n     * /// Cache the keys for future use with a memorable locator\n     * offlineKeyProvider.cacheKeys(\"myprogram.aleo/myfunction\", [myFunctionProvingKey, myFunctionVerifyingKey]);\n     *\n     * /// When they're needed, retrieve the keys from the cache\n     *\n     * /// First create a search parameter object with the same locator used to cache the keys\n     * const keyParams = new OfflineSearchParams(\"myprogram.aleo/myfunction\");\n     *\n     * /// Then retrieve the keys\n     * const [myFunctionProver, myFunctionVerifier] = await offlineKeyProvider.functionKeys(keyParams);\n     */\n    functionKeys(params) {\n        return new Promise((resolve, reject) => {\n            if (params === undefined) {\n                reject(new Error(\"No search parameters provided, cannot retrieve keys\"));\n            }\n            else {\n                const keyId = params.cacheKey;\n                const verifyCreditsKeys = params.verifyCreditsKeys;\n                if (this.cache.has(keyId)) {\n                    const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);\n                    const provingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.ProvingKey.fromBytes(provingKeyBytes);\n                    const verifyingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.fromBytes(verifyingKeyBytes);\n                    if (verifyCreditsKeys) {\n                        const keysMatchExpected = this.verifyCreditsKeys(keyId, provingKey, verifyingKey);\n                        if (!keysMatchExpected) {\n                            reject(new Error(`Cached keys do not match expected keys for ${keyId}`));\n                        }\n                    }\n                    resolve([provingKey, verifyingKey]);\n                }\n                else {\n                    reject(new Error(\"Keys not found in cache for \" + keyId));\n                }\n            }\n        });\n    }\n    ;\n    /**\n     * Determines if the keys for a given credits function match the expected keys.\n     *\n     * @returns {boolean} Whether the keys match the expected keys\n     */\n    verifyCreditsKeys(locator, provingKey, verifyingKey) {\n        switch (locator) {\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.bond_public.locator:\n                return provingKey.isBondPublicProver() && verifyingKey.isBondPublicVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.claim_unbond_public.locator:\n                return provingKey.isClaimUnbondPublicProver() && verifyingKey.isClaimUnbondPublicVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_private.locator:\n                return provingKey.isFeePrivateProver() && verifyingKey.isFeePrivateVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_public.locator:\n                return provingKey.isFeePublicProver() && verifyingKey.isFeePublicVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.inclusion.locator:\n                return provingKey.isInclusionProver() && verifyingKey.isInclusionVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.join.locator:\n                return provingKey.isJoinProver() && verifyingKey.isJoinVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.set_validator_state.locator:\n                return provingKey.isSetValidatorStateProver() && verifyingKey.isSetValidatorStateVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.split.locator:\n                return provingKey.isSplitProver() && verifyingKey.isSplitVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private.locator:\n                return provingKey.isTransferPrivateProver() && verifyingKey.isTransferPrivateVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private_to_public.locator:\n                return provingKey.isTransferPrivateToPublicProver() && verifyingKey.isTransferPrivateToPublicVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public.locator:\n                return provingKey.isTransferPublicProver() && verifyingKey.isTransferPublicVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public_to_private.locator:\n                return provingKey.isTransferPublicToPrivateProver() && verifyingKey.isTransferPublicToPrivateVerifier();\n            case _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.unbond_public.locator:\n                return provingKey.isUnbondPublicProver() && verifyingKey.isUnbondPublicVerifier();\n            default:\n                return false;\n        }\n    }\n    /**\n     * Get fee_private function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePrivateKeys() {\n        return this.functionKeys(OfflineSearchParams.feePrivateKeyParams());\n    }\n    ;\n    /**\n     * Get fee_public function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    feePublicKeys() {\n        return this.functionKeys(OfflineSearchParams.feePublicKeyParams());\n    }\n    ;\n    /**\n     * Get join function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    joinKeys() {\n        return this.functionKeys(OfflineSearchParams.joinKeyParams());\n    }\n    ;\n    /**\n     * Get split function keys from the credits.aleo program. The keys must be cached prior to calling this\n     * method for it to work.\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    splitKeys() {\n        return this.functionKeys(OfflineSearchParams.splitKeyParams());\n    }\n    ;\n    /**\n     * Get keys for a variant of the transfer function from the credits.aleo program.\n     *\n     *\n     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function\n     *\n     * @example\n     * // Create a new OfflineKeyProvider\n     * const offlineKeyProvider = new OfflineKeyProvider();\n     *\n     * // Cache the keys for future use with the official locator\n     * const transferPublicProvingKeyBytes = await readBinaryFile('./resources/transfer_public.prover.a74565e');\n     * const transferPublicProvingKey = ProvingKey.fromBytes(transferPublicProvingKeyBytes);\n     *\n     * // Cache the transfer_public keys for future use with the OfflinKeyProvider's convenience method for\n     * // transfer_public (the verifying key will be cached automatically)\n     * offlineKeyProvider.insertTransferPublicKeys(transferPublicProvingKey);\n     *\n     * /// When they're needed, retrieve the keys from the cache\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    transferKeys(visibility) {\n        if (_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.c.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPrivateKeyParams());\n        }\n        else if (_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.d.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPrivateToPublicKeyParams());\n        }\n        else if (_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.f.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicKeyParams());\n        }\n        else if (_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.g.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicAsSignerKeyParams());\n        }\n        else if (_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.h.has(visibility)) {\n            return this.functionKeys(OfflineSearchParams.transferPublicToPrivateKeyParams());\n        }\n        else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    }\n    ;\n    /**\n     * Get unbond_public function keys from the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    async unBondPublicKeys() {\n        return this.functionKeys(OfflineSearchParams.unbondPublicKeyParams());\n    }\n    ;\n    /**\n     * Insert the proving and verifying keys for the bond_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for bond_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertBondPublicKeys(provingKey) {\n        if (provingKey.isBondPublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.bond_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.bondPublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for bond_public\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the claim_unbond_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for claim_unbond_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertClaimUnbondPublicKeys(provingKey) {\n        if (provingKey.isClaimUnbondPublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.claim_unbond_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.claimUnbondPublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for claim_unbond_public\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the fee_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for fee_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertFeePrivateKeys(provingKey) {\n        if (provingKey.isFeePrivateProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_private.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.feePrivateVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for fee_private\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the fee_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for fee_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertFeePublicKeys(provingKey) {\n        if (provingKey.isFeePublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.fee_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.feePublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for fee_public\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the join function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for join before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertJoinKeys(provingKey) {\n        if (provingKey.isJoinProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.join.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.joinVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for join\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the set_validator_state function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for set_validator_state before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertSetValidatorStateKeys(provingKey) {\n        if (provingKey.isSetValidatorStateProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.set_validator_state.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.setValidatorStateVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for set_validator_state\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the split function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for split before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertSplitKeys(provingKey) {\n        if (provingKey.isSplitProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.split.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.splitVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for split\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the transfer_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPrivateKeys(provingKey) {\n        if (provingKey.isTransferPrivateProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.transferPrivateVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_private\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the transfer_private_to_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_private_to_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPrivateToPublicKeys(provingKey) {\n        if (provingKey.isTransferPrivateToPublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_private_to_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.transferPrivateToPublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_private_to_public\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the transfer_public function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_public before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPublicKeys(provingKey) {\n        if (provingKey.isTransferPublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.transferPublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_public\");\n        }\n    }\n    /**\n     * Insert the proving and verifying keys for the transfer_public_to_private function into the cache. Only the proving key needs\n     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check\n     * that the keys match the expected checksum for transfer_public_to_private before inserting them into the cache.\n     *\n     * @param provingKey\n     */\n    insertTransferPublicToPrivateKeys(provingKey) {\n        if (provingKey.isTransferPublicToPrivateProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.transfer_public_to_private.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.transferPublicToPrivateVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for transfer_public_to_private\");\n        }\n    }\n    insertUnbondPublicKeys(provingKey) {\n        if (provingKey.isUnbondPublicProver()) {\n            this.cache.set(_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C.unbond_public.locator, [provingKey.toBytes(), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.VerifyingKey.unbondPublicVerifier().toBytes()]);\n        }\n        else {\n            throw new Error(\"Attempted to insert invalid proving keys for unbond_public\");\n        }\n    }\n}\n\n/**\n * A record provider implementation that uses the official Aleo API to find records for usage in program execution and\n * deployment, wallet functionality, and other use cases.\n */\nclass NetworkRecordProvider {\n    account;\n    networkClient;\n    constructor(account, networkClient) {\n        this.account = account;\n        this.networkClient = networkClient;\n    }\n    /**\n     * Set the account used to search for records\n     *\n     * @param {Account} account The account to use for searching for records\n     */\n    setAccount(account) {\n        this.account = account;\n    }\n    /**\n     * Find a list of credit records with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number[]} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * */\n    async findCreditsRecords(microcredits, unspent, nonces, searchParameters) {\n        let startHeight = 0;\n        let endHeight = 0;\n        let maxAmount = undefined;\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amount\"].every((item) => typeof item === 'number')) {\n                microcredits = searchParameters[\"amounts\"];\n            }\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"];\n            }\n        }\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            (0,_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.l)(\"Start height must be less than end height\");\n        }\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, [\"credits.aleo\"], microcredits, maxAmount, nonces, this.account.privateKey());\n    }\n    /**\n     * Find a credit record with a given number of microcredits by via the official Aleo API\n     *\n     * @param {number} microcredits The number of microcredits to search for\n     * @param {boolean} unspent Whether or not the record is unspent\n     * @param {string[]} nonces Nonces of records already found so that they are not found again\n     * @param {RecordSearchParams} searchParameters Additional parameters to search for\n     * @returns {Promise<RecordPlaintext>} The record if found, otherwise an error\n     *\n     * @example\n     * // Create a new NetworkRecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // The record provider can be used to find records with a given number of microcredits\n     * const record = await recordProvider.findCreditsRecord(5000, true, []);\n     *\n     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not\n     * // found again if a subsequent search is performed\n     * const records = await recordProvider.findCreditsRecords(5000, true, [record.nonce()]);\n     *\n     * // When the program manager is initialized with the record provider it will be used to find automatically find\n     * // fee records and amount records for value transfers so that they do not need to be specified manually\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     */\n    async findCreditsRecord(microcredits, unspent, nonces, searchParameters) {\n        let records = null;\n        try {\n            records = await this.findCreditsRecords([microcredits], unspent, nonces, searchParameters);\n        }\n        catch (e) {\n            console.log(\"No records found with error:\", e);\n        }\n        if (records && records.length > 0) {\n            return records[0];\n        }\n        console.error(\"Record not found with error:\", records);\n        throw new Error(\"Record not found\");\n    }\n    /**\n     * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.\n     */\n    async findRecord(unspent, nonces, searchParameters) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Find multiple records from a specified program.\n     */\n    async findRecords(unspent, nonces, searchParameters) {\n        let startHeight = 0;\n        let endHeight = 0;\n        let amounts = undefined;\n        let maxAmount = undefined;\n        let programs = undefined;\n        if (searchParameters) {\n            if (\"startHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                startHeight = searchParameters[\"startHeight\"];\n            }\n            if (\"endHeight\" in searchParameters && typeof searchParameters[\"endHeight\"] == \"number\") {\n                endHeight = searchParameters[\"endHeight\"];\n            }\n            if (\"amounts\" in searchParameters && Array.isArray(searchParameters[\"amounts\"]) && searchParameters[\"amounts\"].every((item) => typeof item === 'number')) {\n                amounts = searchParameters[\"amounts\"];\n            }\n            if (\"maxAmount\" in searchParameters && typeof searchParameters[\"maxAmount\"] == \"number\") {\n                maxAmount = searchParameters[\"maxAmount\"];\n            }\n            if (\"nonces\" in searchParameters && Array.isArray(searchParameters[\"nonces\"]) && searchParameters[\"nonces\"].every((item) => typeof item === \"string\")) {\n                nonces = searchParameters[\"nonces\"];\n            }\n            if (\"program\" in searchParameters && typeof searchParameters[\"program\"] == \"string\") {\n                programs = [searchParameters[\"program\"]];\n            }\n            if (\"programs\" in searchParameters && Array.isArray(searchParameters[\"programs\"]) && searchParameters[\"programs\"].every((item) => typeof item === \"string\")) {\n                programs = searchParameters[\"programs\"];\n            }\n            if (\"unspent\" in searchParameters && typeof searchParameters[\"unspent\"] == \"boolean\") {\n                unspent = searchParameters[\"unspent\"];\n            }\n        }\n        // If the end height is not specified, use the current block height\n        if (endHeight == 0) {\n            const end = await this.networkClient.getLatestHeight();\n            endHeight = end;\n        }\n        // If the start height is greater than the end height, throw an error\n        if (startHeight >= endHeight) {\n            (0,_program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.l)(\"Start height must be less than end height\");\n        }\n        return await this.networkClient.findRecords(startHeight, endHeight, unspent, programs, amounts, maxAmount, nonces, this.account.privateKey());\n    }\n}\n/**\n * BlockHeightSearch is a RecordSearchParams implementation that allows for searching for records within a given\n * block height range.\n *\n * @example\n * // Create a new BlockHeightSearch\n * const params = new BlockHeightSearch(89995, 99995);\n *\n * // Create a new NetworkRecordProvider\n * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n * const keyProvider = new AleoKeyProvider();\n * const recordProvider = new NetworkRecordProvider(account, networkClient);\n *\n * // The record provider can be used to find records with a given number of microcredits and the block height search\n * // can be used to find records within a given block height range\n * const record = await recordProvider.findCreditsRecord(5000, true, [], params);\n *\n */\nclass BlockHeightSearch {\n    startHeight;\n    endHeight;\n    constructor(startHeight, endHeight) {\n        this.startHeight = startHeight;\n        this.endHeight = endHeight;\n    }\n}\n\n// Experimental example where SDK manages worker\nlet singletonWorker = null;\nconst createAleoWorker = () => {\n    if (!singletonWorker) {\n        const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(0), __webpack_require__.b), {\n            type: undefined,\n        });\n        singletonWorker = (0,comlink__WEBPACK_IMPORTED_MODULE_3__.wrap)(worker);\n    }\n    return singletonWorker;\n};\n\n// @TODO: This function is no longer needed, remove it.\nasync function initializeWasm() {\n    console.warn(\"initializeWasm is deprecated, you no longer need to use it\");\n}\n\n\n//# sourceMappingURL=browser.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNvRztBQUNzVjtBQUNwUTtBQUNyQjtBQUN2TDs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQW1DO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFPO0FBQy9CLDJCQUEyQixtRUFBVTtBQUNyQyx3QkFBd0IsZ0VBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw2RUFBb0I7QUFDaEYsZ0NBQWdDLG1FQUFVO0FBQzFDLGlDQUFpQyxxQ0FBcUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQixtRUFBVTtBQUM3QjtBQUNBLG1CQUFtQixtRUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlFQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDLHlCQUF5QixtQkFBbUIseUJBQXlCO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJGQUE0QjtBQUN0RSxrQkFBa0IsU0FBUTtBQUMxQixTQUFTO0FBQ1QsMEJBQTBCLDZDQUFJO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaVM7QUFDalMiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXJuYW1lL2FsZW8vcmF0ZS1saW1pdGluZy1udWxsaWZpZXIvcmxuLW1lc3NhZ2UtYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm92YWJsZWhxK3Nka0AwLjguNi9ub2RlX21vZHVsZXMvQHByb3ZhYmxlaHEvc2RrL2Rpc3QvdGVzdG5ldC9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnY29yZS1qcy9wcm9wb3NhbHMvanNvbi1wYXJzZS13aXRoLXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBWaWV3S2V5LCBDb21wdXRlS2V5LCBBZGRyZXNzLCBQcml2YXRlS2V5Q2lwaGVydGV4dCwgUHJpdmF0ZUtleSwgUmVjb3JkQ2lwaGVydGV4dCwgUHJvdmluZ0tleSwgVmVyaWZ5aW5nS2V5IH0gZnJvbSAnQHByb3ZhYmxlaHEvd2FzbS90ZXN0bmV0LmpzJztcbmV4cG9ydCB7IEFkZHJlc3MsIEJIUDEwMjQsIEJIUDI1NiwgQkhQNTEyLCBCSFA3NjgsIENpcGhlcnRleHQsIENvbXB1dGVLZXksIEV4ZWN1dGlvblJlc3BvbnNlLCBGaWVsZCwgRXhlY3V0aW9uIGFzIEZ1bmN0aW9uRXhlY3V0aW9uLCBHcm91cCwgT2ZmbGluZVF1ZXJ5LCBQZWRlcnNlbjEyOCwgUGVkZXJzZW42NCwgUGxhaW50ZXh0LCBQb3NlaWRvbjIsIFBvc2VpZG9uNCwgUG9zZWlkb244LCBQcml2YXRlS2V5LCBQcml2YXRlS2V5Q2lwaGVydGV4dCwgUHJvZ3JhbSwgUHJvZ3JhbU1hbmFnZXIgYXMgUHJvZ3JhbU1hbmFnZXJCYXNlLCBQcm92aW5nS2V5LCBSZWNvcmRDaXBoZXJ0ZXh0LCBSZWNvcmRQbGFpbnRleHQsIFNjYWxhciwgU2lnbmF0dXJlLCBUcmFuc2FjdGlvbiwgVHJhbnNpdGlvbiwgVmVyaWZ5aW5nS2V5LCBWaWV3S2V5LCBpbml0VGhyZWFkUG9vbCwgdmVyaWZ5RnVuY3Rpb25FeGVjdXRpb24gfSBmcm9tICdAcHJvdmFibGVocS93YXNtL3Rlc3RuZXQuanMnO1xuaW1wb3J0IHsgQyBhcyBDUkVESVRTX1BST0dSQU1fS0VZUywgYyBhcyBQUklWQVRFX1RSQU5TRkVSLCBkIGFzIFBSSVZBVEVfVE9fUFVCTElDX1RSQU5TRkVSLCBmIGFzIFBVQkxJQ19UUkFOU0ZFUiwgZyBhcyBQVUJMSUNfVFJBTlNGRVJfQVNfU0lHTkVSLCBoIGFzIFBVQkxJQ19UT19QUklWQVRFX1RSQU5TRkVSLCBsIGFzIGxvZ0FuZFRocm93IH0gZnJvbSAnLi9wcm9ncmFtLW1hbmFnZXItQ2p2bk95Zm4uanMnO1xuZXhwb3J0IHsgQSBhcyBBbGVvS2V5UHJvdmlkZXIsIGEgYXMgQWxlb0tleVByb3ZpZGVyUGFyYW1zLCBiIGFzIEFsZW9OZXR3b3JrQ2xpZW50LCBLIGFzIEtFWV9TVE9SRSwgZSBhcyBQUklWQVRFX1RSQU5TRkVSX1RZUEVTLCBQIGFzIFByb2dyYW1NYW5hZ2VyLCBWIGFzIFZBTElEX1RSQU5TRkVSX1RZUEVTIH0gZnJvbSAnLi9wcm9ncmFtLW1hbmFnZXItQ2p2bk95Zm4uanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJ2NvbWxpbmsnO1xuXG4vKipcbiAqIEtleSBNYW5hZ2VtZW50IGNsYXNzLiBFbmFibGVzIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyBBbGVvIEFjY291bnQsIGltcG9ydGF0aW9uIG9mIGFuIGV4aXN0aW5nIGFjY291bnQgZnJvbVxuICogYW4gZXhpc3RpbmcgcHJpdmF0ZSBrZXkgb3Igc2VlZCwgYW5kIG1lc3NhZ2Ugc2lnbmluZyBhbmQgdmVyaWZpY2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQW4gQWxlbyBBY2NvdW50IGlzIGdlbmVyYXRlZCBmcm9tIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIHNlZWQgKG51bWJlcikgZnJvbSB3aGljaCBhbiBhY2NvdW50IHByaXZhdGUga2V5LCB2aWV3IGtleSxcbiAqIGFuZCBhIHB1YmxpYyBhY2NvdW50IGFkZHJlc3MgYXJlIGRlcml2ZWQuIFRoZSBwcml2YXRlIGtleSBsaWVzIGF0IHRoZSByb290IG9mIGFuIEFsZW8gYWNjb3VudC4gSXQgaXMgYSBoaWdobHlcbiAqIHNlbnNpdGl2ZSBzZWNyZXQgYW5kIHNob3VsZCBiZSBwcm90ZWN0ZWQgYXMgaXQgYWxsb3dzIGZvciBjcmVhdGlvbiBvZiBBbGVvIFByb2dyYW0gZXhlY3V0aW9ucyBhbmQgYXJiaXRyYXJ5IHZhbHVlXG4gKiB0cmFuc2ZlcnMuIFRoZSBWaWV3IEtleSBhbGxvd3MgZm9yIGRlY3J5cHRpb24gb2YgYSB1c2VyJ3MgYWN0aXZpdHkgb24gdGhlIGJsb2NrY2hhaW4uIFRoZSBBZGRyZXNzIGlzIHRoZSBwdWJsaWNcbiAqIGFkZHJlc3MgdG8gd2hpY2ggb3RoZXIgdXNlcnMgb2YgQWxlbyBjYW4gc2VuZCBBbGVvIGNyZWRpdHMgYW5kIG90aGVyIHJlY29yZHMgdG8uIFRoaXMgY2xhc3Mgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogZW52aXJvbm1lbnRzIHdoZXJlIHRoZSBzYWZldHkgb2YgdGhlIHVuZGVybHlpbmcga2V5IG1hdGVyaWFsIGNhbiBiZSBhc3N1cmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgYSBuZXcgYWNjb3VudFxuICogY29uc3QgbXlSYW5kb21BY2NvdW50ID0gbmV3IEFjY291bnQoKTtcbiAqXG4gKiAvLyBDcmVhdGUgYW4gYWNjb3VudCBmcm9tIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIHNlZWRcbiAqIGNvbnN0IHNlZWQgPSBuZXcgVWludDhBcnJheShbOTQsIDkxLCA1MiwgMjUxLCAyNDAsIDIzMCwgMjI2LCAzNSwgMTE3LCAyNTMsIDIyNCwgMjEwLCAxNzUsIDEzLCAyMDUsIDEyMCwgMTU1LCAyMTQsIDcsIDE2OSwgNjYsIDYyLCAyMDYsIDUwLCAxODgsIDQwLCAyOSwgMTIyLCA0MCwgMjUwLCA1NCwgMThdKTtcbiAqIGNvbnN0IG15U2VlZGVkQWNjb3VudCA9IG5ldyBBY2NvdW50KHtzZWVkOiBzZWVkfSk7XG4gKlxuICogLy8gQ3JlYXRlIGFuIGFjY291bnQgZnJvbSBhbiBleGlzdGluZyBwcml2YXRlIGtleVxuICogY29uc3QgbXlFeGlzdGluZ0FjY291bnQgPSBuZXcgQWNjb3VudCh7cHJpdmF0ZUtleTogJ215RXhpc3RpbmdQcml2YXRlS2V5J30pXG4gKlxuICogLy8gU2lnbiBhIG1lc3NhZ2VcbiAqIGNvbnN0IGhlbGxvX3dvcmxkID0gVWludDhBcnJheS5mcm9tKFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBjb25zdCBzaWduYXR1cmUgPSBteVJhbmRvbUFjY291bnQuc2lnbihoZWxsb193b3JsZClcbiAqXG4gKiAvLyBWZXJpZnkgYSBzaWduYXR1cmVcbiAqIG15UmFuZG9tQWNjb3VudC52ZXJpZnkoaGVsbG9fd29ybGQsIHNpZ25hdHVyZSlcbiAqL1xuY2xhc3MgQWNjb3VudCB7XG4gICAgX3ByaXZhdGVLZXk7XG4gICAgX3ZpZXdLZXk7XG4gICAgX2NvbXB1dGVLZXk7XG4gICAgX2FkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSB0aGlzLnByaXZhdGVLZXlGcm9tUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXcm9uZyBwYXJhbWV0ZXJcIiwgZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBQYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld0tleSA9IFZpZXdLZXkuZnJvbV9wcml2YXRlX2tleSh0aGlzLl9wcml2YXRlS2V5KTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IENvbXB1dGVLZXkuZnJvbV9wcml2YXRlX2tleSh0aGlzLl9wcml2YXRlS2V5KTtcbiAgICAgICAgdGhpcy5fYWRkcmVzcyA9IEFkZHJlc3MuZnJvbV9wcml2YXRlX2tleSh0aGlzLl9wcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIGFuIGFjY291bnQgZnJvbSBhIHByaXZhdGUga2V5IGNpcGhlcnRleHRcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXlDaXBoZXJ0ZXh0IHwgc3RyaW5nfSBjaXBoZXJ0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAgICogQHJldHVybnMge1ByaXZhdGVLZXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNpcGhlcnRleHQgPSBQcml2YXRlS2V5Lm5ld0VuY3J5cHRlZChcInBhc3N3b3JkXCIpO1xuICAgICAqIGNvbnN0IGFjY291bnQgPSBBY2NvdW50LmZyb21DaXBoZXJ0ZXh0KGNpcGhlcnRleHQsIFwicGFzc3dvcmRcIik7XG4gICAgICovXG4gICAgc3RhdGljIGZyb21DaXBoZXJ0ZXh0KGNpcGhlcnRleHQsIHBhc3N3b3JkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSA/IFByaXZhdGVLZXlDaXBoZXJ0ZXh0LmZyb21TdHJpbmcoY2lwaGVydGV4dCkgOiBjaXBoZXJ0ZXh0O1xuICAgICAgICAgICAgY29uc3QgX3ByaXZhdGVLZXkgPSBQcml2YXRlS2V5LmZyb21Qcml2YXRlS2V5Q2lwaGVydGV4dChjaXBoZXJ0ZXh0LCBwYXNzd29yZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjY291bnQoeyBwcml2YXRlS2V5OiBfcHJpdmF0ZUtleS50b19zdHJpbmcoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgcGFzc3dvcmQgb3IgaW52YWxpZCBjaXBoZXJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGVLZXlGcm9tUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNlZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21fc2VlZF91bmNoZWNrZWQocGFyYW1zLnNlZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbV9zdHJpbmcocGFyYW1zLnByaXZhdGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleSgpO1xuICAgIH1cbiAgICBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleTtcbiAgICB9XG4gICAgdmlld0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdLZXk7XG4gICAgfVxuICAgIGNvbXB1dGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wdXRlS2V5O1xuICAgIH1cbiAgICBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzcztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWNjb3VudCh7IHByaXZhdGVLZXk6IHRoaXMuX3ByaXZhdGVLZXkudG9fc3RyaW5nKCkgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzKCkudG9fc3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgdGhlIGFjY291bnQncyBwcml2YXRlIGtleSB3aXRoIGEgcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtQcml2YXRlS2V5Q2lwaGVydGV4dH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KCk7XG4gICAgICogY29uc3QgY2lwaGVydGV4dCA9IGFjY291bnQuZW5jcnlwdEFjY291bnQoXCJwYXNzd29yZFwiKTtcbiAgICAgKi9cbiAgICBlbmNyeXB0QWNjb3VudChwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleS50b0NpcGhlcnRleHQocGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBhIFJlY29yZCBpbiBjaXBoZXJ0ZXh0IGZvcm0gaW50byBwbGFpbnRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGFjY291bnQgPSBuZXcgQWNjb3VudCgpO1xuICAgICAqIGNvbnN0IHJlY29yZCA9IGFjY291bnQuZGVjcnlwdFJlY29yZChcInJlY29yZDFjaXBoZXJ0ZXh0XCIpO1xuICAgICAqL1xuICAgIGRlY3J5cHRSZWNvcmQoY2lwaGVydGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld0tleS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBhbiBhcnJheSBvZiBSZWNvcmRzIGluIGNpcGhlcnRleHQgZm9ybSBpbnRvIHBsYWludGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGNpcGhlcnRleHRzXG4gICAgICogQHJldHVybnMge1JlY29yZFtdfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gbmV3IEFjY291bnQoKTtcbiAgICAgKiBjb25zdCByZWNvcmQgPSBhY2NvdW50LmRlY3J5cHRSZWNvcmRzKFtcInJlY29yZDFjaXBoZXJ0ZXh0XCIsIFwicmVjb3JkMmNpcGhlcnRleHRcIl0pO1xuICAgICAqL1xuICAgIGRlY3J5cHRSZWNvcmRzKGNpcGhlcnRleHRzKSB7XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0cy5tYXAoKGNpcGhlcnRleHQpID0+IHRoaXMuX3ZpZXdLZXkuZGVjcnlwdChjaXBoZXJ0ZXh0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYWNjb3VudCBvd25zIGEgY2lwaGVydGV4dCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1JlY29yZENpcGhlclRleHQgfCBzdHJpbmd9IGNpcGhlcnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgQWxlbyBuZXR3b3JrIGFuZCBhbiBhY2NvdW50XG4gICAgICogY29uc3QgY29ubmVjdGlvbiA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gQWNjb3VudC5mcm9tQ2lwaGVydGV4dChcImNpcGhlcnRleHRcIiwgXCJwYXNzd29yZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIEdldCBhIHJlY29yZCBmcm9tIHRoZSBuZXR3b3JrXG4gICAgICogY29uc3QgcmVjb3JkID0gY29ubmVjdGlvbi5nZXRCbG9jaygxMjM0KTtcbiAgICAgKiBjb25zdCByZWNvcmRDaXBoZXJUZXh0ID0gcmVjb3JkLnRyYW5zYWN0aW9uc1swXS5leGVjdXRpb24udHJhbnNpdGlvbnNbMF0uaWQ7XG4gICAgICpcbiAgICAgKiAvLyBDaGVjayBpZiB0aGUgYWNjb3VudCBvd25zIHRoZSByZWNvcmRcbiAgICAgKiBpZiBhY2NvdW50Lm93bnNSZWNvcmQocmVjb3JkQ2lwaGVyVGV4dCkge1xuICAgICAqICAgICAvLyBUaGVuIG9uZSBjYW4gZG8gc29tZXRoaW5nIGxpa2U6XG4gICAgICogICAgIC8vIERlY3J5cHQgdGhlIHJlY29yZCBhbmQgY2hlY2sgaWYgaXQncyBzcGVudFxuICAgICAqICAgICAvLyBTdG9yZSB0aGUgcmVjb3JkIGluIGEgbG9jYWwgZGF0YWJhc2VcbiAgICAgKiAgICAgLy8gRXRjLlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBvd25zUmVjb3JkQ2lwaGVydGV4dChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dE9iamVjdCA9IFJlY29yZENpcGhlcnRleHQuZnJvbVN0cmluZyhjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dE9iamVjdC5pc093bmVyKHRoaXMuX3ZpZXdLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dC5pc093bmVyKHRoaXMuX3ZpZXdLZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgbWVzc2FnZSB3aXRoIHRoZSBhY2NvdW50J3MgcHJpdmF0ZSBrZXkuXG4gICAgICogUmV0dXJucyBhIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGFjY291bnQgPSBuZXcgQWNjb3VudCgpO1xuICAgICAqIGNvbnN0IG1lc3NhZ2UgPSBVaW50OEFycmF5LmZyb20oWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAgICAgKiBhY2NvdW50LnNpZ24obWVzc2FnZSk7XG4gICAgICovXG4gICAgc2lnbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlS2V5LnNpZ24obWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSBTaWduYXR1cmUgb24gYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBhY2NvdW50ID0gbmV3IEFjY291bnQoKTtcbiAgICAgKiBjb25zdCBtZXNzYWdlID0gVWludDhBcnJheS5mcm9tKFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gICAgICogY29uc3Qgc2lnbmF0dXJlID0gYWNjb3VudC5zaWduKG1lc3NhZ2UpO1xuICAgICAqIGFjY291bnQudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gICAgICovXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzcy52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VhcmNoIHBhcmFtZXRlcnMgZm9yIHRoZSBvZmZsaW5lIGtleSBwcm92aWRlci4gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBLZXlTZWFyY2hQYXJhbXMgaW50ZXJmYWNlIGFuZCBpbmNsdWRlc1xuICogYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZm9yIGVhY2ggZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiBzdG9yaW5nIGEga2V5IGZvciBhIGN1c3RvbSBwcm9ncmFtIGZ1bmN0aW9uXG4gKiBvZmZsaW5lU2VhcmNoUGFyYW1zID0gbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMoXCJteXByb2dyYW0uYWxlby9teWZ1bmN0aW9uXCIpO1xuICpcbiAqIC8vIElmIHN0b3JpbmcgYSBrZXkgZm9yIGEgY3JlZGl0cy5hbGVvIHByb2dyYW0gZnVuY3Rpb25cbiAqIGJvbmRQdWJsaWNLZXlQYXJhbXMgPSBPZmZsaW5lU2VhcmNoUGFyYW1zLmJvbmRQdWJsaWNLZXlQYXJhbXMoKTtcbiAqL1xuY2xhc3MgT2ZmbGluZVNlYXJjaFBhcmFtcyB7XG4gICAgY2FjaGVLZXk7XG4gICAgdmVyaWZ5Q3JlZGl0c0tleXM7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVLZXkgLSBLZXkgdXNlZCB0byBzdG9yZSB0aGUgbG9jYWwgZnVuY3Rpb24gcHJvdmluZyAmIHZlcmlmeWluZyBrZXlzLiBUaGlzIHNob3VsZCBiZSBzdG9yZWRcbiAgICAgKiB1bmRlciB0aGUgbmFtaW5nIGNvbnZlbnRpb24gXCJwcm9ncmFtTmFtZS9mdW5jdGlvbk5hbWVcIiAoaS5lLiBcIm15cHJvZ3JhbS5hbGVvL215ZnVuY3Rpb25cIilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcmlmeUNyZWRpdHNLZXlzIC0gV2hldGhlciB0byB2ZXJpZnkgdGhlIGtleXMgYWdhaW5zdCB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0sXG4gICAgICogZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCBzaG91bGQgYmUgc2V0IHRvIHRydWUgaWYgdXNpbmcga2V5cyBmcm9tIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlS2V5LCB2ZXJpZnlDcmVkaXRzS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVLZXkgPSBjYWNoZUtleTtcbiAgICAgICAgdGhpcy52ZXJpZnlDcmVkaXRzS2V5cyA9IHZlcmlmeUNyZWRpdHNLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIGJvbmRfcHVibGljIGZ1bmN0aW9uIG9mIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9uZFB1YmxpY0tleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfcHVibGljLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIGJvbmRfdmFsaWRhdG9yIGZ1bmN0aW9uIG9mIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9uZFZhbGlkYXRvcktleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfdmFsaWRhdG9yLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIGNsYWltX3VuYm9uZF9wdWJsaWMgZnVuY3Rpb24gb2YgdGhlXG4gICAgICovXG4gICAgc3RhdGljIGNsYWltVW5ib25kUHVibGljS2V5UGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMoQ1JFRElUU19QUk9HUkFNX0tFWVMuY2xhaW1fdW5ib25kX3B1YmxpYy5sb2NhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UgZm9yIHRoZSBmZWVfcHJpdmF0ZSBmdW5jdGlvbiBvZiB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0uXG4gICAgICovXG4gICAgc3RhdGljIGZlZVByaXZhdGVLZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy5mZWVfcHJpdmF0ZS5sb2NhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UgZm9yIHRoZSBmZWVfcHVibGljIGZ1bmN0aW9uIG9mIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZmVlUHVibGljS2V5UGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMoQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3B1YmxpYy5sb2NhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UgZm9yIHRoZSBpbmNsdXNpb24gcHJvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdXNpb25LZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy5pbmNsdXNpb24ubG9jYXRvciwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zIGluc3RhbmNlIGZvciB0aGUgam9pbiBmdW5jdGlvbiBvZiB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0uXG4gICAgICovXG4gICAgc3RhdGljIGpvaW5LZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy5qb2luLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIHNldF92YWxpZGF0b3Jfc3RhdGUgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRWYWxpZGF0b3JTdGF0ZUtleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLnNldF92YWxpZGF0b3Jfc3RhdGUubG9jYXRvciwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zIGluc3RhbmNlIGZvciB0aGUgc3BsaXQgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyBzcGxpdEtleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLnNwbGl0LmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIHRyYW5zZmVyX3ByaXZhdGUgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2ZlclByaXZhdGVLZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wcml2YXRlLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIHRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljIGZ1bmN0aW9uIG9mIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmZXJQcml2YXRlVG9QdWJsaWNLZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wcml2YXRlX3RvX3B1YmxpYy5sb2NhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWMgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2ZlclB1YmxpY0tleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpYy5sb2NhdG9yLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMgaW5zdGFuY2UgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfYXNfc2lnbmVyIGZ1bmN0aW9uIG9mIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmZXJQdWJsaWNBc1NpZ25lcktleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpY19hc19zaWduZXIubG9jYXRvciwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zIGluc3RhbmNlIGZvciB0aGUgdHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGUgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc2ZlclB1YmxpY1RvUHJpdmF0ZUtleVBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lU2VhcmNoUGFyYW1zKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyBpbnN0YW5jZSBmb3IgdGhlIHVuYm9uZF9wdWJsaWMgZnVuY3Rpb24gb2YgdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLlxuICAgICAqL1xuICAgIHN0YXRpYyB1bmJvbmRQdWJsaWNLZXlQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhDUkVESVRTX1BST0dSQU1fS0VZUy51bmJvbmRfcHVibGljLmxvY2F0b3IsIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogQSBrZXkgcHJvdmlkZXIgbWVhbnQgZm9yIGJ1aWxkaW5nIHRyYW5zYWN0aW9ucyBvZmZsaW5lIG9uIGRldmljZXMgc3VjaCBhcyBoYXJkd2FyZSB3YWxsZXRzLiBUaGlzIGtleSBwcm92aWRlciBpcyBub3RcbiAqIGFibGUgdG8gY29udGFjdCB0aGUgaW50ZXJuZXQgZm9yIGtleSBtYXRlcmlhbCBhbmQgaW5zdGVhZCByZWxpZXMgb24gdGhlIHVzZXIgdG8gaW5zZXJ0IEFsZW8gZnVuY3Rpb24gcHJvdmluZyAmXG4gKiB2ZXJpZnlpbmcga2V5cyBmcm9tIGxvY2FsIHN0b3JhZ2UgcHJpb3IgdG8gdXNhZ2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhbiBvZmZsaW5lIHByb2dyYW0gbWFuYWdlclxuICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoKTtcbiAqXG4gKiAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgYWNjb3VudCBmb3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgcHJvZ3JhbVxuICogY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KCk7XG4gKiBwcm9ncmFtTWFuYWdlci5zZXRBY2NvdW50KGFjY291bnQpO1xuICpcbiAqIC8vIENyZWF0ZSB0aGUgcHJvdmluZyBrZXlzIGZyb20gdGhlIGtleSBieXRlcyBvbiB0aGUgb2ZmbGluZSBtYWNoaW5lXG4gKiBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHByb3Zpbmcga2V5cyBmcm9tIGxvY2FsIGtleSBmaWxlc1wiKTtcbiAqIGNvbnN0IHByb2dyYW0gPSBcInByb2dyYW0gaGVsbG9faGVsbG8uYWxlbzsgZnVuY3Rpb24gaGVsbG86IGlucHV0IHIwIGFzIHUzMi5wdWJsaWM7IGlucHV0IHIxIGFzIHUzMi5wcml2YXRlOyBhZGQgcjAgcjEgaW50byByMjsgb3V0cHV0IHIyIGFzIHUzMi5wcml2YXRlO1wiO1xuICogY29uc3QgbXlGdW5jdGlvblByb3ZlciA9IGF3YWl0IGdldExvY2FsS2V5KFwiL3BhdGgvdG8vbXkvZnVuY3Rpb24vaGVsbG9faGVsbG8ucHJvdmVyXCIpO1xuICogY29uc3QgbXlGdW5jdGlvblZlcmlmaWVyID0gYXdhaXQgZ2V0TG9jYWxLZXkoXCIvcGF0aC90by9teS9mdW5jdGlvbi9oZWxsb19oZWxsby52ZXJpZmllclwiKTtcbiAqIGNvbnN0IGZlZVB1YmxpY1Byb3ZpbmdLZXlCeXRlcyA9IGF3YWl0IGdldExvY2FsS2V5KFwiL3BhdGgvdG8vY3JlZGl0cy5hbGVvL2ZlZVB1YmxpYy5wcm92ZXJcIik7XG4gKlxuICogbXlGdW5jdGlvblByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhteUZ1bmN0aW9uUHJvdmVyKTtcbiAqIG15RnVuY3Rpb25WZXJpZnlpbmdLZXkgPSBWZXJpZnlpbmdLZXkuZnJvbUJ5dGVzKG15RnVuY3Rpb25WZXJpZmllcik7XG4gKiBjb25zdCBmZWVQdWJsaWNQcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoZmVlUHVibGljS2V5Qnl0ZXMpO1xuICpcbiAqIC8vIENyZWF0ZSBhbiBvZmZsaW5lIGtleSBwcm92aWRlclxuICogY29uc29sZS5sb2coXCJDcmVhdGluZyBvZmZsaW5lIGtleSBwcm92aWRlclwiKTtcbiAqIGNvbnN0IG9mZmxpbmVLZXlQcm92aWRlciA9IG5ldyBPZmZsaW5lS2V5UHJvdmlkZXIoKTtcbiAqXG4gKiAvLyBDYWNoZSB0aGUga2V5c1xuICogLy8gQ2FjaGUgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgY3VzdG9tIGhlbGxvIGZ1bmN0aW9uXG4gKiBPZmZsaW5lS2V5UHJvdmlkZXIuY2FjaGVLZXlzKFwiaGVsbG9faGVsbG8uYWxlby9oZWxsb1wiLCBteUZ1bmN0aW9uUHJvdmluZ0tleSwgbXlGdW5jdGlvblZlcmlmeWluZ0tleSk7XG4gKlxuICogLy8gQ2FjaGUgdGhlIHByb3Zpbmcga2V5IGZvciB0aGUgZmVlX3B1YmxpYyBmdW5jdGlvbiAodGhlIHZlcmlmeWluZyBrZXkgaXMgYXV0b21hdGljYWxseSBjYWNoZWQpXG4gKiBPZmZsaW5lS2V5UHJvdmlkZXIuaW5zZXJ0RmVlUHVibGljS2V5KGZlZVB1YmxpY1Byb3ZpbmdLZXkpO1xuICpcbiAqIC8vIENyZWF0ZSBhbiBvZmZsaW5lIHF1ZXJ5IHVzaW5nIHRoZSBsYXRlc3Qgc3RhdGUgcm9vdCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIGluY2x1c2lvbiBwcm9vZlxuICogY29uc3Qgb2ZmbGluZVF1ZXJ5ID0gbmV3IE9mZmxpbmVRdWVyeShcImxhdGVzdFN0YXRlUm9vdFwiKTtcbiAqXG4gKiAvLyBJbnNlcnQgdGhlIGtleSBwcm92aWRlciBpbnRvIHRoZSBwcm9ncmFtIG1hbmFnZXJcbiAqIHByb2dyYW1NYW5hZ2VyLnNldEtleVByb3ZpZGVyKG9mZmxpbmVLZXlQcm92aWRlcik7XG4gKlxuICogLy8gQ3JlYXRlIHRoZSBvZmZsaW5lIHNlYXJjaCBwYXJhbXNcbiAqIGNvbnN0IG9mZmxpbmVTZWFyY2hQYXJhbXMgPSBuZXcgT2ZmbGluZVNlYXJjaFBhcmFtcyhcImhlbGxvX2hlbGxvLmFsZW8vaGVsbG9cIik7XG4gKlxuICogLy8gQ3JlYXRlIHRoZSBvZmZsaW5lIHRyYW5zYWN0aW9uXG4gKiBjb25zdCBvZmZsaW5lRXhlY3V0ZVR4ID0gPFRyYW5zYWN0aW9uPmF3YWl0IHRoaXMuYnVpbGRFeGVjdXRpb25UcmFuc2FjdGlvbihcImhlbGxvX2hlbGxvLmFsZW9cIiwgXCJoZWxsb1wiLCAxLCBmYWxzZSwgW1wiNXUzMlwiLCBcIjV1MzJcIl0sIHVuZGVmaW5lZCwgb2ZmbGluZVNlYXJjaFBhcmFtcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvZmZsaW5lUXVlcnksIHByb2dyYW0pO1xuICpcbiAqIC8vIEJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gbGF0ZXIgb24gYSBtYWNoaW5lIHdpdGggaW50ZXJuZXQgYWNjZXNzXG4gKiBjb25zdCBuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIpO1xuICogY29uc3QgdHhJZCA9IGF3YWl0IG5ldHdvcmtDbGllbnQuYnJvYWRjYXN0VHJhbnNhY3Rpb24ob2ZmbGluZUV4ZWN1dGVUeCk7XG4gKi9cbmNsYXNzIE9mZmxpbmVLZXlQcm92aWRlciB7XG4gICAgY2FjaGU7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBib25kX3B1YmxpYyBmdW5jdGlvbiBrZXlzIGZyb20gdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLiBUaGUga2V5cyBtdXN0IGJlIGNhY2hlZCBwcmlvciB0byBjYWxsaW5nIHRoaXNcbiAgICAgKiBtZXRob2QgZm9yIGl0IHRvIHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbktleVBhaXI+fSBQcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYm9uZFB1YmxpY0tleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uS2V5cyhPZmZsaW5lU2VhcmNoUGFyYW1zLmJvbmRQdWJsaWNLZXlQYXJhbXMoKSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQgYm9uZF92YWxpZGF0b3IgZnVuY3Rpb24ga2V5cyBmcm9tIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS4gVGhlIGtleXMgbXVzdCBiZSBjYWNoZWQgcHJpb3IgdG8gY2FsbGluZyB0aGlzXG4gICAgICogbWV0aG9kIGZvciBpdCB0byB3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBib25kX3B1YmxpYyBmdW5jdGlvblxuICAgICAqL1xuICAgIGJvbmRWYWxpZGF0b3JLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbktleXMoT2ZmbGluZVNlYXJjaFBhcmFtcy5ib25kVmFsaWRhdG9yS2V5UGFyYW1zKCkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FjaGUgYSBzZXQgb2Yga2V5cy4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3Rpbmcga2V5cyB3aXRoIHRoZSBzYW1lIGtleUlkLiBUaGUgdXNlciBjYW4gY2hlY2sgaWYgYSBrZXlJZFxuICAgICAqIGV4aXN0cyBpbiB0aGUgY2FjaGUgdXNpbmcgdGhlIGNvbnRhaW5zS2V5cyBtZXRob2QgcHJpb3IgdG8gY2FsbGluZyB0aGlzIG1ldGhvZCBpZiBvdmVyd3JpdGluZyBpcyBub3QgZGVzaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZCBhY2Nlc3Mga2V5IGZvciB0aGUgY2FjaGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uS2V5UGFpcn0ga2V5cyBrZXlzIHRvIGNhY2hlXG4gICAgICovXG4gICAgY2FjaGVLZXlzKGtleUlkLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IFtwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXldID0ga2V5cztcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5SWQsIFtwcm92aW5nS2V5LnRvQnl0ZXMoKSwgdmVyaWZ5aW5nS2V5LnRvQnl0ZXMoKV0pO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0IHVuYm9uZF9wdWJsaWMgZnVuY3Rpb24ga2V5cyBmcm9tIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS4gVGhlIGtleXMgbXVzdCBiZSBjYWNoZWQgcHJpb3IgdG8gY2FsbGluZyB0aGlzXG4gICAgICogbWV0aG9kIGZvciBpdCB0byB3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSB1bmJvbmRfcHVibGljIGZ1bmN0aW9uXG4gICAgICovXG4gICAgY2xhaW1VbmJvbmRQdWJsaWNLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbktleXMoT2ZmbGluZVNlYXJjaFBhcmFtcy5jbGFpbVVuYm9uZFB1YmxpY0tleVBhcmFtcygpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldCBhcmJpdHJhcnkgZnVuY3Rpb24ga2V5IGZyb20gdGhlIG9mZmxpbmUga2V5IHByb3ZpZGVyIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlTZWFyY2hQYXJhbXMgfCB1bmRlZmluZWR9IHBhcmFtcyAtIE9wdGlvbmFsIHNlYXJjaCBwYXJhbWV0ZXJzIGZvciB0aGUga2V5IHByb3ZpZGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLy8gRmlyc3QgY2FjaGUgdGhlIGtleXMgZnJvbSBsb2NhbCBvZmZsaW5lIHJlc291cmNlc1xuICAgICAqIGNvbnN0IG9mZmxpbmVLZXlQcm92aWRlciA9IG5ldyBPZmZsaW5lS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBjb25zdCBteUZ1bmN0aW9uVmVyaWZ5aW5nS2V5ID0gVmVyaWZ5aW5nS2V5LmZyb21TdHJpbmcoXCJ2ZXJpZmllci4uLlwiKTtcbiAgICAgKiBjb25zdCBteUZ1bmN0aW9uUHJvdmluZ0tleUJ5dGVzID0gYXdhaXQgcmVhZEJpbmFyeUZpbGUoJy4vcmVzb3VyY2VzL215ZnVuY3Rpb24ucHJvdmVyJyk7XG4gICAgICogY29uc3QgbXlGdW5jdGlvblByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhteUZ1bmN0aW9uUHJvdmluZ0tleUJ5dGVzKTtcbiAgICAgKlxuICAgICAqIC8vLyBDYWNoZSB0aGUga2V5cyBmb3IgZnV0dXJlIHVzZSB3aXRoIGEgbWVtb3JhYmxlIGxvY2F0b3JcbiAgICAgKiBvZmZsaW5lS2V5UHJvdmlkZXIuY2FjaGVLZXlzKFwibXlwcm9ncmFtLmFsZW8vbXlmdW5jdGlvblwiLCBbbXlGdW5jdGlvblByb3ZpbmdLZXksIG15RnVuY3Rpb25WZXJpZnlpbmdLZXldKTtcbiAgICAgKlxuICAgICAqIC8vLyBXaGVuIHRoZXkncmUgbmVlZGVkLCByZXRyaWV2ZSB0aGUga2V5cyBmcm9tIHRoZSBjYWNoZVxuICAgICAqXG4gICAgICogLy8vIEZpcnN0IGNyZWF0ZSBhIHNlYXJjaCBwYXJhbWV0ZXIgb2JqZWN0IHdpdGggdGhlIHNhbWUgbG9jYXRvciB1c2VkIHRvIGNhY2hlIHRoZSBrZXlzXG4gICAgICogY29uc3Qga2V5UGFyYW1zID0gbmV3IE9mZmxpbmVTZWFyY2hQYXJhbXMoXCJteXByb2dyYW0uYWxlby9teWZ1bmN0aW9uXCIpO1xuICAgICAqXG4gICAgICogLy8vIFRoZW4gcmV0cmlldmUgdGhlIGtleXNcbiAgICAgKiBjb25zdCBbbXlGdW5jdGlvblByb3ZlciwgbXlGdW5jdGlvblZlcmlmaWVyXSA9IGF3YWl0IG9mZmxpbmVLZXlQcm92aWRlci5mdW5jdGlvbktleXMoa2V5UGFyYW1zKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbktleXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTm8gc2VhcmNoIHBhcmFtZXRlcnMgcHJvdmlkZWQsIGNhbm5vdCByZXRyaWV2ZSBrZXlzXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUlkID0gcGFyYW1zLmNhY2hlS2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmeUNyZWRpdHNLZXlzID0gcGFyYW1zLnZlcmlmeUNyZWRpdHNLZXlzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXlJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3ZpbmdLZXlCeXRlcywgdmVyaWZ5aW5nS2V5Qnl0ZXNdID0gdGhpcy5jYWNoZS5nZXQoa2V5SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMocHJvdmluZ0tleUJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyaWZ5aW5nS2V5ID0gVmVyaWZ5aW5nS2V5LmZyb21CeXRlcyh2ZXJpZnlpbmdLZXlCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJpZnlDcmVkaXRzS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5c01hdGNoRXhwZWN0ZWQgPSB0aGlzLnZlcmlmeUNyZWRpdHNLZXlzKGtleUlkLCBwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzTWF0Y2hFeHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhY2hlZCBrZXlzIGRvIG5vdCBtYXRjaCBleHBlY3RlZCBrZXlzIGZvciAke2tleUlkfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJLZXlzIG5vdCBmb3VuZCBpbiBjYWNoZSBmb3IgXCIgKyBrZXlJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBrZXlzIGZvciBhIGdpdmVuIGNyZWRpdHMgZnVuY3Rpb24gbWF0Y2ggdGhlIGV4cGVjdGVkIGtleXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQga2V5c1xuICAgICAqL1xuICAgIHZlcmlmeUNyZWRpdHNLZXlzKGxvY2F0b3IsIHByb3ZpbmdLZXksIHZlcmlmeWluZ0tleSkge1xuICAgICAgICBzd2l0Y2ggKGxvY2F0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF9wdWJsaWMubG9jYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmluZ0tleS5pc0JvbmRQdWJsaWNQcm92ZXIoKSAmJiB2ZXJpZnlpbmdLZXkuaXNCb25kUHVibGljVmVyaWZpZXIoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuY2xhaW1fdW5ib25kX3B1YmxpYy5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzQ2xhaW1VbmJvbmRQdWJsaWNQcm92ZXIoKSAmJiB2ZXJpZnlpbmdLZXkuaXNDbGFpbVVuYm9uZFB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmZlZV9wcml2YXRlLmxvY2F0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpbmdLZXkuaXNGZWVQcml2YXRlUHJvdmVyKCkgJiYgdmVyaWZ5aW5nS2V5LmlzRmVlUHJpdmF0ZVZlcmlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmZlZV9wdWJsaWMubG9jYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmluZ0tleS5pc0ZlZVB1YmxpY1Byb3ZlcigpICYmIHZlcmlmeWluZ0tleS5pc0ZlZVB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmluY2x1c2lvbi5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzSW5jbHVzaW9uUHJvdmVyKCkgJiYgdmVyaWZ5aW5nS2V5LmlzSW5jbHVzaW9uVmVyaWZpZXIoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuam9pbi5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzSm9pblByb3ZlcigpICYmIHZlcmlmeWluZ0tleS5pc0pvaW5WZXJpZmllcigpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy5zZXRfdmFsaWRhdG9yX3N0YXRlLmxvY2F0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpbmdLZXkuaXNTZXRWYWxpZGF0b3JTdGF0ZVByb3ZlcigpICYmIHZlcmlmeWluZ0tleS5pc1NldFZhbGlkYXRvclN0YXRlVmVyaWZpZXIoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuc3BsaXQubG9jYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmluZ0tleS5pc1NwbGl0UHJvdmVyKCkgJiYgdmVyaWZ5aW5nS2V5LmlzU3BsaXRWZXJpZmllcigpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wcml2YXRlLmxvY2F0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVQcm92ZXIoKSAmJiB2ZXJpZnlpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVWZXJpZmllcigpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wcml2YXRlX3RvX3B1YmxpYy5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzVHJhbnNmZXJQcml2YXRlVG9QdWJsaWNQcm92ZXIoKSAmJiB2ZXJpZnlpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVUb1B1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpYy5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzVHJhbnNmZXJQdWJsaWNQcm92ZXIoKSAmJiB2ZXJpZnlpbmdLZXkuaXNUcmFuc2ZlclB1YmxpY1ZlcmlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlLmxvY2F0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpbmdLZXkuaXNUcmFuc2ZlclB1YmxpY1RvUHJpdmF0ZVByb3ZlcigpICYmIHZlcmlmeWluZ0tleS5pc1RyYW5zZmVyUHVibGljVG9Qcml2YXRlVmVyaWZpZXIoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMudW5ib25kX3B1YmxpYy5sb2NhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5LmlzVW5ib25kUHVibGljUHJvdmVyKCkgJiYgdmVyaWZ5aW5nS2V5LmlzVW5ib25kUHVibGljVmVyaWZpZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmZWVfcHJpdmF0ZSBmdW5jdGlvbiBrZXlzIGZyb20gdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtLiBUaGUga2V5cyBtdXN0IGJlIGNhY2hlZCBwcmlvciB0byBjYWxsaW5nIHRoaXNcbiAgICAgKiBtZXRob2QgZm9yIGl0IHRvIHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbktleVBhaXI+fSBQcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGpvaW4gZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmZWVQcml2YXRlS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LZXlzKE9mZmxpbmVTZWFyY2hQYXJhbXMuZmVlUHJpdmF0ZUtleVBhcmFtcygpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldCBmZWVfcHVibGljIGZ1bmN0aW9uIGtleXMgZnJvbSB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0uIFRoZSBrZXlzIG11c3QgYmUgY2FjaGVkIHByaW9yIHRvIGNhbGxpbmcgdGhpc1xuICAgICAqIG1ldGhvZCBmb3IgaXQgdG8gd29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZlZVB1YmxpY0tleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uS2V5cyhPZmZsaW5lU2VhcmNoUGFyYW1zLmZlZVB1YmxpY0tleVBhcmFtcygpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldCBqb2luIGZ1bmN0aW9uIGtleXMgZnJvbSB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0uIFRoZSBrZXlzIG11c3QgYmUgY2FjaGVkIHByaW9yIHRvIGNhbGxpbmcgdGhpc1xuICAgICAqIG1ldGhvZCBmb3IgaXQgdG8gd29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGpvaW5LZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbktleXMoT2ZmbGluZVNlYXJjaFBhcmFtcy5qb2luS2V5UGFyYW1zKCkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0IHNwbGl0IGZ1bmN0aW9uIGtleXMgZnJvbSB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW0uIFRoZSBrZXlzIG11c3QgYmUgY2FjaGVkIHByaW9yIHRvIGNhbGxpbmcgdGhpc1xuICAgICAqIG1ldGhvZCBmb3IgaXQgdG8gd29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqL1xuICAgIHNwbGl0S2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LZXlzKE9mZmxpbmVTZWFyY2hQYXJhbXMuc3BsaXRLZXlQYXJhbXMoKSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQga2V5cyBmb3IgYSB2YXJpYW50IG9mIHRoZSB0cmFuc2ZlciBmdW5jdGlvbiBmcm9tIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpc2liaWxpdHkgVmlzaWJpbGl0eSBvZiB0aGUgdHJhbnNmZXIgZnVuY3Rpb24gKHByaXZhdGUsIHB1YmxpYywgcHJpdmF0ZVRvUHVibGljLCBwdWJsaWNUb1ByaXZhdGUpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBzcGVjaWZpZWQgdHJhbnNmZXIgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE9mZmxpbmVLZXlQcm92aWRlclxuICAgICAqIGNvbnN0IG9mZmxpbmVLZXlQcm92aWRlciA9IG5ldyBPZmZsaW5lS2V5UHJvdmlkZXIoKTtcbiAgICAgKlxuICAgICAqIC8vIENhY2hlIHRoZSBrZXlzIGZvciBmdXR1cmUgdXNlIHdpdGggdGhlIG9mZmljaWFsIGxvY2F0b3JcbiAgICAgKiBjb25zdCB0cmFuc2ZlclB1YmxpY1Byb3ZpbmdLZXlCeXRlcyA9IGF3YWl0IHJlYWRCaW5hcnlGaWxlKCcuL3Jlc291cmNlcy90cmFuc2Zlcl9wdWJsaWMucHJvdmVyLmE3NDU2NWUnKTtcbiAgICAgKiBjb25zdCB0cmFuc2ZlclB1YmxpY1Byb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyh0cmFuc2ZlclB1YmxpY1Byb3ZpbmdLZXlCeXRlcyk7XG4gICAgICpcbiAgICAgKiAvLyBDYWNoZSB0aGUgdHJhbnNmZXJfcHVibGljIGtleXMgZm9yIGZ1dHVyZSB1c2Ugd2l0aCB0aGUgT2ZmbGluS2V5UHJvdmlkZXIncyBjb252ZW5pZW5jZSBtZXRob2QgZm9yXG4gICAgICogLy8gdHJhbnNmZXJfcHVibGljICh0aGUgdmVyaWZ5aW5nIGtleSB3aWxsIGJlIGNhY2hlZCBhdXRvbWF0aWNhbGx5KVxuICAgICAqIG9mZmxpbmVLZXlQcm92aWRlci5pbnNlcnRUcmFuc2ZlclB1YmxpY0tleXModHJhbnNmZXJQdWJsaWNQcm92aW5nS2V5KTtcbiAgICAgKlxuICAgICAqIC8vLyBXaGVuIHRoZXkncmUgbmVlZGVkLCByZXRyaWV2ZSB0aGUga2V5cyBmcm9tIHRoZSBjYWNoZVxuICAgICAqIGNvbnN0IFt0cmFuc2ZlclB1YmxpY1Byb3ZpbmdLZXksIHRyYW5zZmVyUHVibGljVmVyaWZ5aW5nS2V5XSA9IGF3YWl0IGtleVByb3ZpZGVyLnRyYW5zZmVyS2V5cyhcInB1YmxpY1wiKTtcbiAgICAgKi9cbiAgICB0cmFuc2ZlcktleXModmlzaWJpbGl0eSkge1xuICAgICAgICBpZiAoUFJJVkFURV9UUkFOU0ZFUi5oYXModmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uS2V5cyhPZmZsaW5lU2VhcmNoUGFyYW1zLnRyYW5zZmVyUHJpdmF0ZUtleVBhcmFtcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQUklWQVRFX1RPX1BVQkxJQ19UUkFOU0ZFUi5oYXModmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uS2V5cyhPZmZsaW5lU2VhcmNoUGFyYW1zLnRyYW5zZmVyUHJpdmF0ZVRvUHVibGljS2V5UGFyYW1zKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBVQkxJQ19UUkFOU0ZFUi5oYXModmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uS2V5cyhPZmZsaW5lU2VhcmNoUGFyYW1zLnRyYW5zZmVyUHVibGljS2V5UGFyYW1zKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBVQkxJQ19UUkFOU0ZFUl9BU19TSUdORVIuaGFzKHZpc2liaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbktleXMoT2ZmbGluZVNlYXJjaFBhcmFtcy50cmFuc2ZlclB1YmxpY0FzU2lnbmVyS2V5UGFyYW1zKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBVQkxJQ19UT19QUklWQVRFX1RSQU5TRkVSLmhhcyh2aXNpYmlsaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LZXlzKE9mZmxpbmVTZWFyY2hQYXJhbXMudHJhbnNmZXJQdWJsaWNUb1ByaXZhdGVLZXlQYXJhbXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZpc2liaWxpdHkgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0IHVuYm9uZF9wdWJsaWMgZnVuY3Rpb24ga2V5cyBmcm9tIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBqb2luIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgdW5Cb25kUHVibGljS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LZXlzKE9mZmxpbmVTZWFyY2hQYXJhbXMudW5ib25kUHVibGljS2V5UGFyYW1zKCkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGJvbmRfcHVibGljIGZ1bmN0aW9uIGludG8gdGhlIGNhY2hlLiBPbmx5IHRoZSBwcm92aW5nIGtleSBuZWVkc1xuICAgICAqIHRvIGJlIGluc2VydGVkLCB0aGUgdmVyaWZ5aW5nIGtleSBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGJ5IHRoZSBTREsuIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNoZWNrXG4gICAgICogdGhhdCB0aGUga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQgY2hlY2tzdW0gZm9yIGJvbmRfcHVibGljIGJlZm9yZSBpbnNlcnRpbmcgdGhlbSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aW5nS2V5XG4gICAgICovXG4gICAgaW5zZXJ0Qm9uZFB1YmxpY0tleXMocHJvdmluZ0tleSkge1xuICAgICAgICBpZiAocHJvdmluZ0tleS5pc0JvbmRQdWJsaWNQcm92ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF9wdWJsaWMubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkuYm9uZFB1YmxpY1ZlcmlmaWVyKCkudG9CeXRlcygpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gaW5zZXJ0IGludmFsaWQgcHJvdmluZyBrZXlzIGZvciBib25kX3B1YmxpY1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgY2xhaW1fdW5ib25kX3B1YmxpYyBmdW5jdGlvbiBpbnRvIHRoZSBjYWNoZS4gT25seSB0aGUgcHJvdmluZyBrZXkgbmVlZHNcbiAgICAgKiB0byBiZSBpbnNlcnRlZCwgdGhlIHZlcmlmeWluZyBrZXkgaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZCBieSB0aGUgU0RLLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjaGVja1xuICAgICAqIHRoYXQgdGhlIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIGNoZWNrc3VtIGZvciBjbGFpbV91bmJvbmRfcHVibGljIGJlZm9yZSBpbnNlcnRpbmcgdGhlbSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aW5nS2V5XG4gICAgICovXG4gICAgaW5zZXJ0Q2xhaW1VbmJvbmRQdWJsaWNLZXlzKHByb3ZpbmdLZXkpIHtcbiAgICAgICAgaWYgKHByb3ZpbmdLZXkuaXNDbGFpbVVuYm9uZFB1YmxpY1Byb3ZlcigpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChDUkVESVRTX1BST0dSQU1fS0VZUy5jbGFpbV91bmJvbmRfcHVibGljLmxvY2F0b3IsIFtwcm92aW5nS2V5LnRvQnl0ZXMoKSwgVmVyaWZ5aW5nS2V5LmNsYWltVW5ib25kUHVibGljVmVyaWZpZXIoKS50b0J5dGVzKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBpbnNlcnQgaW52YWxpZCBwcm92aW5nIGtleXMgZm9yIGNsYWltX3VuYm9uZF9wdWJsaWNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGZlZV9wcml2YXRlIGZ1bmN0aW9uIGludG8gdGhlIGNhY2hlLiBPbmx5IHRoZSBwcm92aW5nIGtleSBuZWVkc1xuICAgICAqIHRvIGJlIGluc2VydGVkLCB0aGUgdmVyaWZ5aW5nIGtleSBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGJ5IHRoZSBTREsuIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNoZWNrXG4gICAgICogdGhhdCB0aGUga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQgY2hlY2tzdW0gZm9yIGZlZV9wcml2YXRlIGJlZm9yZSBpbnNlcnRpbmcgdGhlbSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aW5nS2V5XG4gICAgICovXG4gICAgaW5zZXJ0RmVlUHJpdmF0ZUtleXMocHJvdmluZ0tleSkge1xuICAgICAgICBpZiAocHJvdmluZ0tleS5pc0ZlZVByaXZhdGVQcm92ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3ByaXZhdGUubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkuZmVlUHJpdmF0ZVZlcmlmaWVyKCkudG9CeXRlcygpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gaW5zZXJ0IGludmFsaWQgcHJvdmluZyBrZXlzIGZvciBmZWVfcHJpdmF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgZmVlX3B1YmxpYyBmdW5jdGlvbiBpbnRvIHRoZSBjYWNoZS4gT25seSB0aGUgcHJvdmluZyBrZXkgbmVlZHNcbiAgICAgKiB0byBiZSBpbnNlcnRlZCwgdGhlIHZlcmlmeWluZyBrZXkgaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZCBieSB0aGUgU0RLLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjaGVja1xuICAgICAqIHRoYXQgdGhlIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIGNoZWNrc3VtIGZvciBmZWVfcHVibGljIGJlZm9yZSBpbnNlcnRpbmcgdGhlbSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aW5nS2V5XG4gICAgICovXG4gICAgaW5zZXJ0RmVlUHVibGljS2V5cyhwcm92aW5nS2V5KSB7XG4gICAgICAgIGlmIChwcm92aW5nS2V5LmlzRmVlUHVibGljUHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLmZlZV9wdWJsaWMubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkuZmVlUHVibGljVmVyaWZpZXIoKS50b0J5dGVzKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBpbnNlcnQgaW52YWxpZCBwcm92aW5nIGtleXMgZm9yIGZlZV9wdWJsaWNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGpvaW4gZnVuY3Rpb24gaW50byB0aGUgY2FjaGUuIE9ubHkgdGhlIHByb3Zpbmcga2V5IG5lZWRzXG4gICAgICogdG8gYmUgaW5zZXJ0ZWQsIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgYnkgdGhlIFNESy4gVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoZSBrZXlzIG1hdGNoIHRoZSBleHBlY3RlZCBjaGVja3N1bSBmb3Igam9pbiBiZWZvcmUgaW5zZXJ0aW5nIHRoZW0gaW50byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmluZ0tleVxuICAgICAqL1xuICAgIGluc2VydEpvaW5LZXlzKHByb3ZpbmdLZXkpIHtcbiAgICAgICAgaWYgKHByb3ZpbmdLZXkuaXNKb2luUHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLmpvaW4ubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkuam9pblZlcmlmaWVyKCkudG9CeXRlcygpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gaW5zZXJ0IGludmFsaWQgcHJvdmluZyBrZXlzIGZvciBqb2luXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBzZXRfdmFsaWRhdG9yX3N0YXRlIGZ1bmN0aW9uIGludG8gdGhlIGNhY2hlLiBPbmx5IHRoZSBwcm92aW5nIGtleSBuZWVkc1xuICAgICAqIHRvIGJlIGluc2VydGVkLCB0aGUgdmVyaWZ5aW5nIGtleSBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGJ5IHRoZSBTREsuIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNoZWNrXG4gICAgICogdGhhdCB0aGUga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQgY2hlY2tzdW0gZm9yIHNldF92YWxpZGF0b3Jfc3RhdGUgYmVmb3JlIGluc2VydGluZyB0aGVtIGludG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpbmdLZXlcbiAgICAgKi9cbiAgICBpbnNlcnRTZXRWYWxpZGF0b3JTdGF0ZUtleXMocHJvdmluZ0tleSkge1xuICAgICAgICBpZiAocHJvdmluZ0tleS5pc1NldFZhbGlkYXRvclN0YXRlUHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLnNldF92YWxpZGF0b3Jfc3RhdGUubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkuc2V0VmFsaWRhdG9yU3RhdGVWZXJpZmllcigpLnRvQnl0ZXMoKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGluc2VydCBpbnZhbGlkIHByb3Zpbmcga2V5cyBmb3Igc2V0X3ZhbGlkYXRvcl9zdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgc3BsaXQgZnVuY3Rpb24gaW50byB0aGUgY2FjaGUuIE9ubHkgdGhlIHByb3Zpbmcga2V5IG5lZWRzXG4gICAgICogdG8gYmUgaW5zZXJ0ZWQsIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgYnkgdGhlIFNESy4gVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoZSBrZXlzIG1hdGNoIHRoZSBleHBlY3RlZCBjaGVja3N1bSBmb3Igc3BsaXQgYmVmb3JlIGluc2VydGluZyB0aGVtIGludG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpbmdLZXlcbiAgICAgKi9cbiAgICBpbnNlcnRTcGxpdEtleXMocHJvdmluZ0tleSkge1xuICAgICAgICBpZiAocHJvdmluZ0tleS5pc1NwbGl0UHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLnNwbGl0LmxvY2F0b3IsIFtwcm92aW5nS2V5LnRvQnl0ZXMoKSwgVmVyaWZ5aW5nS2V5LnNwbGl0VmVyaWZpZXIoKS50b0J5dGVzKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBpbnNlcnQgaW52YWxpZCBwcm92aW5nIGtleXMgZm9yIHNwbGl0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSB0cmFuc2Zlcl9wcml2YXRlIGZ1bmN0aW9uIGludG8gdGhlIGNhY2hlLiBPbmx5IHRoZSBwcm92aW5nIGtleSBuZWVkc1xuICAgICAqIHRvIGJlIGluc2VydGVkLCB0aGUgdmVyaWZ5aW5nIGtleSBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkIGJ5IHRoZSBTREsuIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNoZWNrXG4gICAgICogdGhhdCB0aGUga2V5cyBtYXRjaCB0aGUgZXhwZWN0ZWQgY2hlY2tzdW0gZm9yIHRyYW5zZmVyX3ByaXZhdGUgYmVmb3JlIGluc2VydGluZyB0aGVtIGludG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpbmdLZXlcbiAgICAgKi9cbiAgICBpbnNlcnRUcmFuc2ZlclByaXZhdGVLZXlzKHByb3ZpbmdLZXkpIHtcbiAgICAgICAgaWYgKHByb3ZpbmdLZXkuaXNUcmFuc2ZlclByaXZhdGVQcm92ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHJpdmF0ZS5sb2NhdG9yLCBbcHJvdmluZ0tleS50b0J5dGVzKCksIFZlcmlmeWluZ0tleS50cmFuc2ZlclByaXZhdGVWZXJpZmllcigpLnRvQnl0ZXMoKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGluc2VydCBpbnZhbGlkIHByb3Zpbmcga2V5cyBmb3IgdHJhbnNmZXJfcHJpdmF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgdHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWMgZnVuY3Rpb24gaW50byB0aGUgY2FjaGUuIE9ubHkgdGhlIHByb3Zpbmcga2V5IG5lZWRzXG4gICAgICogdG8gYmUgaW5zZXJ0ZWQsIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgYnkgdGhlIFNESy4gVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoZSBrZXlzIG1hdGNoIHRoZSBleHBlY3RlZCBjaGVja3N1bSBmb3IgdHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWMgYmVmb3JlIGluc2VydGluZyB0aGVtIGludG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpbmdLZXlcbiAgICAgKi9cbiAgICBpbnNlcnRUcmFuc2ZlclByaXZhdGVUb1B1YmxpY0tleXMocHJvdmluZ0tleSkge1xuICAgICAgICBpZiAocHJvdmluZ0tleS5pc1RyYW5zZmVyUHJpdmF0ZVRvUHVibGljUHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljLmxvY2F0b3IsIFtwcm92aW5nS2V5LnRvQnl0ZXMoKSwgVmVyaWZ5aW5nS2V5LnRyYW5zZmVyUHJpdmF0ZVRvUHVibGljVmVyaWZpZXIoKS50b0J5dGVzKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBpbnNlcnQgaW52YWxpZCBwcm92aW5nIGtleXMgZm9yIHRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWMgZnVuY3Rpb24gaW50byB0aGUgY2FjaGUuIE9ubHkgdGhlIHByb3Zpbmcga2V5IG5lZWRzXG4gICAgICogdG8gYmUgaW5zZXJ0ZWQsIHRoZSB2ZXJpZnlpbmcga2V5IGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgYnkgdGhlIFNESy4gVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2hlY2tcbiAgICAgKiB0aGF0IHRoZSBrZXlzIG1hdGNoIHRoZSBleHBlY3RlZCBjaGVja3N1bSBmb3IgdHJhbnNmZXJfcHVibGljIGJlZm9yZSBpbnNlcnRpbmcgdGhlbSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aW5nS2V5XG4gICAgICovXG4gICAgaW5zZXJ0VHJhbnNmZXJQdWJsaWNLZXlzKHByb3ZpbmdLZXkpIHtcbiAgICAgICAgaWYgKHByb3ZpbmdLZXkuaXNUcmFuc2ZlclB1YmxpY1Byb3ZlcigpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wdWJsaWMubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkudHJhbnNmZXJQdWJsaWNWZXJpZmllcigpLnRvQnl0ZXMoKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGluc2VydCBpbnZhbGlkIHByb3Zpbmcga2V5cyBmb3IgdHJhbnNmZXJfcHVibGljXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSB0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZSBmdW5jdGlvbiBpbnRvIHRoZSBjYWNoZS4gT25seSB0aGUgcHJvdmluZyBrZXkgbmVlZHNcbiAgICAgKiB0byBiZSBpbnNlcnRlZCwgdGhlIHZlcmlmeWluZyBrZXkgaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZCBieSB0aGUgU0RLLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjaGVja1xuICAgICAqIHRoYXQgdGhlIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIGNoZWNrc3VtIGZvciB0cmFuc2Zlcl9wdWJsaWNfdG9fcHJpdmF0ZSBiZWZvcmUgaW5zZXJ0aW5nIHRoZW0gaW50byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmluZ0tleVxuICAgICAqL1xuICAgIGluc2VydFRyYW5zZmVyUHVibGljVG9Qcml2YXRlS2V5cyhwcm92aW5nS2V5KSB7XG4gICAgICAgIGlmIChwcm92aW5nS2V5LmlzVHJhbnNmZXJQdWJsaWNUb1ByaXZhdGVQcm92ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGUubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkudHJhbnNmZXJQdWJsaWNUb1ByaXZhdGVWZXJpZmllcigpLnRvQnl0ZXMoKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGluc2VydCBpbnZhbGlkIHByb3Zpbmcga2V5cyBmb3IgdHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0VW5ib25kUHVibGljS2V5cyhwcm92aW5nS2V5KSB7XG4gICAgICAgIGlmIChwcm92aW5nS2V5LmlzVW5ib25kUHVibGljUHJvdmVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLnVuYm9uZF9wdWJsaWMubG9jYXRvciwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCBWZXJpZnlpbmdLZXkudW5ib25kUHVibGljVmVyaWZpZXIoKS50b0J5dGVzKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBpbnNlcnQgaW52YWxpZCBwcm92aW5nIGtleXMgZm9yIHVuYm9uZF9wdWJsaWNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQSByZWNvcmQgcHJvdmlkZXIgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIHRoZSBvZmZpY2lhbCBBbGVvIEFQSSB0byBmaW5kIHJlY29yZHMgZm9yIHVzYWdlIGluIHByb2dyYW0gZXhlY3V0aW9uIGFuZFxuICogZGVwbG95bWVudCwgd2FsbGV0IGZ1bmN0aW9uYWxpdHksIGFuZCBvdGhlciB1c2UgY2FzZXMuXG4gKi9cbmNsYXNzIE5ldHdvcmtSZWNvcmRQcm92aWRlciB7XG4gICAgYWNjb3VudDtcbiAgICBuZXR3b3JrQ2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGFjY291bnQsIG5ldHdvcmtDbGllbnQpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ2xpZW50ID0gbmV0d29ya0NsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhY2NvdW50IHVzZWQgdG8gc2VhcmNoIGZvciByZWNvcmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FjY291bnR9IGFjY291bnQgVGhlIGFjY291bnQgdG8gdXNlIGZvciBzZWFyY2hpbmcgZm9yIHJlY29yZHNcbiAgICAgKi9cbiAgICBzZXRBY2NvdW50KGFjY291bnQpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIGxpc3Qgb2YgY3JlZGl0IHJlY29yZHMgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBtaWNyb2NyZWRpdHMgYnkgdmlhIHRoZSBvZmZpY2lhbCBBbGVvIEFQSVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gbWljcm9jcmVkaXRzIFRoZSBudW1iZXIgb2YgbWljcm9jcmVkaXRzIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVuc3BlbnQgV2hldGhlciBvciBub3QgdGhlIHJlY29yZCBpcyB1bnNwZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbm9uY2VzIE5vbmNlcyBvZiByZWNvcmRzIGFscmVhZHkgZm91bmQgc28gdGhhdCB0aGV5IGFyZSBub3QgZm91bmQgYWdhaW5cbiAgICAgKiBAcGFyYW0ge1JlY29yZFNlYXJjaFBhcmFtc30gc2VhcmNoUGFyYW1ldGVycyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlY29yZFBsYWludGV4dD59IFRoZSByZWNvcmQgaWYgZm91bmQsIG90aGVyd2lzZSBhbiBlcnJvclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyXG4gICAgICogY29uc3QgbmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBjb25zdCByZWNvcmRQcm92aWRlciA9IG5ldyBOZXR3b3JrUmVjb3JkUHJvdmlkZXIoYWNjb3VudCwgbmV0d29ya0NsaWVudCk7XG4gICAgICpcbiAgICAgKiAvLyBUaGUgcmVjb3JkIHByb3ZpZGVyIGNhbiBiZSB1c2VkIHRvIGZpbmQgcmVjb3JkcyB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIG1pY3JvY3JlZGl0c1xuICAgICAqIGNvbnN0IHJlY29yZCA9IGF3YWl0IHJlY29yZFByb3ZpZGVyLmZpbmRDcmVkaXRzUmVjb3JkKDUwMDAsIHRydWUsIFtdKTtcbiAgICAgKlxuICAgICAqIC8vIFdoZW4gYSByZWNvcmQgaXMgZm91bmQgYnV0IG5vdCB5ZXQgdXNlZCwgaXQncyBub25jZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG5vbmNlcyBwYXJhbWV0ZXIgc28gdGhhdCBpdCBpcyBub3RcbiAgICAgKiAvLyBmb3VuZCBhZ2FpbiBpZiBhIHN1YnNlcXVlbnQgc2VhcmNoIGlzIHBlcmZvcm1lZFxuICAgICAqIGNvbnN0IHJlY29yZHMgPSBhd2FpdCByZWNvcmRQcm92aWRlci5maW5kQ3JlZGl0c1JlY29yZHMoNTAwMCwgdHJ1ZSwgW3JlY29yZC5ub25jZSgpXSk7XG4gICAgICpcbiAgICAgKiAvLyBXaGVuIHRoZSBwcm9ncmFtIG1hbmFnZXIgaXMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgcmVjb3JkIHByb3ZpZGVyIGl0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGF1dG9tYXRpY2FsbHkgZmluZFxuICAgICAqIC8vIGZlZSByZWNvcmRzIGFuZCBhbW91bnQgcmVjb3JkcyBmb3IgdmFsdWUgdHJhbnNmZXJzIHNvIHRoYXQgdGhleSBkbyBub3QgbmVlZCB0byBiZSBzcGVjaWZpZWQgbWFudWFsbHlcbiAgICAgKiBjb25zdCBwcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcihcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiLCBrZXlQcm92aWRlciwgcmVjb3JkUHJvdmlkZXIpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnRyYW5zZmVyKDEsIFwiYWxlbzE2NnE2d3c2Njg4Y3VnN3F4d2U3bmhjdGpweW15ZHd6eTJoN3JzY2ZtYXRxbWZ3bmp2Z2dxY2FkMGF0XCIsIFwicHVibGljXCIsIDAuNSk7XG4gICAgICpcbiAgICAgKiAqL1xuICAgIGFzeW5jIGZpbmRDcmVkaXRzUmVjb3JkcyhtaWNyb2NyZWRpdHMsIHVuc3BlbnQsIG5vbmNlcywgc2VhcmNoUGFyYW1ldGVycykge1xuICAgICAgICBsZXQgc3RhcnRIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgZW5kSGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IG1heEFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNlYXJjaFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChcInN0YXJ0SGVpZ2h0XCIgaW4gc2VhcmNoUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2VhcmNoUGFyYW1ldGVyc1tcImVuZEhlaWdodFwiXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRIZWlnaHQgPSBzZWFyY2hQYXJhbWV0ZXJzW1wic3RhcnRIZWlnaHRcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJlbmRIZWlnaHRcIiBpbiBzZWFyY2hQYXJhbWV0ZXJzICYmIHR5cGVvZiBzZWFyY2hQYXJhbWV0ZXJzW1wiZW5kSGVpZ2h0XCJdID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBlbmRIZWlnaHQgPSBzZWFyY2hQYXJhbWV0ZXJzW1wiZW5kSGVpZ2h0XCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiYW1vdW50c1wiIGluIHNlYXJjaFBhcmFtZXRlcnMgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hQYXJhbWV0ZXJzW1wiYW1vdW50c1wiXSkgJiYgc2VhcmNoUGFyYW1ldGVyc1tcImFtb3VudFwiXS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIG1pY3JvY3JlZGl0cyA9IHNlYXJjaFBhcmFtZXRlcnNbXCJhbW91bnRzXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwibWF4QW1vdW50XCIgaW4gc2VhcmNoUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2VhcmNoUGFyYW1ldGVyc1tcIm1heEFtb3VudFwiXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWF4QW1vdW50ID0gc2VhcmNoUGFyYW1ldGVyc1tcIm1heEFtb3VudFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInVuc3BlbnRcIiBpbiBzZWFyY2hQYXJhbWV0ZXJzICYmIHR5cGVvZiBzZWFyY2hQYXJhbWV0ZXJzW1widW5zcGVudFwiXSA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHVuc3BlbnQgPSBzZWFyY2hQYXJhbWV0ZXJzW1widW5zcGVudFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZW5kIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0XG4gICAgICAgIGlmIChlbmRIZWlnaHQgPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LmdldExhdGVzdEhlaWdodCgpO1xuICAgICAgICAgICAgZW5kSGVpZ2h0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdGFydCBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHRoZSBlbmQgaGVpZ2h0LCB0aHJvdyBhbiBlcnJvclxuICAgICAgICBpZiAoc3RhcnRIZWlnaHQgPj0gZW5kSGVpZ2h0KSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhcIlN0YXJ0IGhlaWdodCBtdXN0IGJlIGxlc3MgdGhhbiBlbmQgaGVpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuZmluZFJlY29yZHMoc3RhcnRIZWlnaHQsIGVuZEhlaWdodCwgdW5zcGVudCwgW1wiY3JlZGl0cy5hbGVvXCJdLCBtaWNyb2NyZWRpdHMsIG1heEFtb3VudCwgbm9uY2VzLCB0aGlzLmFjY291bnQucHJpdmF0ZUtleSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIGNyZWRpdCByZWNvcmQgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBtaWNyb2NyZWRpdHMgYnkgdmlhIHRoZSBvZmZpY2lhbCBBbGVvIEFQSVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pY3JvY3JlZGl0cyBUaGUgbnVtYmVyIG9mIG1pY3JvY3JlZGl0cyB0byBzZWFyY2ggZm9yXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1bnNwZW50IFdoZXRoZXIgb3Igbm90IHRoZSByZWNvcmQgaXMgdW5zcGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG5vbmNlcyBOb25jZXMgb2YgcmVjb3JkcyBhbHJlYWR5IGZvdW5kIHNvIHRoYXQgdGhleSBhcmUgbm90IGZvdW5kIGFnYWluXG4gICAgICogQHBhcmFtIHtSZWNvcmRTZWFyY2hQYXJhbXN9IHNlYXJjaFBhcmFtZXRlcnMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWNvcmRQbGFpbnRleHQ+fSBUaGUgcmVjb3JkIGlmIGZvdW5kLCBvdGhlcndpc2UgYW4gZXJyb3JcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlclxuICAgICAqIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBuZXcgQWxlb05ldHdvcmtDbGllbnQoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIik7XG4gICAgICogY29uc3Qga2V5UHJvdmlkZXIgPSBuZXcgQWxlb0tleVByb3ZpZGVyKCk7XG4gICAgICogY29uc3QgcmVjb3JkUHJvdmlkZXIgPSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyKGFjY291bnQsIG5ldHdvcmtDbGllbnQpO1xuICAgICAqXG4gICAgICogLy8gVGhlIHJlY29yZCBwcm92aWRlciBjYW4gYmUgdXNlZCB0byBmaW5kIHJlY29yZHMgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBtaWNyb2NyZWRpdHNcbiAgICAgKiBjb25zdCByZWNvcmQgPSBhd2FpdCByZWNvcmRQcm92aWRlci5maW5kQ3JlZGl0c1JlY29yZCg1MDAwLCB0cnVlLCBbXSk7XG4gICAgICpcbiAgICAgKiAvLyBXaGVuIGEgcmVjb3JkIGlzIGZvdW5kIGJ1dCBub3QgeWV0IHVzZWQsIGl0J3Mgbm9uY2Ugc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBub25jZXMgcGFyYW1ldGVyIHNvIHRoYXQgaXQgaXMgbm90XG4gICAgICogLy8gZm91bmQgYWdhaW4gaWYgYSBzdWJzZXF1ZW50IHNlYXJjaCBpcyBwZXJmb3JtZWRcbiAgICAgKiBjb25zdCByZWNvcmRzID0gYXdhaXQgcmVjb3JkUHJvdmlkZXIuZmluZENyZWRpdHNSZWNvcmRzKDUwMDAsIHRydWUsIFtyZWNvcmQubm9uY2UoKV0pO1xuICAgICAqXG4gICAgICogLy8gV2hlbiB0aGUgcHJvZ3JhbSBtYW5hZ2VyIGlzIGluaXRpYWxpemVkIHdpdGggdGhlIHJlY29yZCBwcm92aWRlciBpdCB3aWxsIGJlIHVzZWQgdG8gZmluZCBhdXRvbWF0aWNhbGx5IGZpbmRcbiAgICAgKiAvLyBmZWUgcmVjb3JkcyBhbmQgYW1vdW50IHJlY29yZHMgZm9yIHZhbHVlIHRyYW5zZmVycyBzbyB0aGF0IHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgc3BlY2lmaWVkIG1hbnVhbGx5XG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKiBwcm9ncmFtTWFuYWdlci50cmFuc2ZlcigxLCBcImFsZW8xNjZxNnd3NjY4OGN1ZzdxeHdlN25oY3RqcHlteWR3enkyaDdyc2NmbWF0cW1md25qdmdncWNhZDBhdFwiLCBcInB1YmxpY1wiLCAwLjUpO1xuICAgICAqL1xuICAgIGFzeW5jIGZpbmRDcmVkaXRzUmVjb3JkKG1pY3JvY3JlZGl0cywgdW5zcGVudCwgbm9uY2VzLCBzZWFyY2hQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlY29yZHMgPSBhd2FpdCB0aGlzLmZpbmRDcmVkaXRzUmVjb3JkcyhbbWljcm9jcmVkaXRzXSwgdW5zcGVudCwgbm9uY2VzLCBzZWFyY2hQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyByZWNvcmRzIGZvdW5kIHdpdGggZXJyb3I6XCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvcmRzICYmIHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlY29yZCBub3QgZm91bmQgd2l0aCBlcnJvcjpcIiwgcmVjb3Jkcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY29yZCBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gYXJiaXRyYXJ5IHJlY29yZC4gV0FSTklORzogVGhpcyBmdW5jdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0IGFuZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRSZWNvcmQodW5zcGVudCwgbm9uY2VzLCBzZWFyY2hQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBtdWx0aXBsZSByZWNvcmRzIGZyb20gYSBzcGVjaWZpZWQgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5kUmVjb3Jkcyh1bnNwZW50LCBub25jZXMsIHNlYXJjaFBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGVuZEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBhbW91bnRzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF4QW1vdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHJvZ3JhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzZWFyY2hQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoXCJzdGFydEhlaWdodFwiIGluIHNlYXJjaFBhcmFtZXRlcnMgJiYgdHlwZW9mIHNlYXJjaFBhcmFtZXRlcnNbXCJlbmRIZWlnaHRcIl0gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHN0YXJ0SGVpZ2h0ID0gc2VhcmNoUGFyYW1ldGVyc1tcInN0YXJ0SGVpZ2h0XCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiZW5kSGVpZ2h0XCIgaW4gc2VhcmNoUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2VhcmNoUGFyYW1ldGVyc1tcImVuZEhlaWdodFwiXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZW5kSGVpZ2h0ID0gc2VhcmNoUGFyYW1ldGVyc1tcImVuZEhlaWdodFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImFtb3VudHNcIiBpbiBzZWFyY2hQYXJhbWV0ZXJzICYmIEFycmF5LmlzQXJyYXkoc2VhcmNoUGFyYW1ldGVyc1tcImFtb3VudHNcIl0pICYmIHNlYXJjaFBhcmFtZXRlcnNbXCJhbW91bnRzXCJdLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50cyA9IHNlYXJjaFBhcmFtZXRlcnNbXCJhbW91bnRzXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwibWF4QW1vdW50XCIgaW4gc2VhcmNoUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2VhcmNoUGFyYW1ldGVyc1tcIm1heEFtb3VudFwiXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWF4QW1vdW50ID0gc2VhcmNoUGFyYW1ldGVyc1tcIm1heEFtb3VudFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcIm5vbmNlc1wiIGluIHNlYXJjaFBhcmFtZXRlcnMgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hQYXJhbWV0ZXJzW1wibm9uY2VzXCJdKSAmJiBzZWFyY2hQYXJhbWV0ZXJzW1wibm9uY2VzXCJdLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBub25jZXMgPSBzZWFyY2hQYXJhbWV0ZXJzW1wibm9uY2VzXCJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwicHJvZ3JhbVwiIGluIHNlYXJjaFBhcmFtZXRlcnMgJiYgdHlwZW9mIHNlYXJjaFBhcmFtZXRlcnNbXCJwcm9ncmFtXCJdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtcyA9IFtzZWFyY2hQYXJhbWV0ZXJzW1wicHJvZ3JhbVwiXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJwcm9ncmFtc1wiIGluIHNlYXJjaFBhcmFtZXRlcnMgJiYgQXJyYXkuaXNBcnJheShzZWFyY2hQYXJhbWV0ZXJzW1wicHJvZ3JhbXNcIl0pICYmIHNlYXJjaFBhcmFtZXRlcnNbXCJwcm9ncmFtc1wiXS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbXMgPSBzZWFyY2hQYXJhbWV0ZXJzW1wicHJvZ3JhbXNcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ1bnNwZW50XCIgaW4gc2VhcmNoUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2VhcmNoUGFyYW1ldGVyc1tcInVuc3BlbnRcIl0gPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB1bnNwZW50ID0gc2VhcmNoUGFyYW1ldGVyc1tcInVuc3BlbnRcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGVuZCBoZWlnaHQgaXMgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodFxuICAgICAgICBpZiAoZW5kSGVpZ2h0ID09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGF3YWl0IHRoaXMubmV0d29ya0NsaWVudC5nZXRMYXRlc3RIZWlnaHQoKTtcbiAgICAgICAgICAgIGVuZEhlaWdodCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3RhcnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgZW5kIGhlaWdodCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgaWYgKHN0YXJ0SGVpZ2h0ID49IGVuZEhlaWdodCkge1xuICAgICAgICAgICAgbG9nQW5kVGhyb3coXCJTdGFydCBoZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gZW5kIGhlaWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LmZpbmRSZWNvcmRzKHN0YXJ0SGVpZ2h0LCBlbmRIZWlnaHQsIHVuc3BlbnQsIHByb2dyYW1zLCBhbW91bnRzLCBtYXhBbW91bnQsIG5vbmNlcywgdGhpcy5hY2NvdW50LnByaXZhdGVLZXkoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBCbG9ja0hlaWdodFNlYXJjaCBpcyBhIFJlY29yZFNlYXJjaFBhcmFtcyBpbXBsZW1lbnRhdGlvbiB0aGF0IGFsbG93cyBmb3Igc2VhcmNoaW5nIGZvciByZWNvcmRzIHdpdGhpbiBhIGdpdmVuXG4gKiBibG9jayBoZWlnaHQgcmFuZ2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhIG5ldyBCbG9ja0hlaWdodFNlYXJjaFxuICogY29uc3QgcGFyYW1zID0gbmV3IEJsb2NrSGVpZ2h0U2VhcmNoKDg5OTk1LCA5OTk5NSk7XG4gKlxuICogLy8gQ3JlYXRlIGEgbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlclxuICogY29uc3QgbmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICogY29uc3QgcmVjb3JkUHJvdmlkZXIgPSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyKGFjY291bnQsIG5ldHdvcmtDbGllbnQpO1xuICpcbiAqIC8vIFRoZSByZWNvcmQgcHJvdmlkZXIgY2FuIGJlIHVzZWQgdG8gZmluZCByZWNvcmRzIHdpdGggYSBnaXZlbiBudW1iZXIgb2YgbWljcm9jcmVkaXRzIGFuZCB0aGUgYmxvY2sgaGVpZ2h0IHNlYXJjaFxuICogLy8gY2FuIGJlIHVzZWQgdG8gZmluZCByZWNvcmRzIHdpdGhpbiBhIGdpdmVuIGJsb2NrIGhlaWdodCByYW5nZVxuICogY29uc3QgcmVjb3JkID0gYXdhaXQgcmVjb3JkUHJvdmlkZXIuZmluZENyZWRpdHNSZWNvcmQoNTAwMCwgdHJ1ZSwgW10sIHBhcmFtcyk7XG4gKlxuICovXG5jbGFzcyBCbG9ja0hlaWdodFNlYXJjaCB7XG4gICAgc3RhcnRIZWlnaHQ7XG4gICAgZW5kSGVpZ2h0O1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0SGVpZ2h0LCBlbmRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zdGFydEhlaWdodCA9IHN0YXJ0SGVpZ2h0O1xuICAgICAgICB0aGlzLmVuZEhlaWdodCA9IGVuZEhlaWdodDtcbiAgICB9XG59XG5cbi8vIEV4cGVyaW1lbnRhbCBleGFtcGxlIHdoZXJlIFNESyBtYW5hZ2VzIHdvcmtlclxubGV0IHNpbmdsZXRvbldvcmtlciA9IG51bGw7XG5jb25zdCBjcmVhdGVBbGVvV29ya2VyID0gKCkgPT4ge1xuICAgIGlmICghc2luZ2xldG9uV29ya2VyKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTChcIndvcmtlci5qc1wiLCBpbXBvcnQubWV0YS51cmwpLCB7XG4gICAgICAgICAgICB0eXBlOiBcIm1vZHVsZVwiLFxuICAgICAgICB9KTtcbiAgICAgICAgc2luZ2xldG9uV29ya2VyID0gd3JhcCh3b3JrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uV29ya2VyO1xufTtcblxuLy8gQFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgbm8gbG9uZ2VyIG5lZWRlZCwgcmVtb3ZlIGl0LlxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVdhc20oKSB7XG4gICAgY29uc29sZS53YXJuKFwiaW5pdGlhbGl6ZVdhc20gaXMgZGVwcmVjYXRlZCwgeW91IG5vIGxvbmdlciBuZWVkIHRvIHVzZSBpdFwiKTtcbn1cblxuZXhwb3J0IHsgQWNjb3VudCwgQmxvY2tIZWlnaHRTZWFyY2gsIENSRURJVFNfUFJPR1JBTV9LRVlTLCBOZXR3b3JrUmVjb3JkUHJvdmlkZXIsIE9mZmxpbmVLZXlQcm92aWRlciwgT2ZmbGluZVNlYXJjaFBhcmFtcywgUFJJVkFURV9UT19QVUJMSUNfVFJBTlNGRVIsIFBSSVZBVEVfVFJBTlNGRVIsIFBVQkxJQ19UT19QUklWQVRFX1RSQU5TRkVSLCBQVUJMSUNfVFJBTlNGRVIsIFBVQkxJQ19UUkFOU0ZFUl9BU19TSUdORVIsIGNyZWF0ZUFsZW9Xb3JrZXIsIGluaXRpYWxpemVXYXNtLCBsb2dBbmRUaHJvdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js?3032":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_proposals_json_parse_with_source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/proposals/json-parse-with-source.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/proposals/json-parse-with-source.js\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var mime_lite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mime/lite */ \"(ssr)/./node_modules/.pnpm/mime@4.0.6/node_modules/mime/dist/src/index_lite.js\");\n/* harmony import */ var xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xmlhttprequest-ssl */ \"(ssr)/./node_modules/.pnpm/xmlhttprequest-ssl@3.1.0/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\n/* harmony import */ var sync_request__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sync-request */ \"(ssr)/./node_modules/.pnpm/sync-request@6.1.0/node_modules/sync-request/lib/index.js\");\n/* harmony import */ var node_worker_threads__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:os */ \"node:os\");\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"(ssr)/./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\nif (globalThis.crypto == null) {\n    globalThis.crypto = node_crypto__WEBPACK_IMPORTED_MODULE_1__.webcrypto;\n}\n\nconst oldFetch = globalThis.fetch;\nlet supports = null;\nasync function checkFetch() {\n    try {\n        await oldFetch(new URL(\"file:\"));\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function supportsFetch() {\n    if (supports === null) {\n        supports = checkFetch();\n    }\n    return await supports;\n}\n// We always polyfill fetch because Node's fetch doesn't support file URLs.\nglobalThis.fetch = async function (resource, options) {\n    const request = new Request(resource, options);\n    const url = new URL(request.url);\n    if (!(await supportsFetch()) && url.protocol === \"file:\") {\n        const readStream = node_fs__WEBPACK_IMPORTED_MODULE_2__.createReadStream(url);\n        const headers = {};\n        const type = mime_lite__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getType(url.pathname);\n        if (type) {\n            headers[\"Content-Type\"] = type;\n        }\n        return new Response(readStream, {\n            status: 200,\n            statusText: \"OK\",\n            headers,\n        });\n    }\n    else {\n        return await oldFetch(request);\n    }\n};\n\n// @ts-ignore\nif (globalThis.XMLHttpRequest == null) {\n    globalThis.XMLHttpRequest = class extends xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_4__.XMLHttpRequest {\n        // We have to override the methods inside of the `constructor`\n        // because `xmlhttprequest-ssl` doesn't use a regular class,\n        // instead it defines all of the methods inside of the constructor.\n        constructor(...args) {\n            super(...args);\n            const open = this.open;\n            const send = this.send;\n            let _async = true;\n            let _url = null;\n            let _mime = \"text/xml\";\n            function reset() {\n                _async = true;\n                _url = null;\n                _mime = \"text/xml\";\n            }\n            this.open = function (method, url, async, user, password) {\n                // Special behavior for synchronous requests\n                if (method === \"GET\" && !async && !user && !password) {\n                    _async = false;\n                    _url = url;\n                    // Default to the normal polyfill for async requests\n                }\n                else {\n                    reset();\n                    return open.call(this, method, url, async, user, password);\n                }\n            };\n            this.send = function (data) {\n                if (_async) {\n                    return send.call(this, data);\n                    // Use `sync-request` for synchronous requests.\n                }\n                else {\n                    const response = sync_request__WEBPACK_IMPORTED_MODULE_5__(\"GET\", _url, {\n                        headers: {\n                            \"Content-Type\": _mime,\n                        }\n                    });\n                    const buffer = response.body.buffer;\n                    const responseText = new TextDecoder(\"iso-8859-5\", { fatal: true }).decode(buffer);\n                    this.status = 200;\n                    this.response = this.responseText = responseText;\n                    reset();\n                }\n            };\n            this.overrideMimeType = function (mime) {\n                _mime = mime;\n            };\n        }\n    };\n}\n\n// This is technically not a part of the Worker polyfill,\n// but Workers are used for multi-threading, so this is often\n// needed when writing Worker code.\nif (globalThis.navigator == null) {\n    globalThis.navigator = {\n        hardwareConcurrency: node_os__WEBPACK_IMPORTED_MODULE_7__.cpus().length,\n    };\n}\nif (globalThis.Worker == null) {\n    globalThis.Worker = class Worker extends EventTarget {\n        _worker;\n        constructor(url, options) {\n            super();\n            if (url instanceof URL) {\n                if (url.protocol !== \"file:\") {\n                    throw new Error(\"Worker only supports file: URLs\");\n                }\n                url = url.href;\n            }\n            else {\n                throw new Error(\"Filepaths are unreliable, use `new URL(\\\"...\\\", import.meta.url)` instead.\");\n            }\n            if (!options || options.type !== \"module\") {\n                throw new Error(\"Workers must use \\`type: \\\"module\\\"\\`\");\n            }\n            const code = `\n                import(\"node:worker_threads\")\n                    .then(({ workerData }) => {\n                        return import(workerData.polyfill)\n                            .then(() => import(workerData.url))\n                    })\n                    .catch((e) => {\n                        // TODO maybe it should send a message to the parent?\n                        console.error(e.stack);\n                    });\n            `;\n            this._worker = new node_worker_threads__WEBPACK_IMPORTED_MODULE_6__.Worker(code, {\n                eval: true,\n                workerData: {\n                    url,\n                    polyfill: /* asset import */ new __webpack_require__.U(__webpack_require__(/*! node-polyfill.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js?8a58\")).href,\n                },\n            });\n            this._worker.on(\"message\", (data) => {\n                this.dispatchEvent(new MessageEvent(\"message\", { data }));\n            });\n            this._worker.on(\"messageerror\", (error) => {\n                throw new Error(\"UNIMPLEMENTED\");\n            });\n            this._worker.on(\"error\", (error) => {\n                // TODO attach the error to the event somehow\n                const event = new Event(\"error\");\n                this.dispatchEvent(event);\n            });\n        }\n        set onmessage(f) {\n            throw new Error(\"UNIMPLEMENTED\");\n        }\n        set onmessageerror(f) {\n            throw new Error(\"UNIMPLEMENTED\");\n        }\n        set onerror(f) {\n            throw new Error(\"UNIMPLEMENTED\");\n        }\n        postMessage(value, transfer) {\n            this._worker.postMessage(value, transfer);\n        }\n        terminate() {\n            this._worker.terminate();\n        }\n        // This is Node-specific, it allows the process to exit\n        // even if the Worker is still running.\n        unref() {\n            this._worker.unref();\n        }\n    };\n}\nif (!node_worker_threads__WEBPACK_IMPORTED_MODULE_6__.isMainThread) {\n    const globals = globalThis;\n    // This is used to create the onmessage, onmessageerror, and onerror setters\n    const makeSetter = (prop, event) => {\n        let oldvalue;\n        Object.defineProperty(globals, prop, {\n            get() {\n                return oldvalue;\n            },\n            set(value) {\n                if (oldvalue) {\n                    globals.removeEventListener(event, oldvalue);\n                }\n                oldvalue = value;\n                if (oldvalue) {\n                    globals.addEventListener(event, oldvalue);\n                }\n            },\n        });\n    };\n    // This makes sure that `f` is only run once\n    const memoize = (f) => {\n        let run = false;\n        return () => {\n            if (!run) {\n                run = true;\n                f();\n            }\n        };\n    };\n    // We only start listening for messages / errors when the worker calls addEventListener\n    const startOnMessage = memoize(() => {\n        node_worker_threads__WEBPACK_IMPORTED_MODULE_6__.parentPort.on(\"message\", (data) => {\n            workerEvents.dispatchEvent(new MessageEvent(\"message\", { data }));\n        });\n    });\n    const startOnMessageError = memoize(() => {\n        throw new Error(\"UNIMPLEMENTED\");\n    });\n    const startOnError = memoize(() => {\n        node_worker_threads__WEBPACK_IMPORTED_MODULE_6__.parentPort.on(\"error\", (data) => {\n            workerEvents.dispatchEvent(new Event(\"error\"));\n        });\n    });\n    // Node workers don't have top-level events, so we have to make our own\n    const workerEvents = new EventTarget();\n    globals.close = () => {\n        process.exit();\n    };\n    globals.addEventListener = (type, callback, options) => {\n        workerEvents.addEventListener(type, callback, options);\n        if (type === \"message\") {\n            startOnMessage();\n        }\n        else if (type === \"messageerror\") {\n            startOnMessageError();\n        }\n        else if (type === \"error\") {\n            startOnError();\n        }\n    };\n    globals.removeEventListener = (type, callback, options) => {\n        workerEvents.removeEventListener(type, callback, options);\n    };\n    function postMessage(value, transfer) {\n        node_worker_threads__WEBPACK_IMPORTED_MODULE_6__.parentPort.postMessage(value, transfer);\n    }\n    globals.postMessage = postMessage;\n    makeSetter(\"onmessage\", \"message\");\n    makeSetter(\"onmessageerror\", \"messageerror\");\n    makeSetter(\"onerror\", \"error\");\n}\n\nif (!globalThis.self) {\n    globalThis.self = globalThis;\n}\n//# sourceMappingURL=node-polyfill.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L25vZGUtcG9seWZpbGwuanM/MzAzMiIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFEO0FBQ2I7QUFDVDtBQUNEO0FBQ21CO0FBQ2I7QUFDVztBQUNoQjs7QUFFL0I7QUFDQSx3QkFBd0Isa0RBQVM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQW9CO0FBQy9DO0FBQ0EscUJBQXFCLGlEQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4Qyw4REFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlDQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5Q0FBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLCtCQUErQix1REFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNk1BQTRDO0FBQzFFLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2REFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFrQjtBQUMxQixxRUFBcUUsTUFBTTtBQUMzRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxRQUFRLDJEQUFrQjtBQUMxQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvdXNlcm5hbWUvYWxlby9yYXRlLWxpbWl0aW5nLW51bGxpZmllci9ybG4tbWVzc2FnZS1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L25vZGUtcG9seWZpbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb3JlLWpzL3Byb3Bvc2Fscy9qc29uLXBhcnNlLXdpdGgtc291cmNlLmpzJztcbmltcG9ydCB7IHdlYmNyeXB0byB9IGZyb20gJ25vZGU6Y3J5cHRvJztcbmltcG9ydCAqIGFzICRmcyBmcm9tICdub2RlOmZzJztcbmltcG9ydCAkbWltZSBmcm9tICdtaW1lL2xpdGUnO1xuaW1wb3J0ICR4bWxodHRwcmVxdWVzdCBmcm9tICd4bWxodHRwcmVxdWVzdC1zc2wnO1xuaW1wb3J0ICRyZXF1ZXN0IGZyb20gJ3N5bmMtcmVxdWVzdCc7XG5pbXBvcnQgKiBhcyAkd29ya2VyIGZyb20gJ25vZGU6d29ya2VyX3RocmVhZHMnO1xuaW1wb3J0ICogYXMgJG9zIGZyb20gJ25vZGU6b3MnO1xuXG5pZiAoZ2xvYmFsVGhpcy5jcnlwdG8gPT0gbnVsbCkge1xuICAgIGdsb2JhbFRoaXMuY3J5cHRvID0gd2ViY3J5cHRvO1xufVxuXG5jb25zdCBvbGRGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG5sZXQgc3VwcG9ydHMgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tGZXRjaCgpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBvbGRGZXRjaChuZXcgVVJMKFwiZmlsZTpcIikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHN1cHBvcnRzRmV0Y2goKSB7XG4gICAgaWYgKHN1cHBvcnRzID09PSBudWxsKSB7XG4gICAgICAgIHN1cHBvcnRzID0gY2hlY2tGZXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3VwcG9ydHM7XG59XG4vLyBXZSBhbHdheXMgcG9seWZpbGwgZmV0Y2ggYmVjYXVzZSBOb2RlJ3MgZmV0Y2ggZG9lc24ndCBzdXBwb3J0IGZpbGUgVVJMcy5cbmdsb2JhbFRoaXMuZmV0Y2ggPSBhc3luYyBmdW5jdGlvbiAocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGlmICghKGF3YWl0IHN1cHBvcnRzRmV0Y2goKSkgJiYgdXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9ICRmcy5jcmVhdGVSZWFkU3RyZWFtKHVybCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICRtaW1lLmdldFR5cGUodXJsLnBhdGhuYW1lKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVhZFN0cmVhbSwge1xuICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk9LXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBvbGRGZXRjaChyZXF1ZXN0KTtcbiAgICB9XG59O1xuXG4vLyBAdHMtaWdub3JlXG5pZiAoZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCA9PSBudWxsKSB7XG4gICAgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgJHhtbGh0dHByZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0IHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBvdmVycmlkZSB0aGUgbWV0aG9kcyBpbnNpZGUgb2YgdGhlIGBjb25zdHJ1Y3RvcmBcbiAgICAgICAgLy8gYmVjYXVzZSBgeG1saHR0cHJlcXVlc3Qtc3NsYCBkb2Vzbid0IHVzZSBhIHJlZ3VsYXIgY2xhc3MsXG4gICAgICAgIC8vIGluc3RlYWQgaXQgZGVmaW5lcyBhbGwgb2YgdGhlIG1ldGhvZHMgaW5zaWRlIG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICBjb25zdCBvcGVuID0gdGhpcy5vcGVuO1xuICAgICAgICAgICAgY29uc3Qgc2VuZCA9IHRoaXMuc2VuZDtcbiAgICAgICAgICAgIGxldCBfYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IF91cmwgPSBudWxsO1xuICAgICAgICAgICAgbGV0IF9taW1lID0gXCJ0ZXh0L3htbFwiO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICAgICAgX2FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdXJsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfbWltZSA9IFwidGV4dC94bWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBiZWhhdmlvciBmb3Igc3luY2hyb25vdXMgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiICYmICFhc3luYyAmJiAhdXNlciAmJiAhcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF91cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG5vcm1hbCBwb2x5ZmlsbCBmb3IgYXN5bmMgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZC5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYHN5bmMtcmVxdWVzdGAgZm9yIHN5bmNocm9ub3VzIHJlcXVlc3RzLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAkcmVxdWVzdChcIkdFVFwiLCBfdXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogX21pbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSByZXNwb25zZS5ib2R5LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gbmV3IFRleHREZWNvZGVyKFwiaXNvLTg4NTktNVwiLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlTWltZVR5cGUgPSBmdW5jdGlvbiAobWltZSkge1xuICAgICAgICAgICAgICAgIF9taW1lID0gbWltZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIHRlY2huaWNhbGx5IG5vdCBhIHBhcnQgb2YgdGhlIFdvcmtlciBwb2x5ZmlsbCxcbi8vIGJ1dCBXb3JrZXJzIGFyZSB1c2VkIGZvciBtdWx0aS10aHJlYWRpbmcsIHNvIHRoaXMgaXMgb2Z0ZW5cbi8vIG5lZWRlZCB3aGVuIHdyaXRpbmcgV29ya2VyIGNvZGUuXG5pZiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgPT0gbnVsbCkge1xuICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yID0ge1xuICAgICAgICBoYXJkd2FyZUNvbmN1cnJlbmN5OiAkb3MuY3B1cygpLmxlbmd0aCxcbiAgICB9O1xufVxuaWYgKGdsb2JhbFRoaXMuV29ya2VyID09IG51bGwpIHtcbiAgICBnbG9iYWxUaGlzLldvcmtlciA9IGNsYXNzIFdvcmtlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICAgICAgX3dvcmtlcjtcbiAgICAgICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgIGlmICh1cmwucHJvdG9jb2wgIT09IFwiZmlsZTpcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgb25seSBzdXBwb3J0cyBmaWxlOiBVUkxzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGVwYXRocyBhcmUgdW5yZWxpYWJsZSwgdXNlIGBuZXcgVVJMKFxcXCIuLi5cXFwiLCBpbXBvcnQubWV0YS51cmwpYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnR5cGUgIT09IFwibW9kdWxlXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXJzIG11c3QgdXNlIFxcYHR5cGU6IFxcXCJtb2R1bGVcXFwiXFxgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGBcbiAgICAgICAgICAgICAgICBpbXBvcnQoXCJub2RlOndvcmtlcl90aHJlYWRzXCIpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IHdvcmtlckRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydCh3b3JrZXJEYXRhLnBvbHlmaWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGltcG9ydCh3b3JrZXJEYXRhLnVybCkpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBpdCBzaG91bGQgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHBhcmVudD9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG5ldyAkd29ya2VyLldvcmtlcihjb2RlLCB7XG4gICAgICAgICAgICAgICAgZXZhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3b3JrZXJEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgcG9seWZpbGw6IG5ldyBVUkwoXCJub2RlLXBvbHlmaWxsLmpzXCIsIGltcG9ydC5tZXRhLnVybCkuaHJlZixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oXCJtZXNzYWdlXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHsgZGF0YSB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbihcIm1lc3NhZ2VlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVTklNUExFTUVOVEVEXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGF0dGFjaCB0aGUgZXJyb3IgdG8gdGhlIGV2ZW50IHNvbWVob3dcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgb25tZXNzYWdlKGYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVOSU1QTEVNRU5URURcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IG9ubWVzc2FnZWVycm9yKGYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVOSU1QTEVNRU5URURcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IG9uZXJyb3IoZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVU5JTVBMRU1FTlRFRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwb3N0TWVzc2FnZSh2YWx1ZSwgdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh2YWx1ZSwgdHJhbnNmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIE5vZGUtc3BlY2lmaWMsIGl0IGFsbG93cyB0aGUgcHJvY2VzcyB0byBleGl0XG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIFdvcmtlciBpcyBzdGlsbCBydW5uaW5nLlxuICAgICAgICB1bnJlZigpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci51bnJlZigpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmlmICghJHdvcmtlci5pc01haW5UaHJlYWQpIHtcbiAgICBjb25zdCBnbG9iYWxzID0gZ2xvYmFsVGhpcztcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBvbm1lc3NhZ2UsIG9ubWVzc2FnZWVycm9yLCBhbmQgb25lcnJvciBzZXR0ZXJzXG4gICAgY29uc3QgbWFrZVNldHRlciA9IChwcm9wLCBldmVudCkgPT4ge1xuICAgICAgICBsZXQgb2xkdmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxzLCBwcm9wLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGR2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9sZHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2xkdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2xkdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFscy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbGR2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBgZmAgaXMgb25seSBydW4gb25jZVxuICAgIGNvbnN0IG1lbW9pemUgPSAoZikgPT4ge1xuICAgICAgICBsZXQgcnVuID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgICAgIHJ1biA9IHRydWU7XG4gICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gV2Ugb25seSBzdGFydCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzIC8gZXJyb3JzIHdoZW4gdGhlIHdvcmtlciBjYWxscyBhZGRFdmVudExpc3RlbmVyXG4gICAgY29uc3Qgc3RhcnRPbk1lc3NhZ2UgPSBtZW1vaXplKCgpID0+IHtcbiAgICAgICAgJHdvcmtlci5wYXJlbnRQb3J0Lm9uKFwibWVzc2FnZVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgd29ya2VyRXZlbnRzLmRpc3BhdGNoRXZlbnQobmV3IE1lc3NhZ2VFdmVudChcIm1lc3NhZ2VcIiwgeyBkYXRhIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhcnRPbk1lc3NhZ2VFcnJvciA9IG1lbW9pemUoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVTklNUExFTUVOVEVEXCIpO1xuICAgIH0pO1xuICAgIGNvbnN0IHN0YXJ0T25FcnJvciA9IG1lbW9pemUoKCkgPT4ge1xuICAgICAgICAkd29ya2VyLnBhcmVudFBvcnQub24oXCJlcnJvclwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgd29ya2VyRXZlbnRzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZXJyb3JcIikpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBOb2RlIHdvcmtlcnMgZG9uJ3QgaGF2ZSB0b3AtbGV2ZWwgZXZlbnRzLCBzbyB3ZSBoYXZlIHRvIG1ha2Ugb3VyIG93blxuICAgIGNvbnN0IHdvcmtlckV2ZW50cyA9IG5ldyBFdmVudFRhcmdldCgpO1xuICAgIGdsb2JhbHMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgpO1xuICAgIH07XG4gICAgZ2xvYmFscy5hZGRFdmVudExpc3RlbmVyID0gKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIHdvcmtlckV2ZW50cy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICBzdGFydE9uTWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwibWVzc2FnZWVycm9yXCIpIHtcbiAgICAgICAgICAgIHN0YXJ0T25NZXNzYWdlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIHN0YXJ0T25FcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBnbG9iYWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSAodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpID0+IHtcbiAgICAgICAgd29ya2VyRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2UodmFsdWUsIHRyYW5zZmVyKSB7XG4gICAgICAgICR3b3JrZXIucGFyZW50UG9ydC5wb3N0TWVzc2FnZSh2YWx1ZSwgdHJhbnNmZXIpO1xuICAgIH1cbiAgICBnbG9iYWxzLnBvc3RNZXNzYWdlID0gcG9zdE1lc3NhZ2U7XG4gICAgbWFrZVNldHRlcihcIm9ubWVzc2FnZVwiLCBcIm1lc3NhZ2VcIik7XG4gICAgbWFrZVNldHRlcihcIm9ubWVzc2FnZWVycm9yXCIsIFwibWVzc2FnZWVycm9yXCIpO1xuICAgIG1ha2VTZXR0ZXIoXCJvbmVycm9yXCIsIFwiZXJyb3JcIik7XG59XG5cbmlmICghZ2xvYmFsVGhpcy5zZWxmKSB7XG4gICAgZ2xvYmFsVGhpcy5zZWxmID0gZ2xvYmFsVGhpcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGUtcG9seWZpbGwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js?3032\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js?8a58":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js ***!
  \*************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/node-polyfill.65393b57.js";

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node.js ***!
  \****************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.Account),\n/* harmony export */   Address: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Address),\n/* harmony export */   AleoKeyProvider: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.A),\n/* harmony export */   AleoKeyProviderParams: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   AleoNetworkClient: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.b),\n/* harmony export */   BHP1024: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.BHP1024),\n/* harmony export */   BHP256: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.BHP256),\n/* harmony export */   BHP512: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.BHP512),\n/* harmony export */   BHP768: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.BHP768),\n/* harmony export */   BlockHeightSearch: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.BlockHeightSearch),\n/* harmony export */   CREDITS_PROGRAM_KEYS: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.C),\n/* harmony export */   Ciphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Ciphertext),\n/* harmony export */   ComputeKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.ComputeKey),\n/* harmony export */   ExecutionResponse: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.ExecutionResponse),\n/* harmony export */   Field: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Field),\n/* harmony export */   FunctionExecution: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Execution),\n/* harmony export */   Group: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Group),\n/* harmony export */   KEY_STORE: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.K),\n/* harmony export */   NetworkRecordProvider: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.NetworkRecordProvider),\n/* harmony export */   OfflineKeyProvider: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.OfflineKeyProvider),\n/* harmony export */   OfflineQuery: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.OfflineQuery),\n/* harmony export */   OfflineSearchParams: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.OfflineSearchParams),\n/* harmony export */   PRIVATE_TO_PUBLIC_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.d),\n/* harmony export */   PRIVATE_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   PRIVATE_TRANSFER_TYPES: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   PUBLIC_TO_PRIVATE_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.h),\n/* harmony export */   PUBLIC_TRANSFER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.f),\n/* harmony export */   PUBLIC_TRANSFER_AS_SIGNER: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.g),\n/* harmony export */   Pedersen128: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Pedersen128),\n/* harmony export */   Pedersen64: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Pedersen64),\n/* harmony export */   Plaintext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Plaintext),\n/* harmony export */   Poseidon2: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Poseidon2),\n/* harmony export */   Poseidon4: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Poseidon4),\n/* harmony export */   Poseidon8: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Poseidon8),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.PrivateKey),\n/* harmony export */   PrivateKeyCiphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.PrivateKeyCiphertext),\n/* harmony export */   Program: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Program),\n/* harmony export */   ProgramManager: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.P),\n/* harmony export */   ProgramManagerBase: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.ProgramManager),\n/* harmony export */   ProvingKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.ProvingKey),\n/* harmony export */   RecordCiphertext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.RecordCiphertext),\n/* harmony export */   RecordPlaintext: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.RecordPlaintext),\n/* harmony export */   Scalar: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Scalar),\n/* harmony export */   Signature: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Signature),\n/* harmony export */   Transaction: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Transaction),\n/* harmony export */   Transition: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.Transition),\n/* harmony export */   VALID_TRANSFER_TYPES: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.V),\n/* harmony export */   VerifyingKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.VerifyingKey),\n/* harmony export */   ViewKey: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.ViewKey),\n/* harmony export */   createAleoWorker: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.createAleoWorker),\n/* harmony export */   initThreadPool: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.initThreadPool),\n/* harmony export */   initializeWasm: () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_1__.initializeWasm),\n/* harmony export */   logAndThrow: () => (/* reexport safe */ _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.l),\n/* harmony export */   verifyFunctionExecution: () => (/* reexport safe */ _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__.verifyFunctionExecution)\n/* harmony export */ });\n/* harmony import */ var _node_polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node-polyfill.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node-polyfill.js?3032\");\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/browser.js\");\n/* harmony import */ var _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./program-manager-CjvnOyfn.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js\");\n/* harmony import */ var _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @provablehq/wasm/testnet.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js\");\n/* harmony import */ var core_js_proposals_json_parse_with_source_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/proposals/json-parse-with-source.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/proposals/json-parse-with-source.js\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var mime_lite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! mime/lite */ \"(ssr)/./node_modules/.pnpm/mime@4.0.6/node_modules/mime/dist/src/index_lite.js\");\n/* harmony import */ var xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! xmlhttprequest-ssl */ \"(ssr)/./node_modules/.pnpm/xmlhttprequest-ssl@3.1.0/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\n/* harmony import */ var sync_request__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! sync-request */ \"(ssr)/./node_modules/.pnpm/sync-request@6.1.0/node_modules/sync-request/lib/index.js\");\n/* harmony import */ var node_worker_threads__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! node:os */ \"node:os\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_browser_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__, _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__]);\n([_browser_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__, _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=node.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L25vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ2dJO0FBQ3NQO0FBQzZGO0FBQzFiO0FBQ2hDO0FBQ0o7QUFDRTtBQUNTO0FBQ047QUFDTztBQUNaO0FBQ0E7QUFDakIiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXJuYW1lL2FsZW8vcmF0ZS1saW1pdGluZy1udWxsaWZpZXIvcmxuLW1lc3NhZ2UtYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm92YWJsZWhxK3Nka0AwLjguNi9ub2RlX21vZHVsZXMvQHByb3ZhYmxlaHEvc2RrL2Rpc3QvdGVzdG5ldC9ub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9ub2RlLXBvbHlmaWxsLmpzJztcbmV4cG9ydCB7IEFjY291bnQsIEJsb2NrSGVpZ2h0U2VhcmNoLCBOZXR3b3JrUmVjb3JkUHJvdmlkZXIsIE9mZmxpbmVLZXlQcm92aWRlciwgT2ZmbGluZVNlYXJjaFBhcmFtcywgY3JlYXRlQWxlb1dvcmtlciwgaW5pdGlhbGl6ZVdhc20gfSBmcm9tICcuL2Jyb3dzZXIuanMnO1xuZXhwb3J0IHsgQSBhcyBBbGVvS2V5UHJvdmlkZXIsIGEgYXMgQWxlb0tleVByb3ZpZGVyUGFyYW1zLCBiIGFzIEFsZW9OZXR3b3JrQ2xpZW50LCBDIGFzIENSRURJVFNfUFJPR1JBTV9LRVlTLCBLIGFzIEtFWV9TVE9SRSwgZCBhcyBQUklWQVRFX1RPX1BVQkxJQ19UUkFOU0ZFUiwgYyBhcyBQUklWQVRFX1RSQU5TRkVSLCBlIGFzIFBSSVZBVEVfVFJBTlNGRVJfVFlQRVMsIGggYXMgUFVCTElDX1RPX1BSSVZBVEVfVFJBTlNGRVIsIGYgYXMgUFVCTElDX1RSQU5TRkVSLCBnIGFzIFBVQkxJQ19UUkFOU0ZFUl9BU19TSUdORVIsIFAgYXMgUHJvZ3JhbU1hbmFnZXIsIFYgYXMgVkFMSURfVFJBTlNGRVJfVFlQRVMsIGwgYXMgbG9nQW5kVGhyb3cgfSBmcm9tICcuL3Byb2dyYW0tbWFuYWdlci1DanZuT3lmbi5qcyc7XG5leHBvcnQgeyBBZGRyZXNzLCBCSFAxMDI0LCBCSFAyNTYsIEJIUDUxMiwgQkhQNzY4LCBDaXBoZXJ0ZXh0LCBDb21wdXRlS2V5LCBFeGVjdXRpb25SZXNwb25zZSwgRmllbGQsIEV4ZWN1dGlvbiBhcyBGdW5jdGlvbkV4ZWN1dGlvbiwgR3JvdXAsIE9mZmxpbmVRdWVyeSwgUGVkZXJzZW4xMjgsIFBlZGVyc2VuNjQsIFBsYWludGV4dCwgUG9zZWlkb24yLCBQb3NlaWRvbjQsIFBvc2VpZG9uOCwgUHJpdmF0ZUtleSwgUHJpdmF0ZUtleUNpcGhlcnRleHQsIFByb2dyYW0sIFByb2dyYW1NYW5hZ2VyIGFzIFByb2dyYW1NYW5hZ2VyQmFzZSwgUHJvdmluZ0tleSwgUmVjb3JkQ2lwaGVydGV4dCwgUmVjb3JkUGxhaW50ZXh0LCBTY2FsYXIsIFNpZ25hdHVyZSwgVHJhbnNhY3Rpb24sIFRyYW5zaXRpb24sIFZlcmlmeWluZ0tleSwgVmlld0tleSwgaW5pdFRocmVhZFBvb2wsIHZlcmlmeUZ1bmN0aW9uRXhlY3V0aW9uIH0gZnJvbSAnQHByb3ZhYmxlaHEvd2FzbS90ZXN0bmV0LmpzJztcbmltcG9ydCAnY29yZS1qcy9wcm9wb3NhbHMvanNvbi1wYXJzZS13aXRoLXNvdXJjZS5qcyc7XG5pbXBvcnQgJ25vZGU6Y3J5cHRvJztcbmltcG9ydCAnbm9kZTpmcyc7XG5pbXBvcnQgJ21pbWUvbGl0ZSc7XG5pbXBvcnQgJ3htbGh0dHByZXF1ZXN0LXNzbCc7XG5pbXBvcnQgJ3N5bmMtcmVxdWVzdCc7XG5pbXBvcnQgJ25vZGU6d29ya2VyX3RocmVhZHMnO1xuaW1wb3J0ICdub2RlOm9zJztcbmltcG9ydCAnY29tbGluayc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js ***!
  \************************************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ AleoKeyProvider),\n/* harmony export */   C: () => (/* binding */ CREDITS_PROGRAM_KEYS),\n/* harmony export */   K: () => (/* binding */ KEY_STORE),\n/* harmony export */   P: () => (/* binding */ ProgramManager),\n/* harmony export */   V: () => (/* binding */ VALID_TRANSFER_TYPES),\n/* harmony export */   a: () => (/* binding */ AleoKeyProviderParams),\n/* harmony export */   b: () => (/* binding */ AleoNetworkClient),\n/* harmony export */   c: () => (/* binding */ PRIVATE_TRANSFER),\n/* harmony export */   d: () => (/* binding */ PRIVATE_TO_PUBLIC_TRANSFER),\n/* harmony export */   e: () => (/* binding */ PRIVATE_TRANSFER_TYPES),\n/* harmony export */   f: () => (/* binding */ PUBLIC_TRANSFER),\n/* harmony export */   g: () => (/* binding */ PUBLIC_TRANSFER_AS_SIGNER),\n/* harmony export */   h: () => (/* binding */ PUBLIC_TO_PRIVATE_TRANSFER),\n/* harmony export */   l: () => (/* binding */ logAndThrow)\n/* harmony export */ });\n/* harmony import */ var _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @provablehq/wasm/testnet.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__]);\n_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nfunction logAndThrow(message) {\n    console.error(message);\n    throw new Error(message);\n}\nfunction parseJSON(json) {\n    function revive(key, value, context) {\n        if (Number.isInteger(value)) {\n            return BigInt(context.source);\n        }\n        else {\n            return value;\n        }\n    }\n    return JSON.parse(json, revive);\n}\nasync function get(url, options) {\n    const response = await fetch(url, options);\n    if (!response.ok) {\n        throw new Error(response.status + \" could not get URL \" + url);\n    }\n    return response;\n}\nasync function post(url, options) {\n    options.method = \"POST\";\n    const response = await fetch(url, options);\n    if (!response.ok) {\n        throw new Error(response.status + \" could not post URL \" + url);\n    }\n    return response;\n}\n\n/**\n * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this\n * allow users to query public information from the Aleo blockchain and submit transactions to the network.\n *\n * @param {string} host\n * @example\n * // Connection to a local node\n * const localNetworkClient = new AleoNetworkClient(\"http://localhost:3030\");\n *\n * // Connection to a public beacon node\n * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);\n * const publicnetworkClient = new AleoNetworkClient(\"http://localhost:3030\", undefined, account);\n */\nclass AleoNetworkClient {\n    host;\n    headers;\n    account;\n    constructor(host, options) {\n        this.host = host + \"/testnet\";\n        if (options && options.headers) {\n            this.headers = options.headers;\n        }\n        else {\n            this.headers = {\n                // This is replaced by the actual version by a Rollup plugin\n                \"X-Aleo-SDK-Version\": \"0.8.6\",\n            };\n        }\n    }\n    /**\n     * Set an account to use in networkClient calls\n     *\n     * @param {Account} account\n     * @example\n     * const account = new Account();\n     * networkClient.setAccount(account);\n     */\n    setAccount(account) {\n        this.account = account;\n    }\n    /**\n     * Return the Aleo account used in the networkClient\n     *\n     * @example\n     * const account = networkClient.getAccount();\n     */\n    getAccount() {\n        return this.account;\n    }\n    /**\n     * Set a new host for the networkClient\n     *\n     * @param {string} host The address of a node hosting the Aleo API\n     * @param host\n     */\n    setHost(host) {\n        this.host = host + \"/testnet\";\n    }\n    /**\n     * Fetches data from the Aleo network and returns it as a JSON object.\n     *\n     * @param url\n     */\n    async fetchData(url = \"/\") {\n        try {\n            return parseJSON(await this.fetchRaw(url));\n        }\n        catch (error) {\n            throw new Error(`Error fetching data: ${error}`);\n        }\n    }\n    /**\n     * Fetches data from the Aleo network and returns it as an unparsed string.\n     *\n     * This method should be used when it is desired to reconstitute data returned\n     * from the network into a WASM object.\n     *\n     * @param url\n     */\n    async fetchRaw(url = \"/\") {\n        try {\n            const response = await get(this.host + url, {\n                headers: this.headers\n            });\n            return await response.text();\n        }\n        catch (error) {\n            throw new Error(`Error fetching data: ${error}`);\n        }\n    }\n    /**\n     * Attempt to find records in the Aleo blockchain.\n     *\n     * @param {number} startHeight - The height at which to start searching for unspent records\n     * @param {number} endHeight - The height at which to stop searching for unspent records\n     * @param {boolean} unspent - Whether to search for unspent records only\n     * @param {string[]} programs - The program(s) to search for unspent records in\n     * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n     * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n     * @param {string[]} nonces - The nonces of already found records to exclude from the search\n     * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n     *\n     * @example\n     * // Find specific amounts\n     * const startHeight = 500000;\n     * const amounts = [600000, 1000000];\n     * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] amounts);\n     *\n     * // Find specific amounts with a maximum number of cumulative microcredits\n     * const maxMicrocredits = 100000;\n     * const records = networkClient.findRecords(startHeight, undefined, true, [\"credits.aleo\"] undefined, maxMicrocredits);\n     */\n    async findRecords(startHeight, endHeight, unspent = false, programs, amounts, maxMicrocredits, nonces, privateKey) {\n        nonces = nonces || [];\n        // Ensure start height is not negative\n        if (startHeight < 0) {\n            throw new Error(\"Start height must be greater than or equal to 0\");\n        }\n        // Initialize search parameters\n        const records = new Array();\n        let start;\n        let end;\n        let resolvedPrivateKey;\n        let failures = 0;\n        let totalRecordValue = BigInt(0);\n        let latestHeight;\n        // Ensure a private key is present to find owned records\n        if (typeof privateKey === \"undefined\") {\n            if (typeof this.account === \"undefined\") {\n                throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n            }\n            else {\n                resolvedPrivateKey = this.account._privateKey;\n            }\n        }\n        else {\n            try {\n                resolvedPrivateKey = privateKey instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey ? privateKey : _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.from_string(privateKey);\n            }\n            catch (error) {\n                throw new Error(\"Error parsing private key provided.\");\n            }\n        }\n        const viewKey = resolvedPrivateKey.to_view_key();\n        // Get the latest height to ensure the range being searched is valid\n        try {\n            const blockHeight = await this.getLatestHeight();\n            if (typeof blockHeight === \"number\") {\n                latestHeight = blockHeight;\n            }\n            else {\n                throw new Error(`Error fetching latest block height: Expected type 'number' got '${typeof blockHeight}'`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest block height: ${error}`);\n        }\n        // If no end height is specified or is greater than the latest height, set the end height to the latest height\n        if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n            end = endHeight;\n        }\n        else {\n            end = latestHeight;\n        }\n        // If the starting is greater than the ending height, return an error\n        if (startHeight > end) {\n            throw new Error(\"Start height must be less than or equal to end height.\");\n        }\n        // Iterate through blocks in reverse order in chunks of 50\n        while (end > startHeight) {\n            start = end - 50;\n            if (start < startHeight) {\n                start = startHeight;\n            }\n            try {\n                // Get 50 blocks (or the difference between the start and end if less than 50)\n                const blocks = await this.getBlockRange(start, end);\n                end = start;\n                // Iterate through blocks to find unspent records\n                for (let i = 0; i < blocks.length; i++) {\n                    const block = blocks[i];\n                    const transactions = block.transactions;\n                    if (!(typeof transactions === \"undefined\")) {\n                        for (let j = 0; j < transactions.length; j++) {\n                            const confirmedTransaction = transactions[j];\n                            // Search for unspent records in execute transactions of credits.aleo\n                            if (confirmedTransaction.type == \"execute\") {\n                                const transaction = confirmedTransaction.transaction;\n                                if (transaction.execution && !(typeof transaction.execution.transitions == \"undefined\")) {\n                                    for (let k = 0; k < transaction.execution.transitions.length; k++) {\n                                        const transition = transaction.execution.transitions[k];\n                                        // Only search for unspent records in the specified programs.\n                                        if (!(typeof programs === \"undefined\")) {\n                                            if (!programs.includes(transition.program)) {\n                                                continue;\n                                            }\n                                        }\n                                        if (!(typeof transition.outputs == \"undefined\")) {\n                                            for (let l = 0; l < transition.outputs.length; l++) {\n                                                const output = transition.outputs[l];\n                                                if (output.type === \"record\") {\n                                                    try {\n                                                        // Create a wasm record ciphertext object from the found output\n                                                        const record = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordCiphertext.fromString(output.value);\n                                                        // Determine if the record is owned by the specified view key\n                                                        if (record.isOwner(viewKey)) {\n                                                            // Decrypt the record and get the serial number\n                                                            const recordPlaintext = record.decrypt(viewKey);\n                                                            // If the record has already been found, skip it\n                                                            const nonce = recordPlaintext.nonce();\n                                                            if (nonces.includes(nonce)) {\n                                                                continue;\n                                                            }\n                                                            if (unspent) {\n                                                                // Otherwise record the nonce that has been found\n                                                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                                                                // Attempt to see if the serial number is spent\n                                                                try {\n                                                                    await this.getTransitionId(serialNumber);\n                                                                    continue;\n                                                                }\n                                                                catch (error) {\n                                                                    console.log(\"Found unspent record!\");\n                                                                }\n                                                            }\n                                                            // Add the record to the list of records if the user did not specify amounts.\n                                                            if (!amounts) {\n                                                                records.push(recordPlaintext);\n                                                                // If the user specified a maximum number of microcredits, check if the search has found enough\n                                                                if (typeof maxMicrocredits === \"number\") {\n                                                                    totalRecordValue += recordPlaintext.microcredits();\n                                                                    // Exit if the search has found the amount specified\n                                                                    if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                                                        return records;\n                                                                    }\n                                                                }\n                                                            }\n                                                            // If the user specified a list of amounts, check if the search has found them\n                                                            if (!(typeof amounts === \"undefined\") && amounts.length > 0) {\n                                                                let amounts_found = 0;\n                                                                if (recordPlaintext.microcredits() > amounts[amounts_found]) {\n                                                                    amounts_found += 1;\n                                                                    records.push(recordPlaintext);\n                                                                    // If the user specified a maximum number of microcredits, check if the search has found enough\n                                                                    if (typeof maxMicrocredits === \"number\") {\n                                                                        totalRecordValue += recordPlaintext.microcredits();\n                                                                        // Exit if the search has found the amount specified\n                                                                        if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                                                            return records;\n                                                                        }\n                                                                    }\n                                                                    if (records.length >= amounts.length) {\n                                                                        return records;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                    catch (error) {\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // If there is an error fetching blocks, log it and keep searching\n                console.warn(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n                console.warn(\"Error: \", error);\n                failures += 1;\n                if (failures > 10) {\n                    console.warn(\"10 failures fetching records reached. Returning records fetched so far\");\n                    return records;\n                }\n            }\n        }\n        return records;\n    }\n    /**\n     * Attempts to find unspent records in the Aleo blockchain.\n     *\n     * @param {number} startHeight - The height at which to start searching for unspent records\n     * @param {number} endHeight - The height at which to stop searching for unspent records\n     * @param {string[]} programs - The program(s) to search for unspent records in\n     * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])\n     * @param {number} maxMicrocredits - The maximum number of microcredits to search for\n     * @param {string[]} nonces - The nonces of already found records to exclude from the search\n     * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.\n     *\n     * @example\n     * // Find specific amounts\n     * const startHeight = 500000;\n     * const endHeight = 550000;\n     * const amounts = [600000, 1000000];\n     * const records = networkClient.findUnspentRecords(startHeight, endHeight, [\"credits.aleo\"], amounts);\n     *\n     * // Find specific amounts with a maximum number of cumulative microcredits\n     * const maxMicrocredits = 100000;\n     * const records = networkClient.findUnspentRecords(startHeight, undefined, [\"credits.aleo\"], undefined, maxMicrocredits);\n     */\n    async findUnspentRecords(startHeight, endHeight, programs, amounts, maxMicrocredits, nonces, privateKey) {\n        return await this.findRecords(startHeight, endHeight, true, programs, amounts, maxMicrocredits, nonces, privateKey);\n    }\n    /**\n     * Returns the contents of the block at the specified block height.\n     *\n     * @param {number} blockHeight\n     * @example\n     * const block = networkClient.getBlock(1234);\n     */\n    async getBlock(blockHeight) {\n        try {\n            const block = await this.fetchData(\"/block/\" + blockHeight);\n            return block;\n        }\n        catch (error) {\n            throw new Error(`Error fetching block ${blockHeight}: ${error}`);\n        }\n    }\n    /**\n     * Returns the contents of the block with the specified hash.\n     *\n     * @param {string} blockHash\n     * @example\n     * const block = networkClient.getBlockByHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n     */\n    async getBlockByHash(blockHash) {\n        try {\n            const block = await this.fetchData(`/block/${blockHash}`);\n            return block;\n        }\n        catch (error) {\n            throw new Error(`Error fetching block ${blockHash}: ${error}`);\n        }\n    }\n    /**\n     * Returns a range of blocks between the specified block heights.\n     *\n     * @param {number} start\n     * @param {number} end\n     * @example\n     * const blockRange = networkClient.getBlockRange(2050, 2100);\n     */\n    async getBlockRange(start, end) {\n        try {\n            return await this.fetchData(\"/blocks?start=\" + start + \"&end=\" + end);\n        }\n        catch (error) {\n            throw new Error(`Error fetching blocks between ${start} and ${end}: ${error}`);\n        }\n    }\n    /**\n     * Returns the deployment transaction id associated with the specified program.\n     *\n     * @param {Program | string} program\n     * @returns {TransactionJSON}\n     */\n    async getDeploymentTransactionIDForProgram(program) {\n        if (program instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program) {\n            program = program.id();\n        }\n        try {\n            const id = await this.fetchData(\"/find/transactionID/deployment/\" + program);\n            return id.replace(\"\\\"\", \"\");\n        }\n        catch (error) {\n            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n        }\n    }\n    /**\n     * Returns the deployment transaction associated with a specified program.\n     *\n     * @param {Program | string} program\n     * @returns {TransactionJSON}\n     */\n    async getDeploymentTransactionForProgram(program) {\n        if (program instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program) {\n            program = program.id();\n        }\n        try {\n            const transaction_id = await this.getDeploymentTransactionIDForProgram(program);\n            return await this.getTransaction(transaction_id);\n        }\n        catch (error) {\n            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n        }\n    }\n    /**\n     * Returns the deployment transaction associated with a specified program as a wasm object.\n     *\n     * @param {Program | string} program\n     * @returns {TransactionJSON}\n     */\n    async getDeploymentTransactionObjectForProgram(program) {\n        try {\n            const transaction_id = await this.getDeploymentTransactionIDForProgram(program);\n            return await this.getTransactionObject(transaction_id);\n        }\n        catch (error) {\n            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);\n        }\n    }\n    /**\n     * Returns the contents of the latest block.\n     *\n     * @example\n     * const latestHeight = networkClient.getLatestBlock();\n     */\n    async getLatestBlock() {\n        try {\n            return await this.fetchData(\"/block/latest\");\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest block: ${error}`);\n        }\n    }\n    /**\n     * Returns the latest committee.\n     *\n     * @returns {Promise<object>} A javascript object containing the latest committee\n     */\n    async getLatestCommittee() {\n        try {\n            return await this.fetchData(\"/committee/latest\");\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest committee: ${error}`);\n        }\n    }\n    /**\n     * Returns the committe at the specified block height.\n     *\n     * @param {number} blockHeight\n     *\n     * @returns {Promise<object>} A javascript object containing the committee\n     *\n     * @example\n     * const committee = await networkClient.getCommitteByBlockHeight(1234);\n     */\n    async getCommitteeByBlockHeight(blockHeight) {\n        try {\n            return await this.fetchData(`/committee/${blockHeight}`);\n        }\n        catch (error) {\n            throw new Error(`Error fetching committee at height ${blockHeight}: ${error}`);\n        }\n    }\n    /**\n     * Returns the latest block height.\n     *\n     * @example\n     * const latestHeight = networkClient.getLatestHeight();\n     */\n    async getLatestHeight() {\n        try {\n            return Number(await this.fetchData(\"/block/height/latest\"));\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest height: ${error}`);\n        }\n    }\n    /**\n     * Returns the latest block hash.\n     *\n     * @example\n     * const latestHash - newtworkClient.getLatestBlockHash();\n     */\n    async getLatestBlockHash() {\n        try {\n            return String(await this.fetchData(\"/block/hash/latest\"));\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest hash: ${error}`);\n        }\n    }\n    /**\n     * Returns the source code of a program given a program ID.\n     *\n     * @param {string} programId The program ID of a program deployed to the Aleo Network\n     * @return {Promise<string>} Source code of the program\n     *\n     * @example\n     * const program = networkClient.getProgram(\"hello_hello.aleo\");\n     * const expectedSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n     * assert.equal(program, expectedSource);\n     */\n    async getProgram(programId) {\n        try {\n            return await this.fetchData(\"/program/\" + programId);\n        }\n        catch (error) {\n            throw new Error(`Error fetching program ${programId}: ${error}`);\n        }\n    }\n    /**\n     * Returns a program object from a program ID or program source code.\n     *\n     * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n     * @return {Promise<Program>} Source code of the program\n     *\n     * @example\n     * const programID = \"hello_hello.aleo\";\n     * const programSource = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n     *\n     * // Get program object from program ID or program source code\n     * const programObjectFromID = await networkClient.getProgramObject(programID);\n     * const programObjectFromSource = await networkClient.getProgramObject(programSource);\n     *\n     * // Both program objects should be equal\n     * assert.equal(programObjectFromID.to_string(), programObjectFromSource.to_string());\n     */\n    async getProgramObject(inputProgram) {\n        try {\n            return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString(inputProgram);\n        }\n        catch (error) {\n            try {\n                return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString((await this.getProgram(inputProgram)));\n            }\n            catch (error) {\n                throw new Error(`${inputProgram} is neither a program name or a valid program: ${error}`);\n            }\n        }\n    }\n    /**\n     *  Returns an object containing the source code of a program and the source code of all programs it imports\n     *\n     * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network\n     * @returns {Promise<ProgramImports>} Object of the form { \"program_id\": \"program_source\", .. } containing program id & source code for all program imports\n     *\n     * @example\n     * const double_test_source = \"import multiply_test.aleo;\\n\\nprogram double_test.aleo;\\n\\nfunction double_it:\\n    input r0 as u32.private;\\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\\n    output r1 as u32.private;\\n\"\n     * const double_test = Program.fromString(double_test_source);\n     * const expectedImports = {\n     *     \"multiply_test.aleo\": \"program multiply_test.aleo;\\n\\nfunction multiply:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    mul r0 r1 into r2;\\n    output r2 as u32.private;\\n\"\n     * }\n     *\n     * // Imports can be fetched using the program ID, source code, or program object\n     * let programImports = await networkClient.getProgramImports(\"double_test.aleo\");\n     * assert.deepStrictEqual(programImports, expectedImports);\n     *\n     * // Using the program source code\n     * programImports = await networkClient.getProgramImports(double_test_source);\n     * assert.deepStrictEqual(programImports, expectedImports);\n     *\n     * // Using the program object\n     * programImports = await networkClient.getProgramImports(double_test);\n     * assert.deepStrictEqual(programImports, expectedImports);\n     */\n    async getProgramImports(inputProgram) {\n        try {\n            const imports = {};\n            // Get the program object or fail if the program is not valid or does not exist\n            const program = inputProgram instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program ? inputProgram : (await this.getProgramObject(inputProgram));\n            // Get the list of programs that the program imports\n            const importList = program.getImports();\n            // Recursively get any imports that the imported programs have in a depth first search order\n            for (let i = 0; i < importList.length; i++) {\n                const import_id = importList[i];\n                if (!imports.hasOwnProperty(import_id)) {\n                    const programSource = await this.getProgram(import_id);\n                    const nestedImports = await this.getProgramImports(import_id);\n                    for (const key in nestedImports) {\n                        if (!imports.hasOwnProperty(key)) {\n                            imports[key] = nestedImports[key];\n                        }\n                    }\n                    imports[import_id] = programSource;\n                }\n            }\n            return imports;\n        }\n        catch (error) {\n            logAndThrow(\"Error fetching program imports: \" + error.message);\n        }\n    }\n    /**\n     * Get a list of the program names that a program imports.\n     *\n     * @param {Program | string} inputProgram - The program id or program source code to get the imports of\n     * @returns {string[]} - The list of program names that the program imports\n     *\n     * @example\n     * const programImportsNames = networkClient.getProgramImports(\"double_test.aleo\");\n     * const expectedImportsNames = [\"multiply_test.aleo\"];\n     * assert.deepStrictEqual(programImportsNames, expectedImportsNames);\n     */\n    async getProgramImportNames(inputProgram) {\n        try {\n            const program = inputProgram instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program ? inputProgram : (await this.getProgramObject(inputProgram));\n            return program.getImports();\n        }\n        catch (error) {\n            throw new Error(`Error fetching imports for program ${inputProgram instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program ? inputProgram.id() : inputProgram}: ${error.message}`);\n        }\n    }\n    /**\n     * Returns the names of the mappings of a program.\n     *\n     * @param {string} programId - The program ID to get the mappings of (e.g. \"credits.aleo\")\n     * @example\n     * const mappings = networkClient.getProgramMappingNames(\"credits.aleo\");\n     * const expectedMappings = [\n     *   \"committee\",\n     *   \"delegated\",\n     *   \"metadata\",\n     *   \"bonded\",\n     *   \"unbonding\",\n     *   \"account\",\n     *   \"withdraw\"\n     * ];\n     * assert.deepStrictEqual(mappings, expectedMappings);\n     */\n    async getProgramMappingNames(programId) {\n        try {\n            return await this.fetchData(`/program/${programId}/mappings`);\n        }\n        catch (error) {\n            throw new Error(`Error fetching mappings for program ${programId} - ensure the program exists on chain before trying again`);\n        }\n    }\n    /**\n     * Returns the value of a program's mapping for a specific key.\n     *\n     * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n     * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"account\")\n     * @param {string | Plaintext} key - The key of the mapping to get the value of (e.g. \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\")\n     * @return {Promise<string>} String representation of the value of the mapping\n     *\n     * @example\n     * // Get public balance of an account\n     * const mappingValue = networkClient.getMappingValue(\"credits.aleo\", \"account\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n     * const expectedValue = \"0u64\";\n     * assert.equal(mappingValue, expectedValue);\n     */\n    async getProgramMappingValue(programId, mappingName, key) {\n        try {\n            const keyString = key instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Plaintext ? key.toString() : key;\n            return await this.fetchData(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n        }\n        catch (error) {\n            throw new Error(`Error fetching value for key '${key}' in mapping '${mappingName}' in program '${programId}' - ensure the mapping exists and the key is correct`);\n        }\n    }\n    /**\n     * Returns the value of a mapping as a wasm Plaintext object. Returning an\n     * object in this format allows it to be converted to a Js type and for its\n     * internal members to be inspected if it's a struct or array.\n     *\n     * @example\n     * // Get the bond state as an account.\n     * const unbondedState = networkClient.getMappingPlaintext(\"credits.aleo\", \"bonded\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n     *\n     * // Get the two members of the object individually.\n     * const validator = unbondedState.getMember(\"validator\");\n     * const microcredits = unbondedState.getMember(\"microcredits\");\n     *\n     * // Ensure the expected values are correct.\n     * assert.equal(validator, \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\");\n     * assert.equal(microcredits, BigInt(\"9007199254740991\"));\n     *\n     * // Get a JS object representation of the unbonded state.\n     * const unbondedStateObject = unbondedState.toObject();\n     *\n     * const expectedState = {\n     *     validator: \"aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd\",\n     *     microcredits: BigInt(\"9007199254740991\")\n     * };\n     * assert.equal(unbondedState, expectedState);\n     *\n     * @param {string} programId - The program ID to get the mapping value of (e.g. \"credits.aleo\")\n     * @param {string} mappingName - The name of the mapping to get the value of (e.g. \"account\")\n     * @param {string | Plaintext} key - The key of the mapping to get the value of (e.g. \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\")\n     *\n     * @return {Promise<string>} String representation of the value of the mapping\n     */\n    async getProgramMappingPlaintext(programId, mappingName, key) {\n        try {\n            const keyString = key instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Plaintext ? key.toString() : key;\n            const value = await this.fetchRaw(`/program/${programId}/mapping/${mappingName}/${keyString}`);\n            return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Plaintext.fromString(JSON.parse(value));\n        }\n        catch (error) {\n            throw new Error(\"Failed to fetch mapping value.\" + error);\n        }\n    }\n    /**\n     * Returns the public balance of an address from the account mapping in credits.aleo\n     *\n     * @param {string} address\n     *\n     * @example\n     * const account = new Account();\n     * const publicBalance = networkClient.getPublicBalance(account.address());\n     */\n    async getPublicBalance(address) {\n        try {\n            const balanceStr = await this.getProgramMappingValue('credits.aleo', 'account', address.to_string());\n            return balanceStr ? parseInt(balanceStr) : 0;\n        }\n        catch (error) {\n            throw new Error(`Error fetching public balance for ${address}: ${error}`);\n        }\n    }\n    /**\n     * Returns the latest state/merkle root of the Aleo blockchain.\n     *\n     * @example\n     * const stateRoot = networkClient.getStateRoot();\n     */\n    async getStateRoot() {\n        try {\n            return await this.fetchData('/stateRoot/latest');\n        }\n        catch (error) {\n            throw new Error(`Error fetching latest state root: ${error}`);\n        }\n    }\n    /**\n     * Returns a transaction by its unique identifier.\n     *\n     * @param {string} transactionId\n     * @example\n     * const transaction = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     */\n    async getTransaction(transactionId) {\n        try {\n            return await this.fetchData(\"/transaction/\" + transactionId);\n        }\n        catch (error) {\n            throw new Error(`Error fetching transaction ${transactionId}: ${error}`);\n        }\n    }\n    /**\n     * Returns a confirmed transaction by its unique identifier.\n     *\n     * @param {string} transactionId\n     * @example\n     * const transaction = networkClient.getConfirmedTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     */\n    async getConfirmedTransaction(transactionId) {\n        try {\n            return await this.fetchData(`/transaction/confirmed/${transactionId}`);\n        }\n        catch (error) {\n            throw new Error(`Error fetching confirmed transaction ${transactionId}: ${error}`);\n        }\n    }\n    /**\n     * Returns a transaction as a wasm object. Getting a transaction of this type will allow the ability for the inputs,\n     * outputs, and records to be searched for and displayed.\n     *\n     * @example\n     * const transactionObject = networkClient.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     * // Get the transaction inputs as a JS array.\n     * const transactionOutputs = transactionObject.inputs(true);\n     *\n     * // Get the transaction outputs as a JS object.\n     * const transactionInputs = transactionObject.outputs(true);\n     *\n     * // Get any records generated in transitions in the transaction as a JS object.\n     * const records = transactionObject.records();\n     *\n     * // Get the transaction type.\n     * const transactionType = transactionObject.transactionType();\n     * assert.equal(transactionType, \"Execute\");\n     *\n     * // Get a JS representation of all inputs, outputs, and transaction metadata.\n     * const transactionSummary = transactionObject.summary();\n     *\n     * @param {string} transactionId\n     * @example\n     * const transaction = networkClient.getTransactionObject(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     */\n    async getTransactionObject(transactionId) {\n        try {\n            const transaction = await this.fetchRaw(\"/transaction/\" + transactionId);\n            return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.fromString(transaction);\n        }\n        catch (error) {\n            throw new Error(`Error fetching transaction object ${transactionId}: ${error}`);\n        }\n    }\n    /**\n     * Returns the transactions present at the specified block height.\n     *\n     * @param {number} blockHeight\n     * @example\n     * const transactions = networkClient.getTransactions(654);\n     */\n    async getTransactions(blockHeight) {\n        try {\n            return await this.fetchData(\"/block/\" + blockHeight.toString() + \"/transactions\");\n        }\n        catch (error) {\n            throw new Error(`Error fetching transactions: ${error}`);\n        }\n    }\n    /**\n     * Returns the confirmed transactions present in the block with the specified block hash.\n     *\n     * @param {string} blockHash\n     * @example\n     * const transactions = networkClient.getTransactionsByHash(\"ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9\");\n     */\n    async getTransactionsByBlockHash(blockHash) {\n        try {\n            const block = await this.fetchData(`/block/${blockHash}`);\n            const height = block.header.metadata.height;\n            return await this.getTransactions(Number(height));\n        }\n        catch (error) {\n            throw new Error(`Error fetching transactions for block ${blockHash}: ${error}`);\n        }\n    }\n    /**\n     * Returns the transactions in the memory pool. This method requires access to a validator's REST API.\n     *\n     * @example\n     * const transactions = networkClient.getTransactionsInMempool();\n     */\n    async getTransactionsInMempool() {\n        try {\n            return await this.fetchData(\"/memoryPool/transactions\");\n        }\n        catch (error) {\n            throw new Error(`Error fetching transactions from mempool: ${error}`);\n        }\n    }\n    /**\n     * Returns the transition ID of the transition corresponding to the ID of the input or output.\n     * @param {string} inputOrOutputID - ID of the input or output.\n     *\n     * @example\n     * const transitionId = networkClient.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n     */\n    async getTransitionId(inputOrOutputID) {\n        try {\n            return await this.fetchData(\"/find/transitionID/\" + inputOrOutputID);\n        }\n        catch (error) {\n            throw new Error(`Error fetching transition ID for input/output ${inputOrOutputID}: ${error}`);\n        }\n    }\n    /**\n     * Submit an execute or deployment transaction to the Aleo network.\n     *\n     * @param {Transaction | string} transaction  - The transaction to submit to the network\n     * @returns {string} - The transaction id of the submitted transaction or the resulting error\n     */\n    async submitTransaction(transaction) {\n        const transaction_string = transaction instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Transaction ? transaction.toString() : transaction;\n        try {\n            const response = await post(this.host + \"/transaction/broadcast\", {\n                body: transaction_string,\n                headers: Object.assign({}, this.headers, {\n                    \"Content-Type\": \"application/json\",\n                }),\n            });\n            try {\n                const text = await response.text();\n                return parseJSON(text);\n            }\n            catch (error) {\n                throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Error posting transaction: No response received: ${error.message}`);\n        }\n    }\n    /**\n     * Submit a solution to the Aleo network.\n     *\n     * @param {string} solution The string representation of the solution desired to be submitted to the network.\n     */\n    async submitSolution(solution) {\n        try {\n            const response = await post(this.host + \"/solution/broadcast\", {\n                body: solution,\n                headers: Object.assign({}, this.headers, {\n                    \"Content-Type\": \"application/json\",\n                }),\n            });\n            try {\n                const text = await response.text();\n                return parseJSON(text);\n            }\n            catch (error) {\n                throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Error posting transaction: No response received: ${error.message}`);\n        }\n    }\n    /**\n     * Await a transaction to be confirmed on the Aleo network.\n     *\n     * @param {string} solution The string representation of the solution desired to be submitted to the network.\n     */\n    async waitForTransactionConfirmation(transactionId, checkInterval = 2000, // Poll every 2 seconds\n    timeout = 45000 // Timeout after 45 seconds\n    ) {\n        const startTime = Date.now();\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(async () => {\n                try {\n                    // Replace with actual Aleo transaction lookup API\n                    const transaction = await this.getTransactionObject(transactionId);\n                    resolve(transaction);\n                    if (Date.now() - startTime > timeout) {\n                        clearInterval(interval);\n                        reject(new Error(\"Transaction confirmation timed out\"));\n                    }\n                }\n                catch (error) {\n                    console.error(\"Error checking transaction:\", error);\n                }\n            }, checkInterval);\n        });\n    }\n}\n\nconst KEY_STORE = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.baseUrl();\nfunction convert(metadata) {\n    // This looks up the method name in VerifyingKey\n    const verifyingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey[metadata.verifyingKey];\n    if (!verifyingKey) {\n        throw new Error(\"Invalid method name: \" + metadata.verifyingKey);\n    }\n    return {\n        name: metadata.name,\n        locator: metadata.locator,\n        prover: metadata.prover,\n        verifier: metadata.verifier,\n        verifyingKey,\n    };\n}\nconst CREDITS_PROGRAM_KEYS = {\n    bond_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.bond_public()),\n    bond_validator: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.bond_validator()),\n    claim_unbond_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.claim_unbond_public()),\n    fee_private: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.fee_private()),\n    fee_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.fee_public()),\n    inclusion: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.inclusion()),\n    join: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.join()),\n    set_validator_state: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.set_validator_state()),\n    split: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.split()),\n    transfer_private: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.transfer_private()),\n    transfer_private_to_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.transfer_private_to_public()),\n    transfer_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.transfer_public()),\n    transfer_public_as_signer: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.transfer_public_as_signer()),\n    transfer_public_to_private: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.transfer_public_to_private()),\n    unbond_public: convert(_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Metadata.unbond_public()),\n    getKey: function (key) {\n        if (this.hasOwnProperty(key)) {\n            return this[key];\n        }\n        else {\n            throw new Error(`Key \"${key}\" not found.`);\n        }\n    }\n};\nconst PRIVATE_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n]);\nconst VALID_TRANSFER_TYPES = new Set([\n    \"transfer_private\",\n    \"private\",\n    \"transferPrivate\",\n    \"transfer_private_to_public\",\n    \"privateToPublic\",\n    \"transferPrivateToPublic\",\n    \"transfer_public\",\n    \"transfer_public_as_signer\",\n    \"public\",\n    \"public_as_signer\",\n    \"transferPublic\",\n    \"transferPublicAsSigner\",\n    \"transfer_public_to_private\",\n    \"publicToPrivate\",\n    \"publicAsSigner\",\n    \"transferPublicToPrivate\",\n]);\nconst PRIVATE_TRANSFER = new Set([\n    \"private\",\n    \"transfer_private\",\n    \"transferPrivate\",\n]);\nconst PRIVATE_TO_PUBLIC_TRANSFER = new Set([\n    \"private_to_public\",\n    \"privateToPublic\",\n    \"transfer_private_to_public\",\n    \"transferPrivateToPublic\",\n]);\nconst PUBLIC_TRANSFER = new Set([\n    \"public\",\n    \"transfer_public\",\n    \"transferPublic\",\n]);\nconst PUBLIC_TRANSFER_AS_SIGNER = new Set([\n    \"public_as_signer\",\n    \"transfer_public_as_signer\",\n    \"transferPublicAsSigner\",\n]);\nconst PUBLIC_TO_PRIVATE_TRANSFER = new Set([\n    \"public_to_private\",\n    \"publicToPrivate\",\n    \"transfer_public_to_private\",\n    \"transferPublicToPrivate\",\n]);\n\n/**\n * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and\n * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.\n */\nclass AleoKeyProviderParams {\n    name;\n    proverUri;\n    verifierUri;\n    cacheKey;\n    /**\n     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally\n     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique\n     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must\n     * be provided.\n     *\n     * @param { AleoKeyProviderInitParams } params - Optional search parameters\n     */\n    constructor(params) {\n        this.proverUri = params.proverUri;\n        this.verifierUri = params.verifierUri;\n        this.cacheKey = params.cacheKey;\n        this.name = params.name;\n    }\n}\n/**\n * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and\n * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function\n * keys from a local memory cache.\n */\nclass AleoKeyProvider {\n    cache;\n    cacheOption;\n    keyUris;\n    async fetchBytes(url = \"/\") {\n        try {\n            const response = await get(url);\n            const data = await response.arrayBuffer();\n            return new Uint8Array(data);\n        }\n        catch (error) {\n            throw new Error(\"Error fetching data.\" + error.message);\n        }\n    }\n    constructor() {\n        this.keyUris = KEY_STORE;\n        this.cache = new Map();\n        this.cacheOption = false;\n    }\n    /**\n     * Use local memory to store keys\n     *\n     * @param {boolean} useCache whether to store keys in local memory\n     */\n    useCache(useCache) {\n        this.cacheOption = useCache;\n    }\n    /**\n     * Clear the key cache\n     */\n    clearCache() {\n        this.cache.clear();\n    }\n    /**\n     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId\n     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.\n     *\n     * @param {string} keyId access key for the cache\n     * @param {FunctionKeyPair} keys keys to cache\n     */\n    cacheKeys(keyId, keys) {\n        const [provingKey, verifyingKey] = keys;\n        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);\n    }\n    /**\n     * Determine if a keyId exists in the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair\n     * @returns {boolean} true if the keyId exists in the cache, false otherwise\n     */\n    containsKeys(keyId) {\n        return this.cache.has(keyId);\n    }\n    /**\n     * Delete a set of keys from the cache\n     *\n     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory\n     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist\n     */\n    deleteKeys(keyId) {\n        return this.cache.delete(keyId);\n    }\n    /**\n     * Get a set of keys from the cache\n     * @param keyId keyId of a proving and verifying key pair\n     *\n     * @returns {FunctionKeyPair} Proving and verifying keys for the specified program\n     */\n    getKeys(keyId) {\n        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`);\n        if (this.cache.has(keyId)) {\n            const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);\n            return [_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(provingKeyBytes), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey.fromBytes(verifyingKeyBytes)];\n        }\n        else {\n            throw new Error(\"Key not found in cache.\");\n        }\n    }\n    /**\n     * Get arbitrary function keys from a provider\n     *\n     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new object which implements the KeyProvider interface\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually using the key provider\n     * const keySearchParams = { \"cacheKey\": \"myProgram:myFunction\" };\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);\n     */\n    async functionKeys(params) {\n        if (params) {\n            let proverUrl;\n            let verifierUrl;\n            let cacheKey;\n            if (\"name\" in params && typeof params[\"name\"] == \"string\") {\n                let key = CREDITS_PROGRAM_KEYS.getKey(params[\"name\"]);\n                return this.fetchCreditsKeys(key);\n            }\n            if (\"proverUri\" in params && typeof params[\"proverUri\"] == \"string\") {\n                proverUrl = params[\"proverUri\"];\n            }\n            if (\"verifierUri\" in params && typeof params[\"verifierUri\"] == \"string\") {\n                verifierUrl = params[\"verifierUri\"];\n            }\n            if (\"cacheKey\" in params && typeof params[\"cacheKey\"] == \"string\") {\n                cacheKey = params[\"cacheKey\"];\n            }\n            if (proverUrl && verifierUrl) {\n                return await this.fetchRemoteKeys(proverUrl, verifierUrl, cacheKey);\n            }\n            if (cacheKey) {\n                return this.getKeys(cacheKey);\n            }\n        }\n        throw new Error(\"Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl\");\n    }\n    /**\n     * Returns the proving and verifying keys for a specified program from a specified url.\n     *\n     * @param {string} verifierUrl Url of the proving key\n     * @param {string} proverUrl Url the verifying key\n     * @param {string} cacheKey Key to store the keys in the cache\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program\n     *\n     * @example\n     * // Create a new AleoKeyProvider object\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(\n     *     CREDITS_PROGRAM_KEYS.transfer_private.prover,\n     *     CREDITS_PROGRAM_KEYS.transfer_private.verifier,\n     * );\n     */\n    async fetchRemoteKeys(proverUrl, verifierUrl, cacheKey) {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return [_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(value[0]), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey.fromBytes(value[1])];\n                }\n                else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                    console.debug(\"Fetching verifying keys \" + verifierUrl);\n                    const verifyingKey = (await this.getVerifyingKey(verifierUrl));\n                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);\n                    return [provingKey, verifyingKey];\n                }\n            }\n            else {\n                // If cache is disabled, fetch the keys and return them\n                const provingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                const verifyingKey = (await this.getVerifyingKey(verifierUrl));\n                return [provingKey, verifyingKey];\n            }\n        }\n        catch (error) {\n            throw new Error(`Error: ${error.message} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);\n        }\n    }\n    /***\n     * Fetches the proving key from a remote source.\n     *\n     * @param proverUrl\n     * @param cacheKey\n     *\n     * @returns {Promise<ProvingKey>} Proving key for the specified program\n     */\n    async fetchProvingKey(proverUrl, cacheKey) {\n        try {\n            // If cache is enabled, check if the keys have already been fetched and return them if they have\n            if (this.cacheOption) {\n                if (!cacheKey) {\n                    cacheKey = proverUrl;\n                }\n                const value = this.cache.get(cacheKey);\n                if (typeof value !== \"undefined\") {\n                    return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(value[0]);\n                }\n                else {\n                    console.debug(\"Fetching proving keys from url \" + proverUrl);\n                    const provingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                    return provingKey;\n                }\n            }\n            else {\n                const provingKey = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(await this.fetchBytes(proverUrl));\n                return provingKey;\n            }\n        }\n        catch (error) {\n            throw new Error(`Error: ${error.message} fetching fee proving keys from ${proverUrl}`);\n        }\n    }\n    async fetchCreditsKeys(key) {\n        try {\n            if (!this.cache.has(key.locator) || !this.cacheOption) {\n                const verifying_key = key.verifyingKey();\n                const proving_key = await this.fetchProvingKey(key.prover, key.locator);\n                if (this.cacheOption) {\n                    this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [proving_key.toBytes(), verifying_key.toBytes()]);\n                }\n                return [proving_key, verifying_key];\n            }\n            else {\n                const keyPair = this.cache.get(key.locator);\n                return [_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProvingKey.fromBytes(keyPair[0]), _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey.fromBytes(keyPair[1])];\n            }\n        }\n        catch (error) {\n            throw new Error(`Error: fetching credits.aleo keys: ${error.message}`);\n        }\n    }\n    async bondPublicKeys() {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_public);\n    }\n    bondValidatorKeys() {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_validator);\n    }\n    claimUnbondPublicKeys() {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public);\n    }\n    /**\n     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program\n     * @param {string} visibility Visibility of the transfer function\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer functions\n     *\n     * @example\n     * // Create a new AleoKeyProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * programManager.transfer(1, \"aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at\", \"public\", 0.5);\n     *\n     * // Keys can also be fetched manually\n     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys(\"public\");\n     */\n    async transferKeys(visibility) {\n        if (PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private);\n        }\n        else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public);\n        }\n        else if (PUBLIC_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);\n        }\n        else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_as_signer);\n        }\n        else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {\n            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private);\n        }\n        else {\n            throw new Error(\"Invalid visibility type\");\n        }\n    }\n    /**\n     * Returns the proving and verifying keys for the join function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function\n     */\n    async joinKeys() {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.join);\n    }\n    /**\n     * Returns the proving and verifying keys for the split function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the split function\n     * */\n    async splitKeys() {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.split);\n    }\n    /**\n     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePrivateKeys() {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_private);\n    }\n    /**\n     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program\n     *\n     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function\n     */\n    async feePublicKeys() {\n        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_public);\n    }\n    /**\n     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise\n     *\n     * @returns {Promise<VerifyingKey>} Verifying key for the function\n     */\n    // attempt to fetch it from the network\n    async getVerifyingKey(verifierUri) {\n        switch (verifierUri) {\n            case CREDITS_PROGRAM_KEYS.bond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.bond_validator.verifier:\n                return CREDITS_PROGRAM_KEYS.bond_validator.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_private.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.fee_public.verifier:\n                return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.inclusion.verifier:\n                return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.join.verifier:\n                return CREDITS_PROGRAM_KEYS.join.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:\n                return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.split.verifier:\n                return CREDITS_PROGRAM_KEYS.split.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:\n                return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();\n            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:\n                return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();\n            default:\n                try {\n                    /// Try to fetch the verifying key from the network as a string\n                    const response = await get(verifierUri);\n                    const text = await response.text();\n                    return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey.fromString(text);\n                }\n                catch (e) {\n                    /// If that fails, try to fetch the verifying key from the network as bytes\n                    try {\n                        return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));\n                    }\n                    catch (inner) {\n                        throw new Error(\"Invalid verifying key. Error: \" + inner.message);\n                    }\n                }\n        }\n    }\n    unBondPublicKeys() {\n        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.unbond_public);\n    }\n}\n\n/**\n * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.\n */\nclass ProgramManager {\n    account;\n    keyProvider;\n    host;\n    networkClient;\n    recordProvider;\n    /** Create a new instance of the ProgramManager\n     *\n     * @param { string | undefined } host A host uri running the official Aleo API\n     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface\n     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface\n     */\n    constructor(host, keyProvider, recordProvider) {\n        this.host = host ? host : 'https://api.explorer.provable.com/v1';\n        this.networkClient = new AleoNetworkClient(this.host);\n        this.keyProvider = keyProvider ? keyProvider : new AleoKeyProvider();\n        this.recordProvider = recordProvider;\n    }\n    /**\n     * Set the account to use for transaction submission to the Aleo network\n     *\n     * @param {Account} account Account to use for transaction submission\n     */\n    setAccount(account) {\n        this.account = account;\n    }\n    /**\n     * Set the key provider that provides the proving and verifying keys for programs\n     *\n     * @param {FunctionKeyProvider} keyProvider\n     */\n    setKeyProvider(keyProvider) {\n        this.keyProvider = keyProvider;\n    }\n    /**\n     * Set the host peer to use for transaction submission to the Aleo network\n     *\n     * @param host {string} Peer url to use for transaction submission\n     */\n    setHost(host) {\n        this.host = host;\n        this.networkClient.setHost(host);\n    }\n    /**\n     * Set the record provider that provides records for transactions\n     *\n     * @param {RecordProvider} recordProvider\n     */\n    setRecordProvider(recordProvider) {\n        this.recordProvider = recordProvider;\n    }\n    /**\n     * Builds a deployment transaction for submission to the Aleo network.\n     *\n     * @param {string} program Program source code\n     * @param {number} fee Fee to pay for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use\n     * pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Define a fee in credits\n     * const fee = 1.2;\n     *\n     * // Create the deployment transaction.\n     * const tx = await programManager.buildDeploymentTransaction(program, fee, false);\n     */\n    async buildDeploymentTransaction(program, fee, privateFee, recordSearchParams, feeRecord, privateKey) {\n        // Ensure the program is valid and does not exist on the network\n        try {\n            const programObject = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString(program);\n            let programSource;\n            try {\n                programSource = await this.networkClient.getProgram(programObject.id());\n            }\n            catch (e) {\n                // Program does not exist on the network, deployment can proceed\n                console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);\n            }\n            if (typeof programSource == \"string\") {\n                throw (`Program ${programObject.id()} already exists on the network, please rename your program`);\n            }\n        }\n        catch (e) {\n            logAndThrow(`Error validating program: ${e.message}`);\n        }\n        // Get the private key from the account if it is not provided in the parameters\n        let deploymentPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            deploymentPrivateKey = this.account.privateKey();\n        }\n        if (typeof deploymentPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        // Resolve the program imports if they exist\n        let imports;\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n        }\n        catch (e) {\n            logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);\n        }\n        // Build a deployment transaction and submit it to the network\n        return await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.buildDeploymentTransaction(deploymentPrivateKey, program, fee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);\n    }\n    /**\n     * Deploy an Aleo program to the Aleo network\n     *\n     * @param {string} program Program source code\n     * @param {number} fee Fee to pay for the transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use\n     * pay the deployment fee\n     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @returns {string} The transaction id of the deployed program or a failure message from the network\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for deployments\n     * const program = \"program hello_hello.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Define a fee in credits\n     * const fee = 1.2;\n     *\n     * // Deploy the program\n     * const tx_id = await programManager.deploy(program, fee, false);\n     *\n     * // Verify the transaction was successful\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async deploy(program, fee, privateFee, recordSearchParams, feeRecord, privateKey) {\n        const tx = await this.buildDeploymentTransaction(program, fee, privateFee, recordSearchParams, feeRecord, privateKey);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const transaction = await programManager.buildExecutionTransaction({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   fee: 0.020,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     * const result = await programManager.networkClient.submitTransaction(transaction);\n     */\n    async buildExecutionTransaction(options) {\n        // Destructure the options object to access the parameters\n        const { programName, functionName, fee, privateFee, inputs, recordSearchParams, keySearchParams, privateKey, offlineQuery } = options;\n        let feeRecord = options.feeRecord;\n        let provingKey = options.provingKey;\n        let verifyingKey = options.verifyingKey;\n        let program = options.program;\n        let imports = options.imports;\n        // Ensure the function exists on the network\n        if (program === undefined) {\n            try {\n                program = (await this.networkClient.getProgram(programName));\n            }\n            catch (e) {\n                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);\n            }\n        }\n        else if (program instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program) {\n            program = program.toString();\n        }\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n        // Get the fee proving and verifying keys from the key provider\n        let feeKeys;\n        try {\n            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);\n            }\n            catch (e) {\n                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);\n            }\n        }\n        // Resolve the program imports if they exist\n        const numberOfImports = _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString(program).getImports().length;\n        if (numberOfImports > 0 && !imports) {\n            try {\n                imports = await this.networkClient.getProgramImports(programName);\n            }\n            catch (e) {\n                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);\n            }\n        }\n        // Build an execution transaction and submit it to the network\n        return await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.buildExecutionTransaction(executionPrivateKey, program, functionName, inputs, fee, feeRecord, this.host, imports, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n    }\n    /**\n     * Builds an execution transaction for submission to the Aleo network.\n     *\n     * @param {ExecuteOptions} options - The options for the execution transaction.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     *\n     * // Build and execute the transaction\n     * const transaction = await programManager.execute({\n     *   programName: \"hello_hello.aleo\",\n     *   functionName: \"hello_hello\",\n     *   fee: 0.020,\n     *   privateFee: false,\n     *   inputs: [\"5u32\", \"5u32\"],\n     *   keySearchParams: { \"cacheKey\": \"hello_hello:hello\" }\n     * });\n     * const result = await programManager.networkClient.submitTransaction(transaction);\n     */\n    async execute(options) {\n        const tx = await this.buildExecutionTransaction(options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Run an Aleo program in offline mode\n     *\n     * @param {string} program Program source code containing the function to be executed\n     * @param {string} function_name Function name to execute\n     * @param {string[]} inputs Inputs to the function\n     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript\n     * that contains the proof.\n     * @param {string[] | undefined} imports Optional imports to the program\n     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving &\n     * verifying keys for the function\n     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction\n     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>}\n     *\n     * @example\n     * import { Account, Program } from '@provablehq/sdk';\n     *\n     * /// Create the source for the \"helloworld\" program\n     * const program = \"program helloworld.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n\";\n     * const programManager = new ProgramManager();\n     *\n     * /// Create a temporary account for the execution of the program\n     * const account = new Account();\n     * programManager.setAccount(account);\n     *\n     * /// Get the response and ensure that the program executed correctly\n     * const executionResponse = await programManager.run(program, \"hello\", [\"5u32\", \"5u32\"]);\n     * const result = executionResponse.getOutputs();\n     * assert(result === [\"10u32\"]);\n     */\n    async run(program, function_name, inputs, proveExecution, imports, keySearchParams, provingKey, verifyingKey, privateKey, offlineQuery) {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // If the function proving and verifying keys are not provided, attempt to find them using the key provider\n        if (!provingKey || !verifyingKey) {\n            try {\n                [provingKey, verifyingKey] = await this.keyProvider.functionKeys(keySearchParams);\n            }\n            catch (e) {\n                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);\n            }\n        }\n        // Run the program offline and return the result\n        console.log(\"Running program offline\");\n        console.log(\"Proving key: \", provingKey);\n        console.log(\"Verifying key: \", verifyingKey);\n        return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.executeFunctionOffline(executionPrivateKey, program, function_name, inputs, proveExecution, false, imports, provingKey, verifyingKey, this.host, offlineQuery);\n    }\n    /**\n     * Join two credits records into a single credits record\n     *\n     * @param {RecordPlaintext | string} recordOne First credits record to join\n     * @param {RecordPlaintext | string} recordTwo Second credits record to join\n     * @param {number} fee Fee in credits pay for the join transaction\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use\n     * to pay the fee for the join transaction\n     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction\n     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>}\n     */\n    async join(recordOne, recordTwo, fee, privateFee, recordSearchParams, feeRecord, privateKey, offlineQuery) {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof privateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let joinKeys;\n        try {\n            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();\n            joinKeys = await this.keyProvider.joinKeys();\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [joinProvingKey, joinVerifyingKey] = joinKeys;\n        // Get the fee record from the account if it is not provided in the parameters\n        try {\n            feeRecord = privateFee ? await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams) : undefined;\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n        // Validate the records provided are valid plaintext records\n        try {\n            recordOne = recordOne instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext ? recordOne : _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext.fromString(recordOne);\n            recordTwo = recordTwo instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext ? recordTwo : _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext.fromString(recordTwo);\n        }\n        catch (e) {\n            logAndThrow('Records provided are not valid. Please ensure they are valid plaintext records.');\n        }\n        // Build an execution transaction and submit it to the network\n        const tx = await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.buildJoinTransaction(executionPrivateKey, recordOne, recordTwo, fee, feeRecord, this.host, joinProvingKey, joinVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Split credits into two new credits records\n     *\n     * @param {number} splitAmount Amount in microcredits to split from the original credits record\n     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>}\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * const record = \"{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}\"\n     * const tx_id = await programManager.split(25000000, record);\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async split(splitAmount, amountRecord, privateKey, offlineQuery) {\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // Get the split keys from the key provider\n        let splitKeys;\n        try {\n            splitKeys = await this.keyProvider.splitKeys();\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [splitProvingKey, splitVerifyingKey] = splitKeys;\n        // Validate the record to be split\n        try {\n            amountRecord = amountRecord instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext ? amountRecord : _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext.fromString(amountRecord);\n        }\n        catch (e) {\n            logAndThrow(\"Record provided is not valid. Please ensure it is a valid plaintext record.\");\n        }\n        // Build an execution transaction and submit it to the network\n        const tx = await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.buildSplitTransaction(executionPrivateKey, splitAmount, amountRecord, this.host, splitProvingKey, splitVerifyingKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Pre-synthesize proving and verifying keys for a program\n     *\n     * @param program {string} The program source code to synthesize keys for\n     * @param function_id {string} The function id to synthesize keys for\n     * @param inputs {Array<string>}  Sample inputs to the function\n     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis\n     *\n     * @returns {Promise<FunctionKeyPair>}\n     */\n    async synthesizeKeys(program, function_id, inputs, privateKey) {\n        // Resolve the program imports if they exist\n        let imports;\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\") {\n            if (typeof this.account !== \"undefined\") {\n                executionPrivateKey = this.account.privateKey();\n            }\n            else {\n                executionPrivateKey = new _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey();\n            }\n        }\n        // Attempt to run an offline execution of the program and extract the proving and verifying keys\n        try {\n            imports = await this.networkClient.getProgramImports(program);\n            const keyPair = await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.synthesizeKeyPair(executionPrivateKey, program, function_id, inputs, imports);\n            return [keyPair.provingKey(), keyPair.verifyingKey()];\n        }\n        catch (e) {\n            logAndThrow(`Could not synthesize keys - error ${e.message}. Please ensure the program is valid and the inputs are correct.`);\n        }\n    }\n    /**\n     * Build a transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id of the transfer transaction\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programName = \"hello_hello.aleo\";\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * await programManager.initialize();\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"private\", 0.2)\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async buildTransferTransaction(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {\n        // Validate the transfer type\n        transferType = validateTransferType(transferType);\n        // Get the private key from the account if it is not provided in the parameters\n        let executionPrivateKey = privateKey;\n        if (typeof executionPrivateKey === \"undefined\" && typeof this.account !== \"undefined\") {\n            executionPrivateKey = this.account.privateKey();\n        }\n        if (typeof executionPrivateKey === \"undefined\") {\n            throw (\"No private key provided and no private key set in the ProgramManager\");\n        }\n        // Get the proving and verifying keys from the key provider\n        let feeKeys;\n        let transferKeys;\n        try {\n            feeKeys = privateFee ? await this.keyProvider.feePrivateKeys() : await this.keyProvider.feePublicKeys();\n            transferKeys = await this.keyProvider.transferKeys(transferType);\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);\n        }\n        const [feeProvingKey, feeVerifyingKey] = feeKeys;\n        const [transferProvingKey, transferVerifyingKey] = transferKeys;\n        // Get the amount and fee record from the account if it is not provided in the parameters\n        try {\n            // Track the nonces of the records found so no duplicate records are used\n            const nonces = [];\n            if (requiresAmountRecord(transferType)) {\n                // If the transfer type is private and requires an amount record, get it from the record provider\n                amountRecord = await this.getCreditsRecord(fee, [], amountRecord, recordSearchParams);\n                nonces.push(amountRecord.nonce());\n            }\n            else {\n                amountRecord = undefined;\n            }\n            feeRecord = privateFee ? await this.getCreditsRecord(fee, nonces, feeRecord, recordSearchParams) : undefined;\n        }\n        catch (e) {\n            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n        }\n        // Build an execution transaction and submit it to the network\n        return await _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.ProgramManager.buildTransferTransaction(executionPrivateKey, amount, recipient, transferType, amountRecord, fee, feeRecord, this.host, transferProvingKey, transferVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);\n    }\n    /**\n     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id of the transfer transaction\n     */\n    async buildTransferPublicTransaction(amount, recipient, fee, privateKey, offlineQuery) {\n        return this.buildTransferTransaction(amount, recipient, \"public\", fee, false, undefined, undefined, undefined, privateKey, offlineQuery);\n    }\n    /**\n     * Build a transfer_public_as_signer transaction to transfer credits to another account for later submission to the Aleo network\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id of the transfer transaction\n     */\n    async buildTransferPublicAsSignerTransaction(amount, recipient, fee, privateKey, offlineQuery) {\n        return this.buildTransferTransaction(amount, recipient, \"public\", fee, false, undefined, undefined, undefined, privateKey, offlineQuery);\n    }\n    /**\n     * Transfer credits to another account\n     *\n     * @param {number} amount The amount of credits to transfer\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'\n     * @param {number} fee The fee to pay for the transfer\n     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance\n     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee\n     * records for the transfer transaction\n     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer\n     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer\n     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction\n     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment\n     * @returns {Promise<string>} The transaction id of the transfer transaction\n     *\n     * @example\n     * // Create a new NetworkClient, KeyProvider, and RecordProvider\n     * const networkClient = new AleoNetworkClient(\"https://api.explorer.provable.com/v1\");\n     * const keyProvider = new AleoKeyProvider();\n     * const recordProvider = new NetworkRecordProvider(account, networkClient);\n     *\n     * // Initialize a program manager with the key provider to automatically fetch keys for executions\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, recordProvider);\n     * await programManager.initialize();\n     * const tx_id = await programManager.transfer(1, \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"private\", 0.2)\n     * const transaction = await programManager.networkClient.getTransaction(tx_id);\n     */\n    async transfer(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {\n        const tx = await this.buildTransferTransaction(amount, recipient, transferType, fee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Build transaction to bond credits to a validator for later submission to the Aleo Network\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction object for later submission\n     * const tx = await programManager.buildBondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     * console.log(tx);\n     *\n     * // The transaction can be later submitted to the network using the network client.\n     * const result = await programManager.networkClient.submitTransaction(tx);\n     *\n     * @returns string\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     */\n    async buildBondPublicTransaction(validator_address, withdrawal_address, amount, options = {}) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n        const { programName = \"credits.aleo\", functionName = \"bond_public\", fee = options.fee || 0.86, privateFee = false, inputs = [validator_address, withdrawal_address, `${scaledAmount.toString()}u64`], keySearchParams = new AleoKeyProviderParams({\n            proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,\n            verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,\n            cacheKey: \"credits.aleo/bond_public\"\n        }), program = this.creditsProgram(), ...additionalOptions } = options;\n        const executeOptions = {\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions\n        };\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n    /**\n     * Bond credits to validator.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * @returns string\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the signer (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {Options} options Options for the execution\n     */\n    async bondPublic(validator_address, withdrawal_address, amount, options = {}) {\n        const tx = await this.buildBondPublicTransaction(validator_address, withdrawal_address, amount, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Build a bond_validator transaction for later submission to the Aleo Network.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bond validator transaction object for later use.\n     * const tx = await programManager.buildBondValidatorTransaction(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     * console.log(tx);\n     *\n     * // The transaction can later be submitted to the network using the network client.\n     * const tx_id = await programManager.networkClient.submitTransaction(tx);\n     *\n     * @returns string\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     */\n    async buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options = {}) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n        const adjustedCommission = Math.trunc(commission);\n        const { programName = \"credits.aleo\", functionName = \"bond_validator\", fee = options.fee || 0.86, privateFee = false, inputs = [validator_address, withdrawal_address, `${scaledAmount.toString()}u64`, `${adjustedCommission.toString()}u8`], keySearchParams = new AleoKeyProviderParams({\n            proverUri: CREDITS_PROGRAM_KEYS.bond_validator.prover,\n            verifierUri: CREDITS_PROGRAM_KEYS.bond_validator.verifier,\n            cacheKey: \"credits.aleo/bond_validator\"\n        }), program = this.creditsProgram(), ...additionalOptions } = options;\n        const executeOptions = {\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions\n        };\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n    /**\n     * Build transaction to bond a validator.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.bondValidator(\"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\", \"aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9\", 2000000);\n     *\n     * @returns string\n     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the\n     * executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently\n     * requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing\n     * validator and is different from the address of the executor of this function, it will bond the credits to that\n     * validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.\n     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.\n     * @param {number} amount The amount of credits to bond\n     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     */\n    async bondValidator(validator_address, withdrawal_address, amount, commission, options = {}) {\n        const tx = await this.buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Build a transaction to unbond public credits from a validator in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is unbonding the credits.\n     * @param {number} amount - The amount of credits to unbond (scaled by 1,000,000).\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Create a keyProvider to handle key management.\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to unbond credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * const tx = await programManager.buildUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 2000000);\n     * console.log(tx);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx);\n     */\n    async buildUnbondPublicTransaction(staker_address, amount, options = {}) {\n        const scaledAmount = Math.trunc(amount * 1000000);\n        const { programName = \"credits.aleo\", functionName = \"unbond_public\", fee = options.fee || 1.3, privateFee = false, inputs = [staker_address, `${scaledAmount.toString()}u64`], keySearchParams = new AleoKeyProviderParams({\n            proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,\n            verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,\n            cacheKey: \"credits.aleo/unbond_public\"\n        }), program = this.creditsProgram(), ...additionalOptions } = options;\n        const executeOptions = {\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions\n        };\n        return this.buildExecutionTransaction(executeOptions);\n    }\n    /**\n     * Unbond a specified amount of staked credits.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction and send it to the network\n     * const tx_id = await programManager.unbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\", 10);\n     *\n     * @returns string\n     * @param {string} staker_address Address of the staker who is unbonding the credits\n     * @param {number} amount Amount of credits to unbond. If the address of the executor of this function is an\n     * existing validator, it will subtract this amount of credits from the validator's staked credits. If there are\n     * less than 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set.\n     * If the address of the executor of this function is not a validator and has credits bonded as a delegator, it will\n     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded\n     * after the unbond operation, the delegator will be removed from the validator's staking pool.\n     * @param {ExecuteOptions} options Options for the execution\n     */\n    async unbondPublic(staker_address, amount, options = {}) {\n        const tx = await this.buildUnbondPublicTransaction(staker_address, amount, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Build a transaction to claim unbonded public credits in the Aleo network.\n     *\n     * @param {string} staker_address - The address of the staker who is claiming the credits.\n     * @param {Partial<ExecuteOptions>} options - Override default execution options.\n     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to claim unbonded credits.\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     *\n     * // Create the claim unbonded transaction object for later use.\n     * const tx = await programManager.buildClaimUnbondPublicTransaction(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     * console.log(tx);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx);\n     */\n    async buildClaimUnbondPublicTransaction(staker_address, options = {}) {\n        const { programName = \"credits.aleo\", functionName = \"claim_unbond_public\", fee = options.fee || 2, privateFee = false, inputs = [staker_address], keySearchParams = new AleoKeyProviderParams({\n            proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,\n            verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,\n            cacheKey: \"credits.aleo/claim_unbond_public\"\n        }), program = this.creditsProgram(), ...additionalOptions } = options;\n        const executeOptions = {\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions\n        };\n        return await this.buildExecutionTransaction(executeOptions);\n    }\n    /**\n     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will\n     * claim them and add them to the public balance of the account.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"YourPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.claimUnbondPublic(\"aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j\");\n     *\n     * @param {string} staker_address Address of the staker who is claiming the credits\n     * @param {ExecuteOptions} options\n     * @returns string\n     */\n    async claimUnbondPublic(staker_address, options = {}) {\n        const tx = await this.buildClaimUnbondPublicTransaction(staker_address, options);\n        return await this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Build a set_validator_state transaction for later usage.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"ValidatorPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx = await programManager.buildSetValidatorStateTransaction(true);\n     *\n     * // The transaction can be submitted later to the network using the network client.\n     * programManager.networkClient.submitTransaction(tx);\n     *\n     * @returns string\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     */\n    async buildSetValidatorStateTransaction(validator_state, options = {}) {\n        const { programName = \"credits.aleo\", functionName = \"set_validator_state\", fee = 1, privateFee = false, inputs = [validator_state.toString()], keySearchParams = new AleoKeyProviderParams({\n            proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,\n            verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,\n            cacheKey: \"credits.aleo/set_validator_state\"\n        }), ...additionalOptions } = options;\n        const executeOptions = {\n            programName,\n            functionName,\n            fee,\n            privateFee,\n            inputs,\n            keySearchParams,\n            ...additionalOptions\n        };\n        return await this.execute(executeOptions);\n    }\n    /**\n     * Submit a set_validator_state transaction to the Aleo Network.\n     *\n     * This function allows a validator to set their state to be either opened or closed to new stakers.\n     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.\n     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.\n     *\n     * This function serves two primary purposes:\n     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.\n     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.\n     *\n     * @example\n     * // Create a keyProvider to handle key management\n     * const keyProvider = new AleoKeyProvider();\n     * keyProvider.useCache = true;\n     *\n     * // Create a new ProgramManager with the key that will be used to bond credits\n     * const programManager = new ProgramManager(\"https://api.explorer.provable.com/v1\", keyProvider, undefined);\n     * programManager.setAccount(new Account(\"ValidatorPrivateKey\"));\n     *\n     * // Create the bonding transaction\n     * const tx_id = await programManager.setValidatorState(true);\n     *\n     * @returns string\n     * @param {boolean} validator_state\n     * @param {Partial<ExecuteOptions>} options - Override default execution options\n     */\n    async setValidatorState(validator_state, options = {}) {\n        const tx = await this.buildSetValidatorStateTransaction(validator_state, options);\n        return this.networkClient.submitTransaction(tx);\n    }\n    /**\n     * Verify a proof of execution from an offline execution\n     *\n     * @param {executionResponse} executionResponse\n     * @returns {boolean} True if the proof is valid, false otherwise\n     */\n    verifyExecution(executionResponse) {\n        try {\n            const execution = executionResponse.getExecution();\n            const function_id = executionResponse.getFunctionId();\n            const program = executionResponse.getProgram();\n            const verifyingKey = executionResponse.getVerifyingKey();\n            return (0,_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.verifyFunctionExecution)(execution, verifyingKey, program, function_id);\n        }\n        catch (e) {\n            console.warn(\"The execution was not found in the response, cannot verify the execution\");\n            return false;\n        }\n    }\n    /**\n     * Create a program object from a program's source code\n     *\n     * @param {string} program Program source code\n     * @returns {Program} The program object\n     */\n    createProgramFromSource(program) {\n        return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString(program);\n    }\n    /**\n     * Get the credits program object\n     *\n     * @returns {Program} The credits program object\n     */\n    creditsProgram() {\n        return _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.getCreditsProgram();\n    }\n    /**\n     * Verify a program is valid\n     *\n     * @param {string} program The program source code\n     */\n    verifyProgram(program) {\n        try {\n            _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.Program.fromString(program);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    // Internal utility function for getting a credits.aleo record\n    async getCreditsRecord(amount, nonces, record, params) {\n        try {\n            return record instanceof _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext ? record : _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_0__.RecordPlaintext.fromString(record);\n        }\n        catch (e) {\n            try {\n                const recordProvider = this.recordProvider;\n                return (await recordProvider.findCreditsRecord(amount, true, nonces, params));\n            }\n            catch (e) {\n                logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);\n            }\n        }\n    }\n}\n// Ensure the transfer type requires an amount record\nfunction requiresAmountRecord(transferType) {\n    return PRIVATE_TRANSFER_TYPES.has(transferType);\n}\n// Validate the transfer type\nfunction validateTransferType(transferType) {\n    return VALID_TRANSFER_TYPES.has(transferType) ? transferType :\n        logAndThrow(`Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`);\n}\n\n\n//# sourceMappingURL=program-manager-CjvnOyfn.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L3Byb2dyYW0tbWFuYWdlci1DanZuT3lmbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOE47O0FBRTlOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qixl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QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsZUFBZSxnRUFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3RUFBZSxZQUFZLHdFQUFlO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFVBQVU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEOztBQUU2VztBQUM3VyIsInNvdXJjZXMiOlsiL2hvbWUvdXNlcm5hbWUvYWxlby9yYXRlLWxpbWl0aW5nLW51bGxpZmllci9ybG4tbWVzc2FnZS1ib2FyZC9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L3Byb2dyYW0tbWFuYWdlci1DanZuT3lmbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcml2YXRlS2V5LCBSZWNvcmRDaXBoZXJ0ZXh0LCBQcm9ncmFtLCBQbGFpbnRleHQsIFRyYW5zYWN0aW9uLCBNZXRhZGF0YSwgVmVyaWZ5aW5nS2V5LCBQcm92aW5nS2V5LCBQcm9ncmFtTWFuYWdlciBhcyBQcm9ncmFtTWFuYWdlciQxLCBSZWNvcmRQbGFpbnRleHQsIHZlcmlmeUZ1bmN0aW9uRXhlY3V0aW9uIH0gZnJvbSAnQHByb3ZhYmxlaHEvd2FzbS90ZXN0bmV0LmpzJztcblxuZnVuY3Rpb24gbG9nQW5kVGhyb3cobWVzc2FnZSkge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gcGFyc2VKU09OKGpzb24pIHtcbiAgICBmdW5jdGlvbiByZXZpdmUoa2V5LCB2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoY29udGV4dC5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24sIHJldml2ZSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXQodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIGNvdWxkIG5vdCBnZXQgVVJMIFwiICsgdXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9zdCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBjb3VsZCBub3QgcG9zdCBVUkwgXCIgKyB1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogQ2xpZW50IGxpYnJhcnkgdGhhdCBlbmNhcHN1bGF0ZXMgUkVTVCBjYWxscyB0byBwdWJsaWNseSBleHBvc2VkIGVuZHBvaW50cyBvZiBBbGVvIG5vZGVzLiBUaGUgbWV0aG9kcyBwcm92aWRlZCBpbiB0aGlzXG4gKiBhbGxvdyB1c2VycyB0byBxdWVyeSBwdWJsaWMgaW5mb3JtYXRpb24gZnJvbSB0aGUgQWxlbyBibG9ja2NoYWluIGFuZCBzdWJtaXQgdHJhbnNhY3Rpb25zIHRvIHRoZSBuZXR3b3JrLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gKiBAZXhhbXBsZVxuICogLy8gQ29ubmVjdGlvbiB0byBhIGxvY2FsIG5vZGVcbiAqIGNvbnN0IGxvY2FsTmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAzMFwiKTtcbiAqXG4gKiAvLyBDb25uZWN0aW9uIHRvIGEgcHVibGljIGJlYWNvbiBub2RlXG4gKiBjb25zdCBhY2NvdW50ID0gQWNjb3VudC5mcm9tQ2lwaGVydGV4dChwcm9jZXNzLmVudi5jaXBoZXJ0ZXh0LCBwcm9jZXNzLmVudi5wYXNzd29yZCk7XG4gKiBjb25zdCBwdWJsaWNuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cDovL2xvY2FsaG9zdDozMDMwXCIsIHVuZGVmaW5lZCwgYWNjb3VudCk7XG4gKi9cbmNsYXNzIEFsZW9OZXR3b3JrQ2xpZW50IHtcbiAgICBob3N0O1xuICAgIGhlYWRlcnM7XG4gICAgYWNjb3VudDtcbiAgICBjb25zdHJ1Y3Rvcihob3N0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3QgKyBcIi90ZXN0bmV0XCI7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgdGhlIGFjdHVhbCB2ZXJzaW9uIGJ5IGEgUm9sbHVwIHBsdWdpblxuICAgICAgICAgICAgICAgIFwiWC1BbGVvLVNESy1WZXJzaW9uXCI6IFwiMC44LjZcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGFuIGFjY291bnQgdG8gdXNlIGluIG5ldHdvcmtDbGllbnQgY2FsbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gYWNjb3VudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KCk7XG4gICAgICogbmV0d29ya0NsaWVudC5zZXRBY2NvdW50KGFjY291bnQpO1xuICAgICAqL1xuICAgIHNldEFjY291bnQoYWNjb3VudCkge1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEFsZW8gYWNjb3VudCB1c2VkIGluIHRoZSBuZXR3b3JrQ2xpZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGFjY291bnQgPSBuZXR3b3JrQ2xpZW50LmdldEFjY291bnQoKTtcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgaG9zdCBmb3IgdGhlIG5ldHdvcmtDbGllbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0IFRoZSBhZGRyZXNzIG9mIGEgbm9kZSBob3N0aW5nIHRoZSBBbGVvIEFQSVxuICAgICAqIEBwYXJhbSBob3N0XG4gICAgICovXG4gICAgc2V0SG9zdChob3N0KSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3QgKyBcIi90ZXN0bmV0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgZGF0YSBmcm9tIHRoZSBBbGVvIG5ldHdvcmsgYW5kIHJldHVybnMgaXQgYXMgYSBKU09OIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaERhdGEodXJsID0gXCIvXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUpTT04oYXdhaXQgdGhpcy5mZXRjaFJhdyh1cmwpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgZGF0YTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGRhdGEgZnJvbSB0aGUgQWxlbyBuZXR3b3JrIGFuZCByZXR1cm5zIGl0IGFzIGFuIHVucGFyc2VkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgZGVzaXJlZCB0byByZWNvbnN0aXR1dGUgZGF0YSByZXR1cm5lZFxuICAgICAqIGZyb20gdGhlIG5ldHdvcmsgaW50byBhIFdBU00gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUmF3KHVybCA9IFwiL1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmhvc3QgKyB1cmwsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgZGF0YTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGZpbmQgcmVjb3JkcyBpbiB0aGUgQWxlbyBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SGVpZ2h0IC0gVGhlIGhlaWdodCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIHVuc3BlbnQgcmVjb3Jkc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRIZWlnaHQgLSBUaGUgaGVpZ2h0IGF0IHdoaWNoIHRvIHN0b3Agc2VhcmNoaW5nIGZvciB1bnNwZW50IHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVuc3BlbnQgLSBXaGV0aGVyIHRvIHNlYXJjaCBmb3IgdW5zcGVudCByZWNvcmRzIG9ubHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9ncmFtcyAtIFRoZSBwcm9ncmFtKHMpIHRvIHNlYXJjaCBmb3IgdW5zcGVudCByZWNvcmRzIGluXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYW1vdW50cyAtIFRoZSBhbW91bnRzIChpbiBtaWNyb2NyZWRpdHMpIHRvIHNlYXJjaCBmb3IgKGVnLiBbMTAwLCAyMDAsIDMwMDBdKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhNaWNyb2NyZWRpdHMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWljcm9jcmVkaXRzIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBub25jZXMgLSBUaGUgbm9uY2VzIG9mIGFscmVhZHkgZm91bmQgcmVjb3JkcyB0byBleGNsdWRlIGZyb20gdGhlIHNlYXJjaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUHJpdmF0ZUtleX0gcHJpdmF0ZUtleSAtIEFuIG9wdGlvbmFsIHByaXZhdGUga2V5IHRvIHVzZSB0byBmaW5kIHVuc3BlbnQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRmluZCBzcGVjaWZpYyBhbW91bnRzXG4gICAgICogY29uc3Qgc3RhcnRIZWlnaHQgPSA1MDAwMDA7XG4gICAgICogY29uc3QgYW1vdW50cyA9IFs2MDAwMDAsIDEwMDAwMDBdO1xuICAgICAqIGNvbnN0IHJlY29yZHMgPSBuZXR3b3JrQ2xpZW50LmZpbmRSZWNvcmRzKHN0YXJ0SGVpZ2h0LCB1bmRlZmluZWQsIHRydWUsIFtcImNyZWRpdHMuYWxlb1wiXSBhbW91bnRzKTtcbiAgICAgKlxuICAgICAqIC8vIEZpbmQgc3BlY2lmaWMgYW1vdW50cyB3aXRoIGEgbWF4aW11bSBudW1iZXIgb2YgY3VtdWxhdGl2ZSBtaWNyb2NyZWRpdHNcbiAgICAgKiBjb25zdCBtYXhNaWNyb2NyZWRpdHMgPSAxMDAwMDA7XG4gICAgICogY29uc3QgcmVjb3JkcyA9IG5ldHdvcmtDbGllbnQuZmluZFJlY29yZHMoc3RhcnRIZWlnaHQsIHVuZGVmaW5lZCwgdHJ1ZSwgW1wiY3JlZGl0cy5hbGVvXCJdIHVuZGVmaW5lZCwgbWF4TWljcm9jcmVkaXRzKTtcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kUmVjb3JkcyhzdGFydEhlaWdodCwgZW5kSGVpZ2h0LCB1bnNwZW50ID0gZmFsc2UsIHByb2dyYW1zLCBhbW91bnRzLCBtYXhNaWNyb2NyZWRpdHMsIG5vbmNlcywgcHJpdmF0ZUtleSkge1xuICAgICAgICBub25jZXMgPSBub25jZXMgfHwgW107XG4gICAgICAgIC8vIEVuc3VyZSBzdGFydCBoZWlnaHQgaXMgbm90IG5lZ2F0aXZlXG4gICAgICAgIGlmIChzdGFydEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJ0IGhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgc2VhcmNoIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGxldCByZXNvbHZlZFByaXZhdGVLZXk7XG4gICAgICAgIGxldCBmYWlsdXJlcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbFJlY29yZFZhbHVlID0gQmlnSW50KDApO1xuICAgICAgICBsZXQgbGF0ZXN0SGVpZ2h0O1xuICAgICAgICAvLyBFbnN1cmUgYSBwcml2YXRlIGtleSBpcyBwcmVzZW50IHRvIGZpbmQgb3duZWQgcmVjb3Jkc1xuICAgICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hY2NvdW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgbXVzdCBiZSBzcGVjaWZpZWQgaW4gYW4gYXJndW1lbnQgdG8gZmluZE93bmVkUmVjb3JkcyBvciBzZXQgaW4gdGhlIEFsZW9OZXR3b3JrQ2xpZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcml2YXRlS2V5ID0gdGhpcy5hY2NvdW50Ll9wcml2YXRlS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByaXZhdGVLZXkgPSBwcml2YXRlS2V5IGluc3RhbmNlb2YgUHJpdmF0ZUtleSA/IHByaXZhdGVLZXkgOiBQcml2YXRlS2V5LmZyb21fc3RyaW5nKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcGFyc2luZyBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0tleSA9IHJlc29sdmVkUHJpdmF0ZUtleS50b192aWV3X2tleSgpO1xuICAgICAgICAvLyBHZXQgdGhlIGxhdGVzdCBoZWlnaHQgdG8gZW5zdXJlIHRoZSByYW5nZSBiZWluZyBzZWFyY2hlZCBpcyB2YWxpZFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSBhd2FpdCB0aGlzLmdldExhdGVzdEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9ja0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxhdGVzdEhlaWdodCA9IGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBsYXRlc3QgYmxvY2sgaGVpZ2h0OiBFeHBlY3RlZCB0eXBlICdudW1iZXInIGdvdCAnJHt0eXBlb2YgYmxvY2tIZWlnaHR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBsYXRlc3QgYmxvY2sgaGVpZ2h0OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGVuZCBoZWlnaHQgaXMgc3BlY2lmaWVkIG9yIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGF0ZXN0IGhlaWdodCwgc2V0IHRoZSBlbmQgaGVpZ2h0IHRvIHRoZSBsYXRlc3QgaGVpZ2h0XG4gICAgICAgIGlmICh0eXBlb2YgZW5kSGVpZ2h0ID09PSBcIm51bWJlclwiICYmIGVuZEhlaWdodCA8PSBsYXRlc3RIZWlnaHQpIHtcbiAgICAgICAgICAgIGVuZCA9IGVuZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IGxhdGVzdEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3RhcnRpbmcgaXMgZ3JlYXRlciB0aGFuIHRoZSBlbmRpbmcgaGVpZ2h0LCByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgaWYgKHN0YXJ0SGVpZ2h0ID4gZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFydCBoZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gZW5kIGhlaWdodC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGJsb2NrcyBpbiByZXZlcnNlIG9yZGVyIGluIGNodW5rcyBvZiA1MFxuICAgICAgICB3aGlsZSAoZW5kID4gc3RhcnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gNTA7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBzdGFydEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCA1MCBibG9ja3MgKG9yIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgaWYgbGVzcyB0aGFuIDUwKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tSYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYmxvY2tzIHRvIGZpbmQgdW5zcGVudCByZWNvcmRzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIHRyYW5zYWN0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB1bnNwZW50IHJlY29yZHMgaW4gZXhlY3V0ZSB0cmFuc2FjdGlvbnMgb2YgY3JlZGl0cy5hbGVvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZFRyYW5zYWN0aW9uLnR5cGUgPT0gXCJleGVjdXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb25maXJtZWRUcmFuc2FjdGlvbi50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmV4ZWN1dGlvbiAmJiAhKHR5cGVvZiB0cmFuc2FjdGlvbi5leGVjdXRpb24udHJhbnNpdGlvbnMgPT0gXCJ1bmRlZmluZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdHJhbnNhY3Rpb24uZXhlY3V0aW9uLnRyYW5zaXRpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRyYW5zYWN0aW9uLmV4ZWN1dGlvbi50cmFuc2l0aW9uc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNlYXJjaCBmb3IgdW5zcGVudCByZWNvcmRzIGluIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIHByb2dyYW1zID09PSBcInVuZGVmaW5lZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2dyYW1zLmluY2x1ZGVzKHRyYW5zaXRpb24ucHJvZ3JhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB0cmFuc2l0aW9uLm91dHB1dHMgPT0gXCJ1bmRlZmluZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCB0cmFuc2l0aW9uLm91dHB1dHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRyYW5zaXRpb24ub3V0cHV0c1tsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQudHlwZSA9PT0gXCJyZWNvcmRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdhc20gcmVjb3JkIGNpcGhlcnRleHQgb2JqZWN0IGZyb20gdGhlIGZvdW5kIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBSZWNvcmRDaXBoZXJ0ZXh0LmZyb21TdHJpbmcob3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSByZWNvcmQgaXMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCB2aWV3IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmlzT3duZXIodmlld0tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgdGhlIHJlY29yZCBhbmQgZ2V0IHRoZSBzZXJpYWwgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRQbGFpbnRleHQgPSByZWNvcmQuZGVjcnlwdCh2aWV3S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWNvcmQgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgc2tpcCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSByZWNvcmRQbGFpbnRleHQubm9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25jZXMuaW5jbHVkZXMobm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5zcGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZWNvcmQgdGhlIG5vbmNlIHRoYXQgaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxOdW1iZXIgPSByZWNvcmRQbGFpbnRleHQuc2VyaWFsTnVtYmVyU3RyaW5nKHJlc29sdmVkUHJpdmF0ZUtleSwgXCJjcmVkaXRzLmFsZW9cIiwgXCJjcmVkaXRzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gc2VlIGlmIHRoZSBzZXJpYWwgbnVtYmVyIGlzIHNwZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRUcmFuc2l0aW9uSWQoc2VyaWFsTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIHVuc3BlbnQgcmVjb3JkIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlY29yZCB0byB0aGUgbGlzdCBvZiByZWNvcmRzIGlmIHRoZSB1c2VyIGRpZCBub3Qgc3BlY2lmeSBhbW91bnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbW91bnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZFBsYWludGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgbWF4aW11bSBudW1iZXIgb2YgbWljcm9jcmVkaXRzLCBjaGVjayBpZiB0aGUgc2VhcmNoIGhhcyBmb3VuZCBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1heE1pY3JvY3JlZGl0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlY29yZFZhbHVlICs9IHJlY29yZFBsYWludGV4dC5taWNyb2NyZWRpdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBpZiB0aGUgc2VhcmNoIGhhcyBmb3VuZCB0aGUgYW1vdW50IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxSZWNvcmRWYWx1ZSA+PSBCaWdJbnQobWF4TWljcm9jcmVkaXRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBsaXN0IG9mIGFtb3VudHMsIGNoZWNrIGlmIHRoZSBzZWFyY2ggaGFzIGZvdW5kIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBhbW91bnRzID09PSBcInVuZGVmaW5lZFwiKSAmJiBhbW91bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYW1vdW50c19mb3VuZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZFBsYWludGV4dC5taWNyb2NyZWRpdHMoKSA+IGFtb3VudHNbYW1vdW50c19mb3VuZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50c19mb3VuZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkUGxhaW50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgbWF4aW11bSBudW1iZXIgb2YgbWljcm9jcmVkaXRzLCBjaGVjayBpZiB0aGUgc2VhcmNoIGhhcyBmb3VuZCBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXhNaWNyb2NyZWRpdHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVjb3JkVmFsdWUgKz0gcmVjb3JkUGxhaW50ZXh0Lm1pY3JvY3JlZGl0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBpZiB0aGUgc2VhcmNoIGhhcyBmb3VuZCB0aGUgYW1vdW50IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmVjb3JkVmFsdWUgPj0gQmlnSW50KG1heE1pY3JvY3JlZGl0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPj0gYW1vdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIGZldGNoaW5nIGJsb2NrcywgbG9nIGl0IGFuZCBrZWVwIHNlYXJjaGluZ1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZldGNoaW5nIGJsb2NrcyBpbiByYW5nZTogXCIgKyBzdGFydC50b1N0cmluZygpICsgXCItXCIgKyBlbmQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3I6IFwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgZmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZXMgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCIxMCBmYWlsdXJlcyBmZXRjaGluZyByZWNvcmRzIHJlYWNoZWQuIFJldHVybmluZyByZWNvcmRzIGZldGNoZWQgc28gZmFyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGZpbmQgdW5zcGVudCByZWNvcmRzIGluIHRoZSBBbGVvIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRIZWlnaHQgLSBUaGUgaGVpZ2h0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZyBmb3IgdW5zcGVudCByZWNvcmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEhlaWdodCAtIFRoZSBoZWlnaHQgYXQgd2hpY2ggdG8gc3RvcCBzZWFyY2hpbmcgZm9yIHVuc3BlbnQgcmVjb3Jkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb2dyYW1zIC0gVGhlIHByb2dyYW0ocykgdG8gc2VhcmNoIGZvciB1bnNwZW50IHJlY29yZHMgaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhbW91bnRzIC0gVGhlIGFtb3VudHMgKGluIG1pY3JvY3JlZGl0cykgdG8gc2VhcmNoIGZvciAoZWcuIFsxMDAsIDIwMCwgMzAwMF0pXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heE1pY3JvY3JlZGl0cyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWNyb2NyZWRpdHMgdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG5vbmNlcyAtIFRoZSBub25jZXMgb2YgYWxyZWFkeSBmb3VuZCByZWNvcmRzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgc2VhcmNoXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBQcml2YXRlS2V5fSBwcml2YXRlS2V5IC0gQW4gb3B0aW9uYWwgcHJpdmF0ZSBrZXkgdG8gdXNlIHRvIGZpbmQgdW5zcGVudCByZWNvcmRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBGaW5kIHNwZWNpZmljIGFtb3VudHNcbiAgICAgKiBjb25zdCBzdGFydEhlaWdodCA9IDUwMDAwMDtcbiAgICAgKiBjb25zdCBlbmRIZWlnaHQgPSA1NTAwMDA7XG4gICAgICogY29uc3QgYW1vdW50cyA9IFs2MDAwMDAsIDEwMDAwMDBdO1xuICAgICAqIGNvbnN0IHJlY29yZHMgPSBuZXR3b3JrQ2xpZW50LmZpbmRVbnNwZW50UmVjb3JkcyhzdGFydEhlaWdodCwgZW5kSGVpZ2h0LCBbXCJjcmVkaXRzLmFsZW9cIl0sIGFtb3VudHMpO1xuICAgICAqXG4gICAgICogLy8gRmluZCBzcGVjaWZpYyBhbW91bnRzIHdpdGggYSBtYXhpbXVtIG51bWJlciBvZiBjdW11bGF0aXZlIG1pY3JvY3JlZGl0c1xuICAgICAqIGNvbnN0IG1heE1pY3JvY3JlZGl0cyA9IDEwMDAwMDtcbiAgICAgKiBjb25zdCByZWNvcmRzID0gbmV0d29ya0NsaWVudC5maW5kVW5zcGVudFJlY29yZHMoc3RhcnRIZWlnaHQsIHVuZGVmaW5lZCwgW1wiY3JlZGl0cy5hbGVvXCJdLCB1bmRlZmluZWQsIG1heE1pY3JvY3JlZGl0cyk7XG4gICAgICovXG4gICAgYXN5bmMgZmluZFVuc3BlbnRSZWNvcmRzKHN0YXJ0SGVpZ2h0LCBlbmRIZWlnaHQsIHByb2dyYW1zLCBhbW91bnRzLCBtYXhNaWNyb2NyZWRpdHMsIG5vbmNlcywgcHJpdmF0ZUtleSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kUmVjb3JkcyhzdGFydEhlaWdodCwgZW5kSGVpZ2h0LCB0cnVlLCBwcm9ncmFtcywgYW1vdW50cywgbWF4TWljcm9jcmVkaXRzLCBub25jZXMsIHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgYmxvY2sgYXQgdGhlIHNwZWNpZmllZCBibG9jayBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tIZWlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGJsb2NrID0gbmV0d29ya0NsaWVudC5nZXRCbG9jaygxMjM0KTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jayhibG9ja0hlaWdodCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmZldGNoRGF0YShcIi9ibG9jay9cIiArIGJsb2NrSGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgYmxvY2sgJHtibG9ja0hlaWdodH06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIGJsb2NrIHdpdGggdGhlIHNwZWNpZmllZCBoYXNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrSGFzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgYmxvY2sgPSBuZXR3b3JrQ2xpZW50LmdldEJsb2NrQnlIYXNoKFwiYWIxOWRrbHdsOXZwNjN6dTNod2c1N3d5aHZtcWY5MmZ4NWc4eDB0NmRyNzJweThyODdweHVwcWZuZTV0OVwiKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9ja0J5SGFzaChibG9ja0hhc2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5mZXRjaERhdGEoYC9ibG9jay8ke2Jsb2NrSGFzaH1gKTtcbiAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgYmxvY2sgJHtibG9ja0hhc2h9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5nZSBvZiBibG9ja3MgYmV0d2VlbiB0aGUgc3BlY2lmaWVkIGJsb2NrIGhlaWdodHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBibG9ja1JhbmdlID0gbmV0d29ya0NsaWVudC5nZXRCbG9ja1JhbmdlKDIwNTAsIDIxMDApO1xuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEYXRhKFwiL2Jsb2Nrcz9zdGFydD1cIiArIHN0YXJ0ICsgXCImZW5kPVwiICsgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgYmxvY2tzIGJldHdlZW4gJHtzdGFydH0gYW5kICR7ZW5kfTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb2dyYW0gfCBzdHJpbmd9IHByb2dyYW1cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25KU09OfVxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveW1lbnRUcmFuc2FjdGlvbklERm9yUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIGlmIChwcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW0uaWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLmZldGNoRGF0YShcIi9maW5kL3RyYW5zYWN0aW9uSUQvZGVwbG95bWVudC9cIiArIHByb2dyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIGlkLnJlcGxhY2UoXCJcXFwiXCIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIGZvciBwcm9ncmFtICR7cHJvZ3JhbX06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpZWQgcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvZ3JhbSB8IHN0cmluZ30gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkpTT059XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95bWVudFRyYW5zYWN0aW9uRm9yUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIGlmIChwcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW0uaWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25faWQgPSBhd2FpdCB0aGlzLmdldERlcGxveW1lbnRUcmFuc2FjdGlvbklERm9yUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgZGVwbG95bWVudCB0cmFuc2FjdGlvbiBmb3IgcHJvZ3JhbSAke3Byb2dyYW19OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIGEgc3BlY2lmaWVkIHByb2dyYW0gYXMgYSB3YXNtIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvZ3JhbSB8IHN0cmluZ30gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkpTT059XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95bWVudFRyYW5zYWN0aW9uT2JqZWN0Rm9yUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbl9pZCA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95bWVudFRyYW5zYWN0aW9uSURGb3JQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25PYmplY3QodHJhbnNhY3Rpb25faWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIGZvciBwcm9ncmFtICR7cHJvZ3JhbX06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIGxhdGVzdCBibG9jay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbGF0ZXN0SGVpZ2h0ID0gbmV0d29ya0NsaWVudC5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAqL1xuICAgIGFzeW5jIGdldExhdGVzdEJsb2NrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEYXRhKFwiL2Jsb2NrL2xhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGF0ZXN0IGJsb2NrOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBjb21taXR0ZWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBjb21taXR0ZWVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYXRlc3RDb21taXR0ZWUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERhdGEoXCIvY29tbWl0dGVlL2xhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGF0ZXN0IGNvbW1pdHRlZTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21taXR0ZSBhdCB0aGUgc3BlY2lmaWVkIGJsb2NrIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja0hlaWdodFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIHRoZSBjb21taXR0ZWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgY29tbWl0dGVlID0gYXdhaXQgbmV0d29ya0NsaWVudC5nZXRDb21taXR0ZUJ5QmxvY2tIZWlnaHQoMTIzNCk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29tbWl0dGVlQnlCbG9ja0hlaWdodChibG9ja0hlaWdodCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEYXRhKGAvY29tbWl0dGVlLyR7YmxvY2tIZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIGNvbW1pdHRlZSBhdCBoZWlnaHQgJHtibG9ja0hlaWdodH06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IGJsb2NrIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbGF0ZXN0SGVpZ2h0ID0gbmV0d29ya0NsaWVudC5nZXRMYXRlc3RIZWlnaHQoKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYXRlc3RIZWlnaHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGF3YWl0IHRoaXMuZmV0Y2hEYXRhKFwiL2Jsb2NrL2hlaWdodC9sYXRlc3RcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyBsYXRlc3QgaGVpZ2h0OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBsYXRlc3RIYXNoIC0gbmV3dHdvcmtDbGllbnQuZ2V0TGF0ZXN0QmxvY2tIYXNoKCk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2tIYXNoKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhhd2FpdCB0aGlzLmZldGNoRGF0YShcIi9ibG9jay9oYXNoL2xhdGVzdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIGxhdGVzdCBoYXNoOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNvdXJjZSBjb2RlIG9mIGEgcHJvZ3JhbSBnaXZlbiBhIHByb2dyYW0gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbUlkIFRoZSBwcm9ncmFtIElEIG9mIGEgcHJvZ3JhbSBkZXBsb3llZCB0byB0aGUgQWxlbyBOZXR3b3JrXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fSBTb3VyY2UgY29kZSBvZiB0aGUgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm9ncmFtID0gbmV0d29ya0NsaWVudC5nZXRQcm9ncmFtKFwiaGVsbG9faGVsbG8uYWxlb1wiKTtcbiAgICAgKiBjb25zdCBleHBlY3RlZFNvdXJjZSA9IFwicHJvZ3JhbSBoZWxsb19oZWxsby5hbGVvO1xcblxcbmZ1bmN0aW9uIGhlbGxvOlxcbiAgICBpbnB1dCByMCBhcyB1MzIucHVibGljO1xcbiAgICBpbnB1dCByMSBhcyB1MzIucHJpdmF0ZTtcXG4gICAgYWRkIHIwIHIxIGludG8gcjI7XFxuICAgIG91dHB1dCByMiBhcyB1MzIucHJpdmF0ZTtcXG5cIlxuICAgICAqIGFzc2VydC5lcXVhbChwcm9ncmFtLCBleHBlY3RlZFNvdXJjZSk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvZ3JhbShwcm9ncmFtSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoRGF0YShcIi9wcm9ncmFtL1wiICsgcHJvZ3JhbUlkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgcHJvZ3JhbSAke3Byb2dyYW1JZH06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb2dyYW0gb2JqZWN0IGZyb20gYSBwcm9ncmFtIElEIG9yIHByb2dyYW0gc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRQcm9ncmFtIFRoZSBwcm9ncmFtIElEIG9yIHByb2dyYW0gc291cmNlIGNvZGUgb2YgYSBwcm9ncmFtIGRlcGxveWVkIHRvIHRoZSBBbGVvIE5ldHdvcmtcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFByb2dyYW0+fSBTb3VyY2UgY29kZSBvZiB0aGUgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwcm9ncmFtSUQgPSBcImhlbGxvX2hlbGxvLmFsZW9cIjtcbiAgICAgKiBjb25zdCBwcm9ncmFtU291cmNlID0gXCJwcm9ncmFtIGhlbGxvX2hlbGxvLmFsZW87XFxuXFxuZnVuY3Rpb24gaGVsbG86XFxuICAgIGlucHV0IHIwIGFzIHUzMi5wdWJsaWM7XFxuICAgIGlucHV0IHIxIGFzIHUzMi5wcml2YXRlO1xcbiAgICBhZGQgcjAgcjEgaW50byByMjtcXG4gICAgb3V0cHV0IHIyIGFzIHUzMi5wcml2YXRlO1xcblwiXG4gICAgICpcbiAgICAgKiAvLyBHZXQgcHJvZ3JhbSBvYmplY3QgZnJvbSBwcm9ncmFtIElEIG9yIHByb2dyYW0gc291cmNlIGNvZGVcbiAgICAgKiBjb25zdCBwcm9ncmFtT2JqZWN0RnJvbUlEID0gYXdhaXQgbmV0d29ya0NsaWVudC5nZXRQcm9ncmFtT2JqZWN0KHByb2dyYW1JRCk7XG4gICAgICogY29uc3QgcHJvZ3JhbU9iamVjdEZyb21Tb3VyY2UgPSBhd2FpdCBuZXR3b3JrQ2xpZW50LmdldFByb2dyYW1PYmplY3QocHJvZ3JhbVNvdXJjZSk7XG4gICAgICpcbiAgICAgKiAvLyBCb3RoIHByb2dyYW0gb2JqZWN0cyBzaG91bGQgYmUgZXF1YWxcbiAgICAgKiBhc3NlcnQuZXF1YWwocHJvZ3JhbU9iamVjdEZyb21JRC50b19zdHJpbmcoKSwgcHJvZ3JhbU9iamVjdEZyb21Tb3VyY2UudG9fc3RyaW5nKCkpO1xuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2dyYW1PYmplY3QoaW5wdXRQcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvZ3JhbS5mcm9tU3RyaW5nKGlucHV0UHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9ncmFtLmZyb21TdHJpbmcoKGF3YWl0IHRoaXMuZ2V0UHJvZ3JhbShpbnB1dFByb2dyYW0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aW5wdXRQcm9ncmFtfSBpcyBuZWl0aGVyIGEgcHJvZ3JhbSBuYW1lIG9yIGEgdmFsaWQgcHJvZ3JhbTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc291cmNlIGNvZGUgb2YgYSBwcm9ncmFtIGFuZCB0aGUgc291cmNlIGNvZGUgb2YgYWxsIHByb2dyYW1zIGl0IGltcG9ydHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvZ3JhbSB8IHN0cmluZ30gaW5wdXRQcm9ncmFtIFRoZSBwcm9ncmFtIElEIG9yIHByb2dyYW0gc291cmNlIGNvZGUgb2YgYSBwcm9ncmFtIGRlcGxveWVkIHRvIHRoZSBBbGVvIE5ldHdvcmtcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9ncmFtSW1wb3J0cz59IE9iamVjdCBvZiB0aGUgZm9ybSB7IFwicHJvZ3JhbV9pZFwiOiBcInByb2dyYW1fc291cmNlXCIsIC4uIH0gY29udGFpbmluZyBwcm9ncmFtIGlkICYgc291cmNlIGNvZGUgZm9yIGFsbCBwcm9ncmFtIGltcG9ydHNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZG91YmxlX3Rlc3Rfc291cmNlID0gXCJpbXBvcnQgbXVsdGlwbHlfdGVzdC5hbGVvO1xcblxcbnByb2dyYW0gZG91YmxlX3Rlc3QuYWxlbztcXG5cXG5mdW5jdGlvbiBkb3VibGVfaXQ6XFxuICAgIGlucHV0IHIwIGFzIHUzMi5wcml2YXRlO1xcbiAgICBjYWxsIG11bHRpcGx5X3Rlc3QuYWxlby9tdWx0aXBseSAydTMyIHIwIGludG8gcjE7XFxuICAgIG91dHB1dCByMSBhcyB1MzIucHJpdmF0ZTtcXG5cIlxuICAgICAqIGNvbnN0IGRvdWJsZV90ZXN0ID0gUHJvZ3JhbS5mcm9tU3RyaW5nKGRvdWJsZV90ZXN0X3NvdXJjZSk7XG4gICAgICogY29uc3QgZXhwZWN0ZWRJbXBvcnRzID0ge1xuICAgICAqICAgICBcIm11bHRpcGx5X3Rlc3QuYWxlb1wiOiBcInByb2dyYW0gbXVsdGlwbHlfdGVzdC5hbGVvO1xcblxcbmZ1bmN0aW9uIG11bHRpcGx5OlxcbiAgICBpbnB1dCByMCBhcyB1MzIucHVibGljO1xcbiAgICBpbnB1dCByMSBhcyB1MzIucHJpdmF0ZTtcXG4gICAgbXVsIHIwIHIxIGludG8gcjI7XFxuICAgIG91dHB1dCByMiBhcyB1MzIucHJpdmF0ZTtcXG5cIlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIEltcG9ydHMgY2FuIGJlIGZldGNoZWQgdXNpbmcgdGhlIHByb2dyYW0gSUQsIHNvdXJjZSBjb2RlLCBvciBwcm9ncmFtIG9iamVjdFxuICAgICAqIGxldCBwcm9ncmFtSW1wb3J0cyA9IGF3YWl0IG5ldHdvcmtDbGllbnQuZ2V0UHJvZ3JhbUltcG9ydHMoXCJkb3VibGVfdGVzdC5hbGVvXCIpO1xuICAgICAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocHJvZ3JhbUltcG9ydHMsIGV4cGVjdGVkSW1wb3J0cyk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyB0aGUgcHJvZ3JhbSBzb3VyY2UgY29kZVxuICAgICAqIHByb2dyYW1JbXBvcnRzID0gYXdhaXQgbmV0d29ya0NsaWVudC5nZXRQcm9ncmFtSW1wb3J0cyhkb3VibGVfdGVzdF9zb3VyY2UpO1xuICAgICAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocHJvZ3JhbUltcG9ydHMsIGV4cGVjdGVkSW1wb3J0cyk7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyB0aGUgcHJvZ3JhbSBvYmplY3RcbiAgICAgKiBwcm9ncmFtSW1wb3J0cyA9IGF3YWl0IG5ldHdvcmtDbGllbnQuZ2V0UHJvZ3JhbUltcG9ydHMoZG91YmxlX3Rlc3QpO1xuICAgICAqIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwocHJvZ3JhbUltcG9ydHMsIGV4cGVjdGVkSW1wb3J0cyk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvZ3JhbUltcG9ydHMoaW5wdXRQcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHByb2dyYW0gb2JqZWN0IG9yIGZhaWwgaWYgdGhlIHByb2dyYW0gaXMgbm90IHZhbGlkIG9yIGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICBjb25zdCBwcm9ncmFtID0gaW5wdXRQcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSA/IGlucHV0UHJvZ3JhbSA6IChhd2FpdCB0aGlzLmdldFByb2dyYW1PYmplY3QoaW5wdXRQcm9ncmFtKSk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgcHJvZ3JhbXMgdGhhdCB0aGUgcHJvZ3JhbSBpbXBvcnRzXG4gICAgICAgICAgICBjb25zdCBpbXBvcnRMaXN0ID0gcHJvZ3JhbS5nZXRJbXBvcnRzKCk7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBnZXQgYW55IGltcG9ydHMgdGhhdCB0aGUgaW1wb3J0ZWQgcHJvZ3JhbXMgaGF2ZSBpbiBhIGRlcHRoIGZpcnN0IHNlYXJjaCBvcmRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbXBvcnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1wb3J0X2lkID0gaW1wb3J0TGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydHMuaGFzT3duUHJvcGVydHkoaW1wb3J0X2lkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmFtU291cmNlID0gYXdhaXQgdGhpcy5nZXRQcm9ncmFtKGltcG9ydF9pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZEltcG9ydHMgPSBhd2FpdCB0aGlzLmdldFByb2dyYW1JbXBvcnRzKGltcG9ydF9pZCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5lc3RlZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0c1trZXldID0gbmVzdGVkSW1wb3J0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHNbaW1wb3J0X2lkXSA9IHByb2dyYW1Tb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhcIkVycm9yIGZldGNoaW5nIHByb2dyYW0gaW1wb3J0czogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHRoZSBwcm9ncmFtIG5hbWVzIHRoYXQgYSBwcm9ncmFtIGltcG9ydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb2dyYW0gfCBzdHJpbmd9IGlucHV0UHJvZ3JhbSAtIFRoZSBwcm9ncmFtIGlkIG9yIHByb2dyYW0gc291cmNlIGNvZGUgdG8gZ2V0IHRoZSBpbXBvcnRzIG9mXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSAtIFRoZSBsaXN0IG9mIHByb2dyYW0gbmFtZXMgdGhhdCB0aGUgcHJvZ3JhbSBpbXBvcnRzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb2dyYW1JbXBvcnRzTmFtZXMgPSBuZXR3b3JrQ2xpZW50LmdldFByb2dyYW1JbXBvcnRzKFwiZG91YmxlX3Rlc3QuYWxlb1wiKTtcbiAgICAgKiBjb25zdCBleHBlY3RlZEltcG9ydHNOYW1lcyA9IFtcIm11bHRpcGx5X3Rlc3QuYWxlb1wiXTtcbiAgICAgKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHByb2dyYW1JbXBvcnRzTmFtZXMsIGV4cGVjdGVkSW1wb3J0c05hbWVzKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9ncmFtSW1wb3J0TmFtZXMoaW5wdXRQcm9ncmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmFtID0gaW5wdXRQcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSA/IGlucHV0UHJvZ3JhbSA6IChhd2FpdCB0aGlzLmdldFByb2dyYW1PYmplY3QoaW5wdXRQcm9ncmFtKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5nZXRJbXBvcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIGltcG9ydHMgZm9yIHByb2dyYW0gJHtpbnB1dFByb2dyYW0gaW5zdGFuY2VvZiBQcm9ncmFtID8gaW5wdXRQcm9ncmFtLmlkKCkgOiBpbnB1dFByb2dyYW19OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIG1hcHBpbmdzIG9mIGEgcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtSWQgLSBUaGUgcHJvZ3JhbSBJRCB0byBnZXQgdGhlIG1hcHBpbmdzIG9mIChlLmcuIFwiY3JlZGl0cy5hbGVvXCIpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBtYXBwaW5ncyA9IG5ldHdvcmtDbGllbnQuZ2V0UHJvZ3JhbU1hcHBpbmdOYW1lcyhcImNyZWRpdHMuYWxlb1wiKTtcbiAgICAgKiBjb25zdCBleHBlY3RlZE1hcHBpbmdzID0gW1xuICAgICAqICAgXCJjb21taXR0ZWVcIixcbiAgICAgKiAgIFwiZGVsZWdhdGVkXCIsXG4gICAgICogICBcIm1ldGFkYXRhXCIsXG4gICAgICogICBcImJvbmRlZFwiLFxuICAgICAqICAgXCJ1bmJvbmRpbmdcIixcbiAgICAgKiAgIFwiYWNjb3VudFwiLFxuICAgICAqICAgXCJ3aXRoZHJhd1wiXG4gICAgICogXTtcbiAgICAgKiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKG1hcHBpbmdzLCBleHBlY3RlZE1hcHBpbmdzKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9ncmFtTWFwcGluZ05hbWVzKHByb2dyYW1JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEYXRhKGAvcHJvZ3JhbS8ke3Byb2dyYW1JZH0vbWFwcGluZ3NgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWFwcGluZ3MgZm9yIHByb2dyYW0gJHtwcm9ncmFtSWR9IC0gZW5zdXJlIHRoZSBwcm9ncmFtIGV4aXN0cyBvbiBjaGFpbiBiZWZvcmUgdHJ5aW5nIGFnYWluYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBwcm9ncmFtJ3MgbWFwcGluZyBmb3IgYSBzcGVjaWZpYyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbUlkIC0gVGhlIHByb2dyYW0gSUQgdG8gZ2V0IHRoZSBtYXBwaW5nIHZhbHVlIG9mIChlLmcuIFwiY3JlZGl0cy5hbGVvXCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcHBpbmdOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1hcHBpbmcgdG8gZ2V0IHRoZSB2YWx1ZSBvZiAoZS5nLiBcImFjY291bnRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFBsYWludGV4dH0ga2V5IC0gVGhlIGtleSBvZiB0aGUgbWFwcGluZyB0byBnZXQgdGhlIHZhbHVlIG9mIChlLmcuIFwiYWxlbzFyaGdkdTc3aGd5cWQzeGpqOHVjdTNqajlyMmtyd3o2bW56eWQ4MGduY3I1Znhjd2xoNXJzdnpwOXB4XCIpXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlIG9mIHRoZSBtYXBwaW5nXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdldCBwdWJsaWMgYmFsYW5jZSBvZiBhbiBhY2NvdW50XG4gICAgICogY29uc3QgbWFwcGluZ1ZhbHVlID0gbmV0d29ya0NsaWVudC5nZXRNYXBwaW5nVmFsdWUoXCJjcmVkaXRzLmFsZW9cIiwgXCJhY2NvdW50XCIsIFwiYWxlbzFyaGdkdTc3aGd5cWQzeGpqOHVjdTNqajlyMmtyd3o2bW56eWQ4MGduY3I1Znhjd2xoNXJzdnpwOXB4XCIpO1xuICAgICAqIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBcIjB1NjRcIjtcbiAgICAgKiBhc3NlcnQuZXF1YWwobWFwcGluZ1ZhbHVlLCBleHBlY3RlZFZhbHVlKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9ncmFtTWFwcGluZ1ZhbHVlKHByb2dyYW1JZCwgbWFwcGluZ05hbWUsIGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qga2V5U3RyaW5nID0ga2V5IGluc3RhbmNlb2YgUGxhaW50ZXh0ID8ga2V5LnRvU3RyaW5nKCkgOiBrZXk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERhdGEoYC9wcm9ncmFtLyR7cHJvZ3JhbUlkfS9tYXBwaW5nLyR7bWFwcGluZ05hbWV9LyR7a2V5U3RyaW5nfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB2YWx1ZSBmb3Iga2V5ICcke2tleX0nIGluIG1hcHBpbmcgJyR7bWFwcGluZ05hbWV9JyBpbiBwcm9ncmFtICcke3Byb2dyYW1JZH0nIC0gZW5zdXJlIHRoZSBtYXBwaW5nIGV4aXN0cyBhbmQgdGhlIGtleSBpcyBjb3JyZWN0YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBtYXBwaW5nIGFzIGEgd2FzbSBQbGFpbnRleHQgb2JqZWN0LiBSZXR1cm5pbmcgYW5cbiAgICAgKiBvYmplY3QgaW4gdGhpcyBmb3JtYXQgYWxsb3dzIGl0IHRvIGJlIGNvbnZlcnRlZCB0byBhIEpzIHR5cGUgYW5kIGZvciBpdHNcbiAgICAgKiBpbnRlcm5hbCBtZW1iZXJzIHRvIGJlIGluc3BlY3RlZCBpZiBpdCdzIGEgc3RydWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXQgdGhlIGJvbmQgc3RhdGUgYXMgYW4gYWNjb3VudC5cbiAgICAgKiBjb25zdCB1bmJvbmRlZFN0YXRlID0gbmV0d29ya0NsaWVudC5nZXRNYXBwaW5nUGxhaW50ZXh0KFwiY3JlZGl0cy5hbGVvXCIsIFwiYm9uZGVkXCIsIFwiYWxlbzFyaGdkdTc3aGd5cWQzeGpqOHVjdTNqajlyMmtyd3o2bW56eWQ4MGduY3I1Znhjd2xoNXJzdnpwOXB4XCIpO1xuICAgICAqXG4gICAgICogLy8gR2V0IHRoZSB0d28gbWVtYmVycyBvZiB0aGUgb2JqZWN0IGluZGl2aWR1YWxseS5cbiAgICAgKiBjb25zdCB2YWxpZGF0b3IgPSB1bmJvbmRlZFN0YXRlLmdldE1lbWJlcihcInZhbGlkYXRvclwiKTtcbiAgICAgKiBjb25zdCBtaWNyb2NyZWRpdHMgPSB1bmJvbmRlZFN0YXRlLmdldE1lbWJlcihcIm1pY3JvY3JlZGl0c1wiKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSB0aGUgZXhwZWN0ZWQgdmFsdWVzIGFyZSBjb3JyZWN0LlxuICAgICAqIGFzc2VydC5lcXVhbCh2YWxpZGF0b3IsIFwiYWxlbzF1Njk0MHY1bTBmenVkODU5eHgyYzl0ajJnamc2bTVxcmQyOG42MzZlNmZkZDJha3ZmY2dxczM0bWZkXCIpO1xuICAgICAqIGFzc2VydC5lcXVhbChtaWNyb2NyZWRpdHMsIEJpZ0ludChcIjkwMDcxOTkyNTQ3NDA5OTFcIikpO1xuICAgICAqXG4gICAgICogLy8gR2V0IGEgSlMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bmJvbmRlZCBzdGF0ZS5cbiAgICAgKiBjb25zdCB1bmJvbmRlZFN0YXRlT2JqZWN0ID0gdW5ib25kZWRTdGF0ZS50b09iamVjdCgpO1xuICAgICAqXG4gICAgICogY29uc3QgZXhwZWN0ZWRTdGF0ZSA9IHtcbiAgICAgKiAgICAgdmFsaWRhdG9yOiBcImFsZW8xdTY5NDB2NW0wZnp1ZDg1OXh4MmM5dGoyZ2pnNm01cXJkMjhuNjM2ZTZmZGQyYWt2ZmNncXMzNG1mZFwiLFxuICAgICAqICAgICBtaWNyb2NyZWRpdHM6IEJpZ0ludChcIjkwMDcxOTkyNTQ3NDA5OTFcIilcbiAgICAgKiB9O1xuICAgICAqIGFzc2VydC5lcXVhbCh1bmJvbmRlZFN0YXRlLCBleHBlY3RlZFN0YXRlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtSWQgLSBUaGUgcHJvZ3JhbSBJRCB0byBnZXQgdGhlIG1hcHBpbmcgdmFsdWUgb2YgKGUuZy4gXCJjcmVkaXRzLmFsZW9cIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwcGluZ05hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWFwcGluZyB0byBnZXQgdGhlIHZhbHVlIG9mIChlLmcuIFwiYWNjb3VudFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgUGxhaW50ZXh0fSBrZXkgLSBUaGUga2V5IG9mIHRoZSBtYXBwaW5nIHRvIGdldCB0aGUgdmFsdWUgb2YgKGUuZy4gXCJhbGVvMXJoZ2R1NzdoZ3lxZDN4amo4dWN1M2pqOXIya3J3ejZtbnp5ZDgwZ25jcjVmeGN3bGg1cnN2enA5cHhcIilcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBvZiB0aGUgbWFwcGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2dyYW1NYXBwaW5nUGxhaW50ZXh0KHByb2dyYW1JZCwgbWFwcGluZ05hbWUsIGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qga2V5U3RyaW5nID0ga2V5IGluc3RhbmNlb2YgUGxhaW50ZXh0ID8ga2V5LnRvU3RyaW5nKCkgOiBrZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuZmV0Y2hSYXcoYC9wcm9ncmFtLyR7cHJvZ3JhbUlkfS9tYXBwaW5nLyR7bWFwcGluZ05hbWV9LyR7a2V5U3RyaW5nfWApO1xuICAgICAgICAgICAgcmV0dXJuIFBsYWludGV4dC5mcm9tU3RyaW5nKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYXBwaW5nIHZhbHVlLlwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHB1YmxpYyBiYWxhbmNlIG9mIGFuIGFkZHJlc3MgZnJvbSB0aGUgYWNjb3VudCBtYXBwaW5nIGluIGNyZWRpdHMuYWxlb1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KCk7XG4gICAgICogY29uc3QgcHVibGljQmFsYW5jZSA9IG5ldHdvcmtDbGllbnQuZ2V0UHVibGljQmFsYW5jZShhY2NvdW50LmFkZHJlc3MoKSk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHVibGljQmFsYW5jZShhZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlU3RyID0gYXdhaXQgdGhpcy5nZXRQcm9ncmFtTWFwcGluZ1ZhbHVlKCdjcmVkaXRzLmFsZW8nLCAnYWNjb3VudCcsIGFkZHJlc3MudG9fc3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2VTdHIgPyBwYXJzZUludChiYWxhbmNlU3RyKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIHB1YmxpYyBiYWxhbmNlIGZvciAke2FkZHJlc3N9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBzdGF0ZS9tZXJrbGUgcm9vdCBvZiB0aGUgQWxlbyBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzdGF0ZVJvb3QgPSBuZXR3b3JrQ2xpZW50LmdldFN0YXRlUm9vdCgpO1xuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlUm9vdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoRGF0YSgnL3N0YXRlUm9vdC9sYXRlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGF0ZXN0IHN0YXRlIHJvb3Q6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zYWN0aW9uIGJ5IGl0cyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvbklkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldHdvcmtDbGllbnQuZ2V0VHJhbnNhY3Rpb24oXCJhdDFoYW5kejl4anJxZXluanJyMHhheTRwY3NndG5jemRrc3ozZTU4NHZmc2dhejBkaDBseXhxNDNhNHdqXCIpO1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoRGF0YShcIi90cmFuc2FjdGlvbi9cIiArIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB0cmFuc2FjdGlvbiAke3RyYW5zYWN0aW9uSWR9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25maXJtZWQgdHJhbnNhY3Rpb24gYnkgaXRzIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV0d29ya0NsaWVudC5nZXRDb25maXJtZWRUcmFuc2FjdGlvbihcImF0MWhhbmR6OXhqcnFleW5qcnIweGF5NHBjc2d0bmN6ZGtzejNlNTg0dmZzZ2F6MGRoMGx5eHE0M2E0d2pcIik7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hEYXRhKGAvdHJhbnNhY3Rpb24vY29uZmlybWVkLyR7dHJhbnNhY3Rpb25JZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgY29uZmlybWVkIHRyYW5zYWN0aW9uICR7dHJhbnNhY3Rpb25JZH06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zYWN0aW9uIGFzIGEgd2FzbSBvYmplY3QuIEdldHRpbmcgYSB0cmFuc2FjdGlvbiBvZiB0aGlzIHR5cGUgd2lsbCBhbGxvdyB0aGUgYWJpbGl0eSBmb3IgdGhlIGlucHV0cyxcbiAgICAgKiBvdXRwdXRzLCBhbmQgcmVjb3JkcyB0byBiZSBzZWFyY2hlZCBmb3IgYW5kIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdHJhbnNhY3Rpb25PYmplY3QgPSBuZXR3b3JrQ2xpZW50LmdldFRyYW5zYWN0aW9uKFwiYXQxaGFuZHo5eGpycWV5bmpycjB4YXk0cGNzZ3RuY3pka3N6M2U1ODR2ZnNnYXowZGgwbHl4cTQzYTR3alwiKTtcbiAgICAgKiAvLyBHZXQgdGhlIHRyYW5zYWN0aW9uIGlucHV0cyBhcyBhIEpTIGFycmF5LlxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uT3V0cHV0cyA9IHRyYW5zYWN0aW9uT2JqZWN0LmlucHV0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIEdldCB0aGUgdHJhbnNhY3Rpb24gb3V0cHV0cyBhcyBhIEpTIG9iamVjdC5cbiAgICAgKiBjb25zdCB0cmFuc2FjdGlvbklucHV0cyA9IHRyYW5zYWN0aW9uT2JqZWN0Lm91dHB1dHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBHZXQgYW55IHJlY29yZHMgZ2VuZXJhdGVkIGluIHRyYW5zaXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBhcyBhIEpTIG9iamVjdC5cbiAgICAgKiBjb25zdCByZWNvcmRzID0gdHJhbnNhY3Rpb25PYmplY3QucmVjb3JkcygpO1xuICAgICAqXG4gICAgICogLy8gR2V0IHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uVHlwZSA9IHRyYW5zYWN0aW9uT2JqZWN0LnRyYW5zYWN0aW9uVHlwZSgpO1xuICAgICAqIGFzc2VydC5lcXVhbCh0cmFuc2FjdGlvblR5cGUsIFwiRXhlY3V0ZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIEdldCBhIEpTIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBpbnB1dHMsIG91dHB1dHMsIGFuZCB0cmFuc2FjdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBjb25zdCB0cmFuc2FjdGlvblN1bW1hcnkgPSB0cmFuc2FjdGlvbk9iamVjdC5zdW1tYXJ5KCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNhY3Rpb25JZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdHJhbnNhY3Rpb24gPSBuZXR3b3JrQ2xpZW50LmdldFRyYW5zYWN0aW9uT2JqZWN0KFwiYXQxaGFuZHo5eGpycWV5bmpycjB4YXk0cGNzZ3RuY3pka3N6M2U1ODR2ZnNnYXowZGgwbHl4cTQzYTR3alwiKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbk9iamVjdCh0cmFuc2FjdGlvbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hSYXcoXCIvdHJhbnNhY3Rpb24vXCIgKyB0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tU3RyaW5nKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgdHJhbnNhY3Rpb24gb2JqZWN0ICR7dHJhbnNhY3Rpb25JZH06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb25zIHByZXNlbnQgYXQgdGhlIHNwZWNpZmllZCBibG9jayBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tIZWlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9ucyA9IG5ldHdvcmtDbGllbnQuZ2V0VHJhbnNhY3Rpb25zKDY1NCk7XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKGJsb2NrSGVpZ2h0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERhdGEoXCIvYmxvY2svXCIgKyBibG9ja0hlaWdodC50b1N0cmluZygpICsgXCIvdHJhbnNhY3Rpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB0cmFuc2FjdGlvbnM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlybWVkIHRyYW5zYWN0aW9ucyBwcmVzZW50IGluIHRoZSBibG9jayB3aXRoIHRoZSBzcGVjaWZpZWQgYmxvY2sgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja0hhc2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9ucyA9IG5ldHdvcmtDbGllbnQuZ2V0VHJhbnNhY3Rpb25zQnlIYXNoKFwiYWIxOWRrbHdsOXZwNjN6dTNod2c1N3d5aHZtcWY5MmZ4NWc4eDB0NmRyNzJweThyODdweHVwcWZuZTV0OVwiKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbnNCeUJsb2NrSGFzaChibG9ja0hhc2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5mZXRjaERhdGEoYC9ibG9jay8ke2Jsb2NrSGFzaH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJsb2NrLmhlYWRlci5tZXRhZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbnMoTnVtYmVyKGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB0cmFuc2FjdGlvbnMgZm9yIGJsb2NrICR7YmxvY2tIYXNofTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbnMgaW4gdGhlIG1lbW9yeSBwb29sLiBUaGlzIG1ldGhvZCByZXF1aXJlcyBhY2Nlc3MgdG8gYSB2YWxpZGF0b3IncyBSRVNUIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdHJhbnNhY3Rpb25zID0gbmV0d29ya0NsaWVudC5nZXRUcmFuc2FjdGlvbnNJbk1lbXBvb2woKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbnNJbk1lbXBvb2woKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERhdGEoXCIvbWVtb3J5UG9vbC90cmFuc2FjdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIHRyYW5zYWN0aW9ucyBmcm9tIG1lbXBvb2w6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNpdGlvbiBJRCBvZiB0aGUgdHJhbnNpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBJRCBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dE9yT3V0cHV0SUQgLSBJRCBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCB0cmFuc2l0aW9uSWQgPSBuZXR3b3JrQ2xpZW50LmdldFRyYW5zaXRpb25JZChcIjI0MjkyMzI4NTUyMzY4MzA5MjYxNDQzNTYzNzc4Njg0NDk4OTA4MzA3MDQzMzY2NjQ1NTAyMDMxNzY5MTg3ODI1NTQyMTk5NTIzMjNmaWVsZFwiKTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2l0aW9uSWQoaW5wdXRPck91dHB1dElEKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERhdGEoXCIvZmluZC90cmFuc2l0aW9uSUQvXCIgKyBpbnB1dE9yT3V0cHV0SUQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmZXRjaGluZyB0cmFuc2l0aW9uIElEIGZvciBpbnB1dC9vdXRwdXQgJHtpbnB1dE9yT3V0cHV0SUR9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBhbiBleGVjdXRlIG9yIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gdG8gdGhlIEFsZW8gbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb24gfCBzdHJpbmd9IHRyYW5zYWN0aW9uICAtIFRoZSB0cmFuc2FjdGlvbiB0byBzdWJtaXQgdG8gdGhlIG5ldHdvcmtcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB0cmFuc2FjdGlvbiBpZCBvZiB0aGUgc3VibWl0dGVkIHRyYW5zYWN0aW9uIG9yIHRoZSByZXN1bHRpbmcgZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbl9zdHJpbmcgPSB0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24udG9TdHJpbmcoKSA6IHRyYW5zYWN0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuaG9zdCArIFwiL3RyYW5zYWN0aW9uL2Jyb2FkY2FzdFwiLCB7XG4gICAgICAgICAgICAgICAgYm9keTogdHJhbnNhY3Rpb25fc3RyaW5nLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUpTT04odGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHBvc3RpbmcgdHJhbnNhY3Rpb24uIEFsZW8gbmV0d29yayByZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwb3N0aW5nIHRyYW5zYWN0aW9uOiBObyByZXNwb25zZSByZWNlaXZlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBhIHNvbHV0aW9uIHRvIHRoZSBBbGVvIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc29sdXRpb24gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc29sdXRpb24gZGVzaXJlZCB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0U29sdXRpb24oc29sdXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdCh0aGlzLmhvc3QgKyBcIi9zb2x1dGlvbi9icm9hZGNhc3RcIiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUpTT04odGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHBvc3RpbmcgdHJhbnNhY3Rpb24uIEFsZW8gbmV0d29yayByZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwb3N0aW5nIHRyYW5zYWN0aW9uOiBObyByZXNwb25zZSByZWNlaXZlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF3YWl0IGEgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkIG9uIHRoZSBBbGVvIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc29sdXRpb24gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc29sdXRpb24gZGVzaXJlZCB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uQ29uZmlybWF0aW9uKHRyYW5zYWN0aW9uSWQsIGNoZWNrSW50ZXJ2YWwgPSAyMDAwLCAvLyBQb2xsIGV2ZXJ5IDIgc2Vjb25kc1xuICAgIHRpbWVvdXQgPSA0NTAwMCAvLyBUaW1lb3V0IGFmdGVyIDQ1IHNlY29uZHNcbiAgICApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugd2l0aCBhY3R1YWwgQWxlbyB0cmFuc2FjdGlvbiBsb29rdXAgQVBJXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbk9iamVjdCh0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyB0cmFuc2FjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IEtFWV9TVE9SRSA9IE1ldGFkYXRhLmJhc2VVcmwoKTtcbmZ1bmN0aW9uIGNvbnZlcnQobWV0YWRhdGEpIHtcbiAgICAvLyBUaGlzIGxvb2tzIHVwIHRoZSBtZXRob2QgbmFtZSBpbiBWZXJpZnlpbmdLZXlcbiAgICBjb25zdCB2ZXJpZnlpbmdLZXkgPSBWZXJpZnlpbmdLZXlbbWV0YWRhdGEudmVyaWZ5aW5nS2V5XTtcbiAgICBpZiAoIXZlcmlmeWluZ0tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1ldGhvZCBuYW1lOiBcIiArIG1ldGFkYXRhLnZlcmlmeWluZ0tleSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUsXG4gICAgICAgIGxvY2F0b3I6IG1ldGFkYXRhLmxvY2F0b3IsXG4gICAgICAgIHByb3ZlcjogbWV0YWRhdGEucHJvdmVyLFxuICAgICAgICB2ZXJpZmllcjogbWV0YWRhdGEudmVyaWZpZXIsXG4gICAgICAgIHZlcmlmeWluZ0tleSxcbiAgICB9O1xufVxuY29uc3QgQ1JFRElUU19QUk9HUkFNX0tFWVMgPSB7XG4gICAgYm9uZF9wdWJsaWM6IGNvbnZlcnQoTWV0YWRhdGEuYm9uZF9wdWJsaWMoKSksXG4gICAgYm9uZF92YWxpZGF0b3I6IGNvbnZlcnQoTWV0YWRhdGEuYm9uZF92YWxpZGF0b3IoKSksXG4gICAgY2xhaW1fdW5ib25kX3B1YmxpYzogY29udmVydChNZXRhZGF0YS5jbGFpbV91bmJvbmRfcHVibGljKCkpLFxuICAgIGZlZV9wcml2YXRlOiBjb252ZXJ0KE1ldGFkYXRhLmZlZV9wcml2YXRlKCkpLFxuICAgIGZlZV9wdWJsaWM6IGNvbnZlcnQoTWV0YWRhdGEuZmVlX3B1YmxpYygpKSxcbiAgICBpbmNsdXNpb246IGNvbnZlcnQoTWV0YWRhdGEuaW5jbHVzaW9uKCkpLFxuICAgIGpvaW46IGNvbnZlcnQoTWV0YWRhdGEuam9pbigpKSxcbiAgICBzZXRfdmFsaWRhdG9yX3N0YXRlOiBjb252ZXJ0KE1ldGFkYXRhLnNldF92YWxpZGF0b3Jfc3RhdGUoKSksXG4gICAgc3BsaXQ6IGNvbnZlcnQoTWV0YWRhdGEuc3BsaXQoKSksXG4gICAgdHJhbnNmZXJfcHJpdmF0ZTogY29udmVydChNZXRhZGF0YS50cmFuc2Zlcl9wcml2YXRlKCkpLFxuICAgIHRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljOiBjb252ZXJ0KE1ldGFkYXRhLnRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljKCkpLFxuICAgIHRyYW5zZmVyX3B1YmxpYzogY29udmVydChNZXRhZGF0YS50cmFuc2Zlcl9wdWJsaWMoKSksXG4gICAgdHJhbnNmZXJfcHVibGljX2FzX3NpZ25lcjogY29udmVydChNZXRhZGF0YS50cmFuc2Zlcl9wdWJsaWNfYXNfc2lnbmVyKCkpLFxuICAgIHRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlOiBjb252ZXJ0KE1ldGFkYXRhLnRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlKCkpLFxuICAgIHVuYm9uZF9wdWJsaWM6IGNvbnZlcnQoTWV0YWRhdGEudW5ib25kX3B1YmxpYygpKSxcbiAgICBnZXRLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5IFwiJHtrZXl9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IFBSSVZBVEVfVFJBTlNGRVJfVFlQRVMgPSBuZXcgU2V0KFtcbiAgICBcInRyYW5zZmVyX3ByaXZhdGVcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInRyYW5zZmVyUHJpdmF0ZVwiLFxuICAgIFwidHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWNcIixcbiAgICBcInByaXZhdGVUb1B1YmxpY1wiLFxuICAgIFwidHJhbnNmZXJQcml2YXRlVG9QdWJsaWNcIixcbl0pO1xuY29uc3QgVkFMSURfVFJBTlNGRVJfVFlQRVMgPSBuZXcgU2V0KFtcbiAgICBcInRyYW5zZmVyX3ByaXZhdGVcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInRyYW5zZmVyUHJpdmF0ZVwiLFxuICAgIFwidHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWNcIixcbiAgICBcInByaXZhdGVUb1B1YmxpY1wiLFxuICAgIFwidHJhbnNmZXJQcml2YXRlVG9QdWJsaWNcIixcbiAgICBcInRyYW5zZmVyX3B1YmxpY1wiLFxuICAgIFwidHJhbnNmZXJfcHVibGljX2FzX3NpZ25lclwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJwdWJsaWNfYXNfc2lnbmVyXCIsXG4gICAgXCJ0cmFuc2ZlclB1YmxpY1wiLFxuICAgIFwidHJhbnNmZXJQdWJsaWNBc1NpZ25lclwiLFxuICAgIFwidHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGVcIixcbiAgICBcInB1YmxpY1RvUHJpdmF0ZVwiLFxuICAgIFwicHVibGljQXNTaWduZXJcIixcbiAgICBcInRyYW5zZmVyUHVibGljVG9Qcml2YXRlXCIsXG5dKTtcbmNvbnN0IFBSSVZBVEVfVFJBTlNGRVIgPSBuZXcgU2V0KFtcbiAgICBcInByaXZhdGVcIixcbiAgICBcInRyYW5zZmVyX3ByaXZhdGVcIixcbiAgICBcInRyYW5zZmVyUHJpdmF0ZVwiLFxuXSk7XG5jb25zdCBQUklWQVRFX1RPX1BVQkxJQ19UUkFOU0ZFUiA9IG5ldyBTZXQoW1xuICAgIFwicHJpdmF0ZV90b19wdWJsaWNcIixcbiAgICBcInByaXZhdGVUb1B1YmxpY1wiLFxuICAgIFwidHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWNcIixcbiAgICBcInRyYW5zZmVyUHJpdmF0ZVRvUHVibGljXCIsXG5dKTtcbmNvbnN0IFBVQkxJQ19UUkFOU0ZFUiA9IG5ldyBTZXQoW1xuICAgIFwicHVibGljXCIsXG4gICAgXCJ0cmFuc2Zlcl9wdWJsaWNcIixcbiAgICBcInRyYW5zZmVyUHVibGljXCIsXG5dKTtcbmNvbnN0IFBVQkxJQ19UUkFOU0ZFUl9BU19TSUdORVIgPSBuZXcgU2V0KFtcbiAgICBcInB1YmxpY19hc19zaWduZXJcIixcbiAgICBcInRyYW5zZmVyX3B1YmxpY19hc19zaWduZXJcIixcbiAgICBcInRyYW5zZmVyUHVibGljQXNTaWduZXJcIixcbl0pO1xuY29uc3QgUFVCTElDX1RPX1BSSVZBVEVfVFJBTlNGRVIgPSBuZXcgU2V0KFtcbiAgICBcInB1YmxpY190b19wcml2YXRlXCIsXG4gICAgXCJwdWJsaWNUb1ByaXZhdGVcIixcbiAgICBcInRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlXCIsXG4gICAgXCJ0cmFuc2ZlclB1YmxpY1RvUHJpdmF0ZVwiLFxuXSk7XG5cbi8qKlxuICogQWxlb0tleVByb3ZpZGVyUGFyYW1zIHNlYXJjaCBwYXJhbWV0ZXIgZm9yIHRoZSBBbGVvS2V5UHJvdmlkZXIuIEl0IGFsbG93cyBmb3IgdGhlIHNwZWNpZmljYXRpb24gb2YgYSBwcm92ZXJVcmkgYW5kXG4gKiB2ZXJpZmllclVyaSB0byBmZXRjaCBrZXlzIHZpYSBIVFRQIGZyb20gYSByZW1vdGUgcmVzb3VyY2UgYXMgd2VsbCBhcyBhIHVuaXF1ZSBjYWNoZUtleSB0byBzdG9yZSB0aGUga2V5cyBpbiBtZW1vcnkuXG4gKi9cbmNsYXNzIEFsZW9LZXlQcm92aWRlclBhcmFtcyB7XG4gICAgbmFtZTtcbiAgICBwcm92ZXJVcmk7XG4gICAgdmVyaWZpZXJVcmk7XG4gICAgY2FjaGVLZXk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEFsZW9LZXlQcm92aWRlclBhcmFtcyBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyB0aGUgS2V5U2VhcmNoUGFyYW1zIGludGVyZmFjZS4gVXNlcnMgY2FuIG9wdGlvbmFsbHlcbiAgICAgKiBzcGVjaWZ5IGEgdXJsIGZvciB0aGUgcHJvdmVyVXJpICYgdmVyaWZpZXJVcmkgdG8gZmV0Y2gga2V5cyB2aWEgSFRUUCBmcm9tIGEgcmVtb3RlIHJlc291cmNlIGFzIHdlbGwgYXMgYSB1bmlxdWVcbiAgICAgKiBjYWNoZUtleSB0byBzdG9yZSB0aGUga2V5cyBpbiBtZW1vcnkgZm9yIGZ1dHVyZSB1c2UuIElmIG5vIHByb3ZlclVyaSBvciB2ZXJpZmllclVyaSBpcyBzcGVjaWZpZWQsIGEgY2FjaGVrZXkgbXVzdFxuICAgICAqIGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsgQWxlb0tleVByb3ZpZGVySW5pdFBhcmFtcyB9IHBhcmFtcyAtIE9wdGlvbmFsIHNlYXJjaCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucHJvdmVyVXJpID0gcGFyYW1zLnByb3ZlclVyaTtcbiAgICAgICAgdGhpcy52ZXJpZmllclVyaSA9IHBhcmFtcy52ZXJpZmllclVyaTtcbiAgICAgICAgdGhpcy5jYWNoZUtleSA9IHBhcmFtcy5jYWNoZUtleTtcbiAgICAgICAgdGhpcy5uYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgfVxufVxuLyoqXG4gKiBBbGVvS2V5UHJvdmlkZXIgY2xhc3MuIEltcGxlbWVudHMgdGhlIEtleVByb3ZpZGVyIGludGVyZmFjZS4gRW5hYmxlcyB0aGUgcmV0cmlldmFsIG9mIEFsZW8gcHJvZ3JhbSBwcm92aW5nIGFuZFxuICogdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbSBvdmVyIGh0dHAgZnJvbSBvZmZpY2lhbCBBbGVvIHNvdXJjZXMgYW5kIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZnVuY3Rpb25cbiAqIGtleXMgZnJvbSBhIGxvY2FsIG1lbW9yeSBjYWNoZS5cbiAqL1xuY2xhc3MgQWxlb0tleVByb3ZpZGVyIHtcbiAgICBjYWNoZTtcbiAgICBjYWNoZU9wdGlvbjtcbiAgICBrZXlVcmlzO1xuICAgIGFzeW5jIGZldGNoQnl0ZXModXJsID0gXCIvXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHVybCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGZldGNoaW5nIGRhdGEuXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5rZXlVcmlzID0gS0VZX1NUT1JFO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNhY2hlT3B0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBsb2NhbCBtZW1vcnkgdG8gc3RvcmUga2V5c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYWNoZSB3aGV0aGVyIHRvIHN0b3JlIGtleXMgaW4gbG9jYWwgbWVtb3J5XG4gICAgICovXG4gICAgdXNlQ2FjaGUodXNlQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZU9wdGlvbiA9IHVzZUNhY2hlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUga2V5IGNhY2hlXG4gICAgICovXG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWNoZSBhIHNldCBvZiBrZXlzLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBleGlzdGluZyBrZXlzIHdpdGggdGhlIHNhbWUga2V5SWQuIFRoZSB1c2VyIGNhbiBjaGVjayBpZiBhIGtleUlkXG4gICAgICogZXhpc3RzIGluIHRoZSBjYWNoZSB1c2luZyB0aGUgY29udGFpbnNLZXlzIG1ldGhvZCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kIGlmIG92ZXJ3cml0aW5nIGlzIG5vdCBkZXNpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleUlkIGFjY2VzcyBrZXkgZm9yIHRoZSBjYWNoZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25LZXlQYWlyfSBrZXlzIGtleXMgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBjYWNoZUtleXMoa2V5SWQsIGtleXMpIHtcbiAgICAgICAgY29uc3QgW3Byb3ZpbmdLZXksIHZlcmlmeWluZ0tleV0gPSBrZXlzO1xuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXlJZCwgW3Byb3ZpbmdLZXkudG9CeXRlcygpLCB2ZXJpZnlpbmdLZXkudG9CeXRlcygpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIGtleUlkIGV4aXN0cyBpbiB0aGUgY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZCBrZXlJZCBvZiBhIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXkgcGFpclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXlJZCBleGlzdHMgaW4gdGhlIGNhY2hlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBjb250YWluc0tleXMoa2V5SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZCBrZXlJZCBvZiBhIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXkgcGFpciB0byBkZWxldGUgZnJvbSBtZW1vcnlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5SWQgZXhpc3RzIGluIHRoZSBjYWNoZSBhbmQgd2FzIGRlbGV0ZWQsIGZhbHNlIGlmIHRoZSBrZXkgZGlkIG5vdCBleGlzdFxuICAgICAqL1xuICAgIGRlbGV0ZUtleXMoa2V5SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsZXRlKGtleUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgY2FjaGVcbiAgICAgKiBAcGFyYW0ga2V5SWQga2V5SWQgb2YgYSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5IHBhaXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbktleVBhaXJ9IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cbiAgICAgKi9cbiAgICBnZXRLZXlzKGtleUlkKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoYENoZWNraW5nIGlmIGtleSBleGlzdHMgaW4gY2FjaGUuIEtleUlkOiAke2tleUlkfWApO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5SWQpKSB7XG4gICAgICAgICAgICBjb25zdCBbcHJvdmluZ0tleUJ5dGVzLCB2ZXJpZnlpbmdLZXlCeXRlc10gPSB0aGlzLmNhY2hlLmdldChrZXlJZCk7XG4gICAgICAgICAgICByZXR1cm4gW1Byb3ZpbmdLZXkuZnJvbUJ5dGVzKHByb3ZpbmdLZXlCeXRlcyksIFZlcmlmeWluZ0tleS5mcm9tQnl0ZXModmVyaWZ5aW5nS2V5Qnl0ZXMpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBub3QgZm91bmQgaW4gY2FjaGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhcmJpdHJhcnkgZnVuY3Rpb24ga2V5cyBmcm9tIGEgcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5U2VhcmNoUGFyYW1zfSBwYXJhbXMgcGFyYW1ldGVycyBmb3IgdGhlIGtleSBzZWFyY2ggaW4gZm9ybSBvZjoge3Byb3ZlclVyaTogc3RyaW5nLCB2ZXJpZmllclVyaTogc3RyaW5nLCBjYWNoZUtleTogc3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZSBLZXlQcm92aWRlciBpbnRlcmZhY2VcbiAgICAgKiBjb25zdCBuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIpO1xuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGNvbnN0IHJlY29yZFByb3ZpZGVyID0gbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlcihhY2NvdW50LCBuZXR3b3JrQ2xpZW50KTtcbiAgICAgKlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBwcm9ncmFtIG1hbmFnZXIgd2l0aCB0aGUga2V5IHByb3ZpZGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2gga2V5cyBmb3IgdmFsdWUgdHJhbnNmZXJzXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKiBwcm9ncmFtTWFuYWdlci50cmFuc2ZlcigxLCBcImFsZW8xNjZxNnd3NjY4OGN1ZzdxeHdlN25oY3RqcHlteWR3enkyaDdyc2NmbWF0cW1md25qdmdncWNhZDBhdFwiLCBcInB1YmxpY1wiLCAwLjUpO1xuICAgICAqXG4gICAgICogLy8gS2V5cyBjYW4gYWxzbyBiZSBmZXRjaGVkIG1hbnVhbGx5IHVzaW5nIHRoZSBrZXkgcHJvdmlkZXJcbiAgICAgKiBjb25zdCBrZXlTZWFyY2hQYXJhbXMgPSB7IFwiY2FjaGVLZXlcIjogXCJteVByb2dyYW06bXlGdW5jdGlvblwiIH07XG4gICAgICogY29uc3QgW3RyYW5zZmVyUHJpdmF0ZVByb3ZpbmdLZXksIHRyYW5zZmVyUHJpdmF0ZVZlcmlmeWluZ0tleV0gPSBhd2FpdCBrZXlQcm92aWRlci5mdW5jdGlvbktleXMoa2V5U2VhcmNoUGFyYW1zKTtcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbktleXMocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGxldCBwcm92ZXJVcmw7XG4gICAgICAgICAgICBsZXQgdmVyaWZpZXJVcmw7XG4gICAgICAgICAgICBsZXQgY2FjaGVLZXk7XG4gICAgICAgICAgICBpZiAoXCJuYW1lXCIgaW4gcGFyYW1zICYmIHR5cGVvZiBwYXJhbXNbXCJuYW1lXCJdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gQ1JFRElUU19QUk9HUkFNX0tFWVMuZ2V0S2V5KHBhcmFtc1tcIm5hbWVcIl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoQ3JlZGl0c0tleXMoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInByb3ZlclVyaVwiIGluIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zW1wicHJvdmVyVXJpXCJdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwcm92ZXJVcmwgPSBwYXJhbXNbXCJwcm92ZXJVcmlcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ2ZXJpZmllclVyaVwiIGluIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zW1widmVyaWZpZXJVcmlcIl0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZlcmlmaWVyVXJsID0gcGFyYW1zW1widmVyaWZpZXJVcmlcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJjYWNoZUtleVwiIGluIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zW1wiY2FjaGVLZXlcIl0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gcGFyYW1zW1wiY2FjaGVLZXlcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvdmVyVXJsICYmIHZlcmlmaWVyVXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hSZW1vdGVLZXlzKHByb3ZlclVybCwgdmVyaWZpZXJVcmwsIGNhY2hlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleXMoY2FjaGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVycyBwcm92aWRlZCwgbXVzdCBwcm92aWRlIGVpdGhlciBhIGNhY2hlS2V5IGFuZC9vciBhIHByb3ZlclVybCBhbmQgYSB2ZXJpZmllclVybFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIGEgc3BlY2lmaWVkIHByb2dyYW0gZnJvbSBhIHNwZWNpZmllZCB1cmwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyaWZpZXJVcmwgVXJsIG9mIHRoZSBwcm92aW5nIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92ZXJVcmwgVXJsIHRoZSB2ZXJpZnlpbmcga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlS2V5IEtleSB0byBzdG9yZSB0aGUga2V5cyBpbiB0aGUgY2FjaGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IEFsZW9LZXlQcm92aWRlciBvYmplY3RcbiAgICAgKiBjb25zdCBuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIpO1xuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGNvbnN0IHJlY29yZFByb3ZpZGVyID0gbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlcihhY2NvdW50LCBuZXR3b3JrQ2xpZW50KTtcbiAgICAgKlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBwcm9ncmFtIG1hbmFnZXIgd2l0aCB0aGUga2V5IHByb3ZpZGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2gga2V5cyBmb3IgdmFsdWUgdHJhbnNmZXJzXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKiBwcm9ncmFtTWFuYWdlci50cmFuc2ZlcigxLCBcImFsZW8xNjZxNnd3NjY4OGN1ZzdxeHdlN25oY3RqcHlteWR3enkyaDdyc2NmbWF0cW1md25qdmdncWNhZDBhdFwiLCBcInB1YmxpY1wiLCAwLjUpO1xuICAgICAqXG4gICAgICogLy8gS2V5cyBjYW4gYWxzbyBiZSBmZXRjaGVkIG1hbnVhbGx5XG4gICAgICogY29uc3QgW3RyYW5zZmVyUHJpdmF0ZVByb3ZpbmdLZXksIHRyYW5zZmVyUHJpdmF0ZVZlcmlmeWluZ0tleV0gPSBhd2FpdCBrZXlQcm92aWRlci5mZXRjaEtleXMoXG4gICAgICogICAgIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3ByaXZhdGUucHJvdmVyLFxuICAgICAqICAgICBDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wcml2YXRlLnZlcmlmaWVyLFxuICAgICAqICk7XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hSZW1vdGVLZXlzKHByb3ZlclVybCwgdmVyaWZpZXJVcmwsIGNhY2hlS2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBjYWNoZSBpcyBlbmFibGVkLCBjaGVjayBpZiB0aGUga2V5cyBoYXZlIGFscmVhZHkgYmVlbiBmZXRjaGVkIGFuZCByZXR1cm4gdGhlbSBpZiB0aGV5IGhhdmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IHByb3ZlclVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1Byb3ZpbmdLZXkuZnJvbUJ5dGVzKHZhbHVlWzBdKSwgVmVyaWZ5aW5nS2V5LmZyb21CeXRlcyh2YWx1ZVsxXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkZldGNoaW5nIHByb3Zpbmcga2V5cyBmcm9tIHVybCBcIiArIHByb3ZlclVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhhd2FpdCB0aGlzLmZldGNoQnl0ZXMocHJvdmVyVXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJGZXRjaGluZyB2ZXJpZnlpbmcga2V5cyBcIiArIHZlcmlmaWVyVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyaWZ5aW5nS2V5ID0gKGF3YWl0IHRoaXMuZ2V0VmVyaWZ5aW5nS2V5KHZlcmlmaWVyVXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCBbcHJvdmluZ0tleS50b0J5dGVzKCksIHZlcmlmeWluZ0tleS50b0J5dGVzKCldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGNhY2hlIGlzIGRpc2FibGVkLCBmZXRjaCB0aGUga2V5cyBhbmQgcmV0dXJuIHRoZW1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aW5nS2V5ID0gUHJvdmluZ0tleS5mcm9tQnl0ZXMoYXdhaXQgdGhpcy5mZXRjaEJ5dGVzKHByb3ZlclVybCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmeWluZ0tleSA9IChhd2FpdCB0aGlzLmdldFZlcmlmeWluZ0tleSh2ZXJpZmllclVybCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvdmluZ0tleSwgdmVyaWZ5aW5nS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX0gZmV0Y2hpbmcgZmVlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZyb20gJHtwcm92ZXJVcmx9IGFuZCAke3ZlcmlmaWVyVXJsfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKioqXG4gICAgICogRmV0Y2hlcyB0aGUgcHJvdmluZyBrZXkgZnJvbSBhIHJlbW90ZSBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmVyVXJsXG4gICAgICogQHBhcmFtIGNhY2hlS2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm92aW5nS2V5Pn0gUHJvdmluZyBrZXkgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUHJvdmluZ0tleShwcm92ZXJVcmwsIGNhY2hlS2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBjYWNoZSBpcyBlbmFibGVkLCBjaGVjayBpZiB0aGUga2V5cyBoYXZlIGFscmVhZHkgYmVlbiBmZXRjaGVkIGFuZCByZXR1cm4gdGhlbSBpZiB0aGV5IGhhdmVcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IHByb3ZlclVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvdmluZ0tleS5mcm9tQnl0ZXModmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkZldGNoaW5nIHByb3Zpbmcga2V5cyBmcm9tIHVybCBcIiArIHByb3ZlclVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhhd2FpdCB0aGlzLmZldGNoQnl0ZXMocHJvdmVyVXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aW5nS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpbmdLZXkgPSBQcm92aW5nS2V5LmZyb21CeXRlcyhhd2FpdCB0aGlzLmZldGNoQnl0ZXMocHJvdmVyVXJsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpbmdLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9IGZldGNoaW5nIGZlZSBwcm92aW5nIGtleXMgZnJvbSAke3Byb3ZlclVybH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaENyZWRpdHNLZXlzKGtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkubG9jYXRvcikgfHwgIXRoaXMuY2FjaGVPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJpZnlpbmdfa2V5ID0ga2V5LnZlcmlmeWluZ0tleSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpbmdfa2V5ID0gYXdhaXQgdGhpcy5mZXRjaFByb3ZpbmdLZXkoa2V5LnByb3Zlciwga2V5LmxvY2F0b3IpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfcHVibGljLmxvY2F0b3IsIFtwcm92aW5nX2tleS50b0J5dGVzKCksIHZlcmlmeWluZ19rZXkudG9CeXRlcygpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvdmluZ19rZXksIHZlcmlmeWluZ19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IHRoaXMuY2FjaGUuZ2V0KGtleS5sb2NhdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1Byb3ZpbmdLZXkuZnJvbUJ5dGVzKGtleVBhaXJbMF0pLCBWZXJpZnlpbmdLZXkuZnJvbUJ5dGVzKGtleVBhaXJbMV0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3I6IGZldGNoaW5nIGNyZWRpdHMuYWxlbyBrZXlzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYm9uZFB1YmxpY0tleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF9wdWJsaWMpO1xuICAgIH1cbiAgICBib25kVmFsaWRhdG9yS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hDcmVkaXRzS2V5cyhDUkVESVRTX1BST0dSQU1fS0VZUy5ib25kX3ZhbGlkYXRvcik7XG4gICAgfVxuICAgIGNsYWltVW5ib25kUHVibGljS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hDcmVkaXRzS2V5cyhDUkVESVRTX1BST0dSQU1fS0VZUy5jbGFpbV91bmJvbmRfcHVibGljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSB0cmFuc2ZlciBmdW5jdGlvbnMgaW4gdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpc2liaWxpdHkgVmlzaWJpbGl0eSBvZiB0aGUgdHJhbnNmZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbktleVBhaXI+fSBQcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIHRyYW5zZmVyIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQWxlb0tleVByb3ZpZGVyXG4gICAgICogY29uc3QgbmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBjb25zdCByZWNvcmRQcm92aWRlciA9IG5ldyBOZXR3b3JrUmVjb3JkUHJvdmlkZXIoYWNjb3VudCwgbmV0d29ya0NsaWVudCk7XG4gICAgICpcbiAgICAgKiAvLyBJbml0aWFsaXplIGEgcHJvZ3JhbSBtYW5hZ2VyIHdpdGggdGhlIGtleSBwcm92aWRlciB0byBhdXRvbWF0aWNhbGx5IGZldGNoIGtleXMgZm9yIHZhbHVlIHRyYW5zZmVyc1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCByZWNvcmRQcm92aWRlcik7XG4gICAgICogcHJvZ3JhbU1hbmFnZXIudHJhbnNmZXIoMSwgXCJhbGVvMTY2cTZ3dzY2ODhjdWc3cXh3ZTduaGN0anB5bXlkd3p5Mmg3cnNjZm1hdHFtZnduanZnZ3FjYWQwYXRcIiwgXCJwdWJsaWNcIiwgMC41KTtcbiAgICAgKlxuICAgICAqIC8vIEtleXMgY2FuIGFsc28gYmUgZmV0Y2hlZCBtYW51YWxseVxuICAgICAqIGNvbnN0IFt0cmFuc2ZlclB1YmxpY1Byb3ZpbmdLZXksIHRyYW5zZmVyUHVibGljVmVyaWZ5aW5nS2V5XSA9IGF3YWl0IGtleVByb3ZpZGVyLnRyYW5zZmVyS2V5cyhcInB1YmxpY1wiKTtcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2ZlcktleXModmlzaWJpbGl0eSkge1xuICAgICAgICBpZiAoUFJJVkFURV9UUkFOU0ZFUi5oYXModmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHJpdmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUFJJVkFURV9UT19QVUJMSUNfVFJBTlNGRVIuaGFzKHZpc2liaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaENyZWRpdHNLZXlzKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQVUJMSUNfVFJBTlNGRVIuaGFzKHZpc2liaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaENyZWRpdHNLZXlzKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUFVCTElDX1RSQU5TRkVSX0FTX1NJR05FUi5oYXModmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHVibGljX2FzX3NpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUFVCTElDX1RPX1BSSVZBVEVfVFJBTlNGRVIuaGFzKHZpc2liaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaENyZWRpdHNLZXlzKENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmlzaWJpbGl0eSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgam9pbiBmdW5jdGlvbiBpbiB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgam9pbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGpvaW5LZXlzKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaENyZWRpdHNLZXlzKENSRURJVFNfUFJPR1JBTV9LRVlTLmpvaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIHNwbGl0IGZ1bmN0aW9uIGluIHRoZSBjcmVkaXRzLmFsZW8gcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn0gUHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBzcGxpdCBmdW5jdGlvblxuICAgICAqICovXG4gICAgYXN5bmMgc3BsaXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaENyZWRpdHNLZXlzKENSRURJVFNfUFJPR1JBTV9LRVlTLnNwbGl0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZm9yIHRoZSBmZWVfcHJpdmF0ZSBmdW5jdGlvbiBpbiB0aGUgY3JlZGl0cy5hbGVvIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bmN0aW9uS2V5UGFpcj59IFByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciB0aGUgZmVlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZmVlUHJpdmF0ZUtleXMoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3ByaXZhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGZlZV9wdWJsaWMgZnVuY3Rpb24gaW4gdGhlIGNyZWRpdHMuYWxlbyBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5jdGlvbktleVBhaXI+fSBQcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGZlZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGZlZVB1YmxpY0tleXMoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3B1YmxpYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSB2ZXJpZnlpbmcga2V5LiBJZiB0aGUgdmVyaWZ5aW5nIGtleSBpcyBmb3IgYSBjcmVkaXRzLmFsZW8gZnVuY3Rpb24sIGdldCBpdCBmcm9tIHRoZSB3YXNtIGNhY2hlIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VmVyaWZ5aW5nS2V5Pn0gVmVyaWZ5aW5nIGtleSBmb3IgdGhlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgLy8gYXR0ZW1wdCB0byBmZXRjaCBpdCBmcm9tIHRoZSBuZXR3b3JrXG4gICAgYXN5bmMgZ2V0VmVyaWZ5aW5nS2V5KHZlcmlmaWVyVXJpKSB7XG4gICAgICAgIHN3aXRjaCAodmVyaWZpZXJVcmkpIHtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF9wdWJsaWMudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfcHVibGljLnZlcmlmeWluZ0tleSgpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy5ib25kX3ZhbGlkYXRvci52ZXJpZmllcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF92YWxpZGF0b3IudmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmNsYWltX3VuYm9uZF9wdWJsaWMudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLmNsYWltX3VuYm9uZF9wdWJsaWMudmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmZlZV9wcml2YXRlLnZlcmlmaWVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBDUkVESVRTX1BST0dSQU1fS0VZUy5mZWVfcHJpdmF0ZS52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3B1YmxpYy52ZXJpZmllcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1JFRElUU19QUk9HUkFNX0tFWVMuZmVlX3B1YmxpYy52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMuaW5jbHVzaW9uLnZlcmlmaWVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBDUkVESVRTX1BST0dSQU1fS0VZUy5pbmNsdXNpb24udmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLmpvaW4udmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLmpvaW4udmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLnNldF92YWxpZGF0b3Jfc3RhdGUudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLnNldF92YWxpZGF0b3Jfc3RhdGUudmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICBjYXNlIENSRURJVFNfUFJPR1JBTV9LRVlTLnNwbGl0LnZlcmlmaWVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBDUkVESVRTX1BST0dSQU1fS0VZUy5zcGxpdC52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHJpdmF0ZS52ZXJpZmllcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHJpdmF0ZS52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHJpdmF0ZV90b19wdWJsaWMudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3ByaXZhdGVfdG9fcHVibGljLnZlcmlmeWluZ0tleSgpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy50cmFuc2Zlcl9wdWJsaWMudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpYy52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHVibGljX2FzX3NpZ25lci52ZXJpZmllcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHVibGljX2FzX3NpZ25lci52ZXJpZnlpbmdLZXkoKTtcbiAgICAgICAgICAgIGNhc2UgQ1JFRElUU19QUk9HUkFNX0tFWVMudHJhbnNmZXJfcHVibGljX3RvX3ByaXZhdGUudmVyaWZpZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENSRURJVFNfUFJPR1JBTV9LRVlTLnRyYW5zZmVyX3B1YmxpY190b19wcml2YXRlLnZlcmlmeWluZ0tleSgpO1xuICAgICAgICAgICAgY2FzZSBDUkVESVRTX1BST0dSQU1fS0VZUy51bmJvbmRfcHVibGljLnZlcmlmaWVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBDUkVESVRTX1BST0dSQU1fS0VZUy51bmJvbmRfcHVibGljLnZlcmlmeWluZ0tleSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLy8gVHJ5IHRvIGZldGNoIHRoZSB2ZXJpZnlpbmcga2V5IGZyb20gdGhlIG5ldHdvcmsgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXQodmVyaWZpZXJVcmkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmVyaWZ5aW5nS2V5LmZyb21TdHJpbmcodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vLyBJZiB0aGF0IGZhaWxzLCB0cnkgdG8gZmV0Y2ggdGhlIHZlcmlmeWluZyBrZXkgZnJvbSB0aGUgbmV0d29yayBhcyBieXRlc1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlcmlmeWluZ0tleS5mcm9tQnl0ZXMoYXdhaXQgdGhpcy5mZXRjaEJ5dGVzKHZlcmlmaWVyVXJpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcmlmeWluZyBrZXkuIEVycm9yOiBcIiArIGlubmVyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVuQm9uZFB1YmxpY0tleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoQ3JlZGl0c0tleXMoQ1JFRElUU19QUk9HUkFNX0tFWVMudW5ib25kX3B1YmxpYyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBQcm9ncmFtTWFuYWdlciBjbGFzcyBpcyB1c2VkIHRvIGV4ZWN1dGUgYW5kIGRlcGxveSBwcm9ncmFtcyBvbiB0aGUgQWxlbyBuZXR3b3JrIGFuZCBjcmVhdGUgdmFsdWUgdHJhbnNmZXJzLlxuICovXG5jbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gICAgYWNjb3VudDtcbiAgICBrZXlQcm92aWRlcjtcbiAgICBob3N0O1xuICAgIG5ldHdvcmtDbGllbnQ7XG4gICAgcmVjb3JkUHJvdmlkZXI7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUHJvZ3JhbU1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHVuZGVmaW5lZCB9IGhvc3QgQSBob3N0IHVyaSBydW5uaW5nIHRoZSBvZmZpY2lhbCBBbGVvIEFQSVxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uS2V5UHJvdmlkZXIgfCB1bmRlZmluZWQgfSBrZXlQcm92aWRlciBBIGtleSBwcm92aWRlciB0aGF0IGltcGxlbWVudHMge0BsaW5rIEZ1bmN0aW9uS2V5UHJvdmlkZXJ9IGludGVyZmFjZVxuICAgICAqIEBwYXJhbSB7IFJlY29yZFByb3ZpZGVyIHwgdW5kZWZpbmVkIH0gcmVjb3JkUHJvdmlkZXIgQSByZWNvcmQgcHJvdmlkZXIgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBSZWNvcmRQcm92aWRlcn0gaW50ZXJmYWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaG9zdCwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3QgPyBob3N0IDogJ2h0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MSc7XG4gICAgICAgIHRoaXMubmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudCh0aGlzLmhvc3QpO1xuICAgICAgICB0aGlzLmtleVByb3ZpZGVyID0ga2V5UHJvdmlkZXIgPyBrZXlQcm92aWRlciA6IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5yZWNvcmRQcm92aWRlciA9IHJlY29yZFByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGFjY291bnQgdG8gdXNlIGZvciB0cmFuc2FjdGlvbiBzdWJtaXNzaW9uIHRvIHRoZSBBbGVvIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QWNjb3VudH0gYWNjb3VudCBBY2NvdW50IHRvIHVzZSBmb3IgdHJhbnNhY3Rpb24gc3VibWlzc2lvblxuICAgICAqL1xuICAgIHNldEFjY291bnQoYWNjb3VudCkge1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGtleSBwcm92aWRlciB0aGF0IHByb3ZpZGVzIHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgcHJvZ3JhbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25LZXlQcm92aWRlcn0ga2V5UHJvdmlkZXJcbiAgICAgKi9cbiAgICBzZXRLZXlQcm92aWRlcihrZXlQcm92aWRlcikge1xuICAgICAgICB0aGlzLmtleVByb3ZpZGVyID0ga2V5UHJvdmlkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaG9zdCBwZWVyIHRvIHVzZSBmb3IgdHJhbnNhY3Rpb24gc3VibWlzc2lvbiB0byB0aGUgQWxlbyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdCB7c3RyaW5nfSBQZWVyIHVybCB0byB1c2UgZm9yIHRyYW5zYWN0aW9uIHN1Ym1pc3Npb25cbiAgICAgKi9cbiAgICBzZXRIb3N0KGhvc3QpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ2xpZW50LnNldEhvc3QoaG9zdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVjb3JkIHByb3ZpZGVyIHRoYXQgcHJvdmlkZXMgcmVjb3JkcyBmb3IgdHJhbnNhY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY29yZFByb3ZpZGVyfSByZWNvcmRQcm92aWRlclxuICAgICAqL1xuICAgIHNldFJlY29yZFByb3ZpZGVyKHJlY29yZFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucmVjb3JkUHJvdmlkZXIgPSByZWNvcmRQcm92aWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvbiBmb3Igc3VibWlzc2lvbiB0byB0aGUgQWxlbyBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW0gUHJvZ3JhbSBzb3VyY2UgY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmZWUgRmVlIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcml2YXRlRmVlIFVzZSBhIHByaXZhdGUgcmVjb3JkIHRvIHBheSB0aGUgZmVlLiBJZiBmYWxzZSB0aGlzIHdpbGwgdXNlIHRoZSBhY2NvdW50J3MgcHVibGljIGNyZWRpdCBiYWxhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvcmRTZWFyY2hQYXJhbXMgfCB1bmRlZmluZWR9IHJlY29yZFNlYXJjaFBhcmFtcyBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBzZWFyY2hpbmcgZm9yIGEgcmVjb3JkIHRvIHVzZVxuICAgICAqIHBheSB0aGUgZGVwbG95bWVudCBmZWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlY29yZFBsYWludGV4dCB8IHVuZGVmaW5lZH0gZmVlUmVjb3JkIE9wdGlvbmFsIEZlZSByZWNvcmQgdG8gdXNlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXkgfCB1bmRlZmluZWR9IHByaXZhdGVLZXkgT3B0aW9uYWwgcHJpdmF0ZSBrZXkgdG8gdXNlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNhY3Rpb24gaWQgb2YgdGhlIGRlcGxveWVkIHByb2dyYW0gb3IgYSBmYWlsdXJlIG1lc3NhZ2UgZnJvbSB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTmV0d29ya0NsaWVudCwgS2V5UHJvdmlkZXIsIGFuZCBSZWNvcmRQcm92aWRlclxuICAgICAqIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBuZXcgQWxlb05ldHdvcmtDbGllbnQoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIik7XG4gICAgICogY29uc3Qga2V5UHJvdmlkZXIgPSBuZXcgQWxlb0tleVByb3ZpZGVyKCk7XG4gICAgICogY29uc3QgcmVjb3JkUHJvdmlkZXIgPSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyKGFjY291bnQsIG5ldHdvcmtDbGllbnQpO1xuICAgICAqXG4gICAgICogLy8gSW5pdGlhbGl6ZSBhIHByb2dyYW0gbWFuYWdlciB3aXRoIHRoZSBrZXkgcHJvdmlkZXIgdG8gYXV0b21hdGljYWxseSBmZXRjaCBrZXlzIGZvciBkZXBsb3ltZW50c1xuICAgICAqIGNvbnN0IHByb2dyYW0gPSBcInByb2dyYW0gaGVsbG9faGVsbG8uYWxlbztcXG5cXG5mdW5jdGlvbiBoZWxsbzpcXG4gICAgaW5wdXQgcjAgYXMgdTMyLnB1YmxpYztcXG4gICAgaW5wdXQgcjEgYXMgdTMyLnByaXZhdGU7XFxuICAgIGFkZCByMCByMSBpbnRvIHIyO1xcbiAgICBvdXRwdXQgcjIgYXMgdTMyLnByaXZhdGU7XFxuXCI7XG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKlxuICAgICAqIC8vIERlZmluZSBhIGZlZSBpbiBjcmVkaXRzXG4gICAgICogY29uc3QgZmVlID0gMS4yO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uLlxuICAgICAqIGNvbnN0IHR4ID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuYnVpbGREZXBsb3ltZW50VHJhbnNhY3Rpb24ocHJvZ3JhbSwgZmVlLCBmYWxzZSk7XG4gICAgICovXG4gICAgYXN5bmMgYnVpbGREZXBsb3ltZW50VHJhbnNhY3Rpb24ocHJvZ3JhbSwgZmVlLCBwcml2YXRlRmVlLCByZWNvcmRTZWFyY2hQYXJhbXMsIGZlZVJlY29yZCwgcHJpdmF0ZUtleSkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHByb2dyYW0gaXMgdmFsaWQgYW5kIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBuZXR3b3JrXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmFtT2JqZWN0ID0gUHJvZ3JhbS5mcm9tU3RyaW5nKHByb2dyYW0pO1xuICAgICAgICAgICAgbGV0IHByb2dyYW1Tb3VyY2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb2dyYW1Tb3VyY2UgPSBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuZ2V0UHJvZ3JhbShwcm9ncmFtT2JqZWN0LmlkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9ncmFtIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBuZXR3b3JrLCBkZXBsb3ltZW50IGNhbiBwcm9jZWVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2dyYW0gJHtwcm9ncmFtT2JqZWN0LmlkKCl9IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBuZXR3b3JrLCBkZXBsb3lpbmcuLi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvZ3JhbVNvdXJjZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGBQcm9ncmFtICR7cHJvZ3JhbU9iamVjdC5pZCgpfSBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgbmV0d29yaywgcGxlYXNlIHJlbmFtZSB5b3VyIHByb2dyYW1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nQW5kVGhyb3coYEVycm9yIHZhbGlkYXRpbmcgcHJvZ3JhbTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBwcml2YXRlIGtleSBmcm9tIHRoZSBhY2NvdW50IGlmIGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgcGFyYW1ldGVyc1xuICAgICAgICBsZXQgZGVwbG95bWVudFByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMuYWNjb3VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGVwbG95bWVudFByaXZhdGVLZXkgPSB0aGlzLmFjY291bnQucHJpdmF0ZUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVwbG95bWVudFByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IChcIk5vIHByaXZhdGUga2V5IHByb3ZpZGVkIGFuZCBubyBwcml2YXRlIGtleSBzZXQgaW4gdGhlIFByb2dyYW1NYW5hZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgZmVlIHJlY29yZCBmcm9tIHRoZSBhY2NvdW50IGlmIGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgcGFyYW1ldGVyc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmVlUmVjb3JkID0gcHJpdmF0ZUZlZSA/IGF3YWl0IHRoaXMuZ2V0Q3JlZGl0c1JlY29yZChmZWUsIFtdLCBmZWVSZWNvcmQsIHJlY29yZFNlYXJjaFBhcmFtcykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0FuZFRocm93KGBFcnJvciBmaW5kaW5nIGZlZSByZWNvcmQuIFJlY29yZCBmaW5kZXIgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb25uZWN0ZWQgdG8gYSB2YWxpZCBBbGVvIG5ldHdvcmsgYW5kIGEgcmVjb3JkIHdpdGggZW5vdWdoIGJhbGFuY2UgZXhpc3RzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgZnJvbSB0aGUga2V5IHByb3ZpZGVyXG4gICAgICAgIGxldCBmZWVLZXlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmVlS2V5cyA9IHByaXZhdGVGZWUgPyBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLmZlZVByaXZhdGVLZXlzKCkgOiBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLmZlZVB1YmxpY0tleXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nQW5kVGhyb3coYEVycm9yIGZpbmRpbmcgZmVlIGtleXMuIEtleSBmaW5kZXIgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdXIga2V5IHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWQgY29ycmVjdGx5LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtmZWVQcm92aW5nS2V5LCBmZWVWZXJpZnlpbmdLZXldID0gZmVlS2V5cztcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvZ3JhbSBpbXBvcnRzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgbGV0IGltcG9ydHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbXBvcnRzID0gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LmdldFByb2dyYW1JbXBvcnRzKHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBwcm9ncmFtIGltcG9ydHMuIE5ldHdvcmsgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb25uZWN0ZWQgdG8gYSB2YWxpZCBBbGVvIG5ldHdvcmsgYW5kIHRoZSBwcm9ncmFtIGlzIGRlcGxveWVkIHRvIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvbiBhbmQgc3VibWl0IGl0IHRvIHRoZSBuZXR3b3JrXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9ncmFtTWFuYWdlciQxLmJ1aWxkRGVwbG95bWVudFRyYW5zYWN0aW9uKGRlcGxveW1lbnRQcml2YXRlS2V5LCBwcm9ncmFtLCBmZWUsIGZlZVJlY29yZCwgdGhpcy5ob3N0LCBpbXBvcnRzLCBmZWVQcm92aW5nS2V5LCBmZWVWZXJpZnlpbmdLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3kgYW4gQWxlbyBwcm9ncmFtIHRvIHRoZSBBbGVvIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtIFByb2dyYW0gc291cmNlIGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlIEZlZSB0byBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJpdmF0ZUZlZSBVc2UgYSBwcml2YXRlIHJlY29yZCB0byBwYXkgdGhlIGZlZS4gSWYgZmFsc2UgdGhpcyB3aWxsIHVzZSB0aGUgYWNjb3VudCdzIHB1YmxpYyBjcmVkaXQgYmFsYW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb3JkU2VhcmNoUGFyYW1zIHwgdW5kZWZpbmVkfSByZWNvcmRTZWFyY2hQYXJhbXMgT3B0aW9uYWwgcGFyYW1ldGVycyBmb3Igc2VhcmNoaW5nIGZvciBhIHJlY29yZCB0byB1c2VcbiAgICAgKiBwYXkgdGhlIGRlcGxveW1lbnQgZmVlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmRQbGFpbnRleHQgfCB1bmRlZmluZWR9IGZlZVJlY29yZCBPcHRpb25hbCBGZWUgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5IHwgdW5kZWZpbmVkfSBwcml2YXRlS2V5IE9wdGlvbmFsIHByaXZhdGUga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zYWN0aW9uIGlkIG9mIHRoZSBkZXBsb3llZCBwcm9ncmFtIG9yIGEgZmFpbHVyZSBtZXNzYWdlIGZyb20gdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE5ldHdvcmtDbGllbnQsIEtleVByb3ZpZGVyLCBhbmQgUmVjb3JkUHJvdmlkZXJcbiAgICAgKiBjb25zdCBuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIpO1xuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGNvbnN0IHJlY29yZFByb3ZpZGVyID0gbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlcihhY2NvdW50LCBuZXR3b3JrQ2xpZW50KTtcbiAgICAgKlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBwcm9ncmFtIG1hbmFnZXIgd2l0aCB0aGUga2V5IHByb3ZpZGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2gga2V5cyBmb3IgZGVwbG95bWVudHNcbiAgICAgKiBjb25zdCBwcm9ncmFtID0gXCJwcm9ncmFtIGhlbGxvX2hlbGxvLmFsZW87XFxuXFxuZnVuY3Rpb24gaGVsbG86XFxuICAgIGlucHV0IHIwIGFzIHUzMi5wdWJsaWM7XFxuICAgIGlucHV0IHIxIGFzIHUzMi5wcml2YXRlO1xcbiAgICBhZGQgcjAgcjEgaW50byByMjtcXG4gICAgb3V0cHV0IHIyIGFzIHUzMi5wcml2YXRlO1xcblwiO1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCByZWNvcmRQcm92aWRlcik7XG4gICAgICpcbiAgICAgKiAvLyBEZWZpbmUgYSBmZWUgaW4gY3JlZGl0c1xuICAgICAqIGNvbnN0IGZlZSA9IDEuMjtcbiAgICAgKlxuICAgICAqIC8vIERlcGxveSB0aGUgcHJvZ3JhbVxuICAgICAqIGNvbnN0IHR4X2lkID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuZGVwbG95KHByb2dyYW0sIGZlZSwgZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gVmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5nZXRUcmFuc2FjdGlvbih0eF9pZCk7XG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95KHByb2dyYW0sIGZlZSwgcHJpdmF0ZUZlZSwgcmVjb3JkU2VhcmNoUGFyYW1zLCBmZWVSZWNvcmQsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmJ1aWxkRGVwbG95bWVudFRyYW5zYWN0aW9uKHByb2dyYW0sIGZlZSwgcHJpdmF0ZUZlZSwgcmVjb3JkU2VhcmNoUGFyYW1zLCBmZWVSZWNvcmQsIHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGV4ZWN1dGlvbiB0cmFuc2FjdGlvbiBmb3Igc3VibWlzc2lvbiB0byB0aGUgQWxlbyBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFeGVjdXRlT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgZXhlY3V0aW9uIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gb3IgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBOZXR3b3JrQ2xpZW50LCBLZXlQcm92aWRlciwgYW5kIFJlY29yZFByb3ZpZGVyIHVzaW5nIG9mZmljaWFsIEFsZW8gcmVjb3JkLCBrZXksIGFuZCBuZXR3b3JrIHByb3ZpZGVyc1xuICAgICAqIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBuZXcgQWxlb05ldHdvcmtDbGllbnQoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIik7XG4gICAgICogY29uc3Qga2V5UHJvdmlkZXIgPSBuZXcgQWxlb0tleVByb3ZpZGVyKCk7XG4gICAgICoga2V5UHJvdmlkZXIudXNlQ2FjaGUgPSB0cnVlO1xuICAgICAqIGNvbnN0IHJlY29yZFByb3ZpZGVyID0gbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlcihhY2NvdW50LCBuZXR3b3JrQ2xpZW50KTtcbiAgICAgKlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBwcm9ncmFtIG1hbmFnZXIgd2l0aCB0aGUga2V5IHByb3ZpZGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2gga2V5cyBmb3IgZXhlY3V0aW9uc1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCByZWNvcmRQcm92aWRlcik7XG4gICAgICpcbiAgICAgKiAvLyBCdWlsZCBhbmQgZXhlY3V0ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHByb2dyYW1NYW5hZ2VyLmJ1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24oe1xuICAgICAqICAgcHJvZ3JhbU5hbWU6IFwiaGVsbG9faGVsbG8uYWxlb1wiLFxuICAgICAqICAgZnVuY3Rpb25OYW1lOiBcImhlbGxvX2hlbGxvXCIsXG4gICAgICogICBmZWU6IDAuMDIwLFxuICAgICAqICAgcHJpdmF0ZUZlZTogZmFsc2UsXG4gICAgICogICBpbnB1dHM6IFtcIjV1MzJcIiwgXCI1dTMyXCJdLFxuICAgICAqICAga2V5U2VhcmNoUGFyYW1zOiB7IFwiY2FjaGVLZXlcIjogXCJoZWxsb19oZWxsbzpoZWxsb1wiIH1cbiAgICAgKiB9KTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9ncmFtTWFuYWdlci5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgKi9cbiAgICBhc3luYyBidWlsZEV4ZWN1dGlvblRyYW5zYWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRGVzdHJ1Y3R1cmUgdGhlIG9wdGlvbnMgb2JqZWN0IHRvIGFjY2VzcyB0aGUgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB7IHByb2dyYW1OYW1lLCBmdW5jdGlvbk5hbWUsIGZlZSwgcHJpdmF0ZUZlZSwgaW5wdXRzLCByZWNvcmRTZWFyY2hQYXJhbXMsIGtleVNlYXJjaFBhcmFtcywgcHJpdmF0ZUtleSwgb2ZmbGluZVF1ZXJ5IH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgZmVlUmVjb3JkID0gb3B0aW9ucy5mZWVSZWNvcmQ7XG4gICAgICAgIGxldCBwcm92aW5nS2V5ID0gb3B0aW9ucy5wcm92aW5nS2V5O1xuICAgICAgICBsZXQgdmVyaWZ5aW5nS2V5ID0gb3B0aW9ucy52ZXJpZnlpbmdLZXk7XG4gICAgICAgIGxldCBwcm9ncmFtID0gb3B0aW9ucy5wcm9ncmFtO1xuICAgICAgICBsZXQgaW1wb3J0cyA9IG9wdGlvbnMuaW1wb3J0cztcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBleGlzdHMgb24gdGhlIG5ldHdvcmtcbiAgICAgICAgaWYgKHByb2dyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtID0gKGF3YWl0IHRoaXMubmV0d29ya0NsaWVudC5nZXRQcm9ncmFtKHByb2dyYW1OYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0FuZFRocm93KGBFcnJvciBmaW5kaW5nICR7cHJvZ3JhbU5hbWV9LiBOZXR3b3JrIHJlc3BvbnNlOiAnJHtlLm1lc3NhZ2V9Jy4gUGxlYXNlIGVuc3VyZSB5b3UncmUgY29ubmVjdGVkIHRvIGEgdmFsaWQgQWxlbyBuZXR3b3JrIHRoZSBwcm9ncmFtIGlzIGRlcGxveWVkIHRvIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2dyYW0gaW5zdGFuY2VvZiBQcm9ncmFtKSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgYWNjb3VudCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgbGV0IGV4ZWN1dGlvblByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMuYWNjb3VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHRoaXMuYWNjb3VudC5wcml2YXRlS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25Qcml2YXRlS2V5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyAoXCJObyBwcml2YXRlIGtleSBwcm92aWRlZCBhbmQgbm8gcHJpdmF0ZSBrZXkgc2V0IGluIHRoZSBQcm9ncmFtTWFuYWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGZlZSByZWNvcmQgZnJvbSB0aGUgYWNjb3VudCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZlZVJlY29yZCA9IHByaXZhdGVGZWUgPyBhd2FpdCB0aGlzLmdldENyZWRpdHNSZWNvcmQoZmVlLCBbXSwgZmVlUmVjb3JkLCByZWNvcmRTZWFyY2hQYXJhbXMpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUgcmVjb3JkLiBSZWNvcmQgZmluZGVyIHJlc3BvbnNlOiAnJHtlLm1lc3NhZ2V9Jy4gUGxlYXNlIGVuc3VyZSB5b3UncmUgY29ubmVjdGVkIHRvIGEgdmFsaWQgQWxlbyBuZXR3b3JrIGFuZCBhIHJlY29yZCB3aXRoIGVub3VnaCBiYWxhbmNlIGV4aXN0cy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGZlZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmcm9tIHRoZSBrZXkgcHJvdmlkZXJcbiAgICAgICAgbGV0IGZlZUtleXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZWVLZXlzID0gcHJpdmF0ZUZlZSA/IGF3YWl0IHRoaXMua2V5UHJvdmlkZXIuZmVlUHJpdmF0ZUtleXMoKSA6IGF3YWl0IHRoaXMua2V5UHJvdmlkZXIuZmVlUHVibGljS2V5cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUga2V5cy4gS2V5IGZpbmRlciByZXNwb25zZTogJyR7ZS5tZXNzYWdlfScuIFBsZWFzZSBlbnN1cmUgeW91ciBrZXkgcHJvdmlkZXIgaXMgY29uZmlndXJlZCBjb3JyZWN0bHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2ZlZVByb3ZpbmdLZXksIGZlZVZlcmlmeWluZ0tleV0gPSBmZWVLZXlzO1xuICAgICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gcHJvdmluZyBhbmQgdmVyaWZ5aW5nIGtleXMgYXJlIG5vdCBwcm92aWRlZCwgYXR0ZW1wdCB0byBmaW5kIHRoZW0gdXNpbmcgdGhlIGtleSBwcm92aWRlclxuICAgICAgICBpZiAoIXByb3ZpbmdLZXkgfHwgIXZlcmlmeWluZ0tleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBbcHJvdmluZ0tleSwgdmVyaWZ5aW5nS2V5XSA9IGF3YWl0IHRoaXMua2V5UHJvdmlkZXIuZnVuY3Rpb25LZXlzKGtleVNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGdW5jdGlvbiBrZXlzIG5vdCBmb3VuZC4gS2V5IGZpbmRlciByZXNwb25zZTogJyR7ZX0nLiBUaGUgZnVuY3Rpb24ga2V5cyB3aWxsIGJlIHN5bnRoZXNpemVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvZ3JhbSBpbXBvcnRzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZJbXBvcnRzID0gUHJvZ3JhbS5mcm9tU3RyaW5nKHByb2dyYW0pLmdldEltcG9ydHMoKS5sZW5ndGg7XG4gICAgICAgIGlmIChudW1iZXJPZkltcG9ydHMgPiAwICYmICFpbXBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGltcG9ydHMgPSBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuZ2V0UHJvZ3JhbUltcG9ydHMocHJvZ3JhbU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBwcm9ncmFtIGltcG9ydHMuIE5ldHdvcmsgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb25uZWN0ZWQgdG8gYSB2YWxpZCBBbGVvIG5ldHdvcmsgYW5kIHRoZSBwcm9ncmFtIGlzIGRlcGxveWVkIHRvIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGFuIGV4ZWN1dGlvbiB0cmFuc2FjdGlvbiBhbmQgc3VibWl0IGl0IHRvIHRoZSBuZXR3b3JrXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9ncmFtTWFuYWdlciQxLmJ1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24oZXhlY3V0aW9uUHJpdmF0ZUtleSwgcHJvZ3JhbSwgZnVuY3Rpb25OYW1lLCBpbnB1dHMsIGZlZSwgZmVlUmVjb3JkLCB0aGlzLmhvc3QsIGltcG9ydHMsIHByb3ZpbmdLZXksIHZlcmlmeWluZ0tleSwgZmVlUHJvdmluZ0tleSwgZmVlVmVyaWZ5aW5nS2V5LCBvZmZsaW5lUXVlcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gZXhlY3V0aW9uIHRyYW5zYWN0aW9uIGZvciBzdWJtaXNzaW9uIHRvIHRoZSBBbGVvIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V4ZWN1dGVPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBleGVjdXRpb24gdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiBvciBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE5ldHdvcmtDbGllbnQsIEtleVByb3ZpZGVyLCBhbmQgUmVjb3JkUHJvdmlkZXIgdXNpbmcgb2ZmaWNpYWwgQWxlbyByZWNvcmQsIGtleSwgYW5kIG5ldHdvcmsgcHJvdmlkZXJzXG4gICAgICogY29uc3QgbmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICogY29uc3QgcmVjb3JkUHJvdmlkZXIgPSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyKGFjY291bnQsIG5ldHdvcmtDbGllbnQpO1xuICAgICAqXG4gICAgICogLy8gSW5pdGlhbGl6ZSBhIHByb2dyYW0gbWFuYWdlciB3aXRoIHRoZSBrZXkgcHJvdmlkZXIgdG8gYXV0b21hdGljYWxseSBmZXRjaCBrZXlzIGZvciBleGVjdXRpb25zXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKlxuICAgICAqIC8vIEJ1aWxkIGFuZCBleGVjdXRlIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuZXhlY3V0ZSh7XG4gICAgICogICBwcm9ncmFtTmFtZTogXCJoZWxsb19oZWxsby5hbGVvXCIsXG4gICAgICogICBmdW5jdGlvbk5hbWU6IFwiaGVsbG9faGVsbG9cIixcbiAgICAgKiAgIGZlZTogMC4wMjAsXG4gICAgICogICBwcml2YXRlRmVlOiBmYWxzZSxcbiAgICAgKiAgIGlucHV0czogW1wiNXUzMlwiLCBcIjV1MzJcIl0sXG4gICAgICogICBrZXlTZWFyY2hQYXJhbXM6IHsgXCJjYWNoZUtleVwiOiBcImhlbGxvX2hlbGxvOmhlbGxvXCIgfVxuICAgICAqIH0pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2dyYW1NYW5hZ2VyLm5ldHdvcmtDbGllbnQuc3VibWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuYnVpbGRFeGVjdXRpb25UcmFuc2FjdGlvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubmV0d29ya0NsaWVudC5zdWJtaXRUcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBhbiBBbGVvIHByb2dyYW0gaW4gb2ZmbGluZSBtb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbSBQcm9ncmFtIHNvdXJjZSBjb2RlIGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uX25hbWUgRnVuY3Rpb24gbmFtZSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRzIElucHV0cyB0byB0aGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvdmVFeGVjdXRpb24gV2hldGhlciB0byBwcm92ZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBmdW5jdGlvbiBhbmQgcmV0dXJuIGFuIGV4ZWN1dGlvbiB0cmFuc2NyaXB0XG4gICAgICogdGhhdCBjb250YWlucyB0aGUgcHJvb2YuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHVuZGVmaW5lZH0gaW1wb3J0cyBPcHRpb25hbCBpbXBvcnRzIHRvIHRoZSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtLZXlTZWFyY2hQYXJhbXMgfCB1bmRlZmluZWR9IGtleVNlYXJjaFBhcmFtcyBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaW5kaW5nIHRoZSBtYXRjaGluZyBwcm92aW5nICZcbiAgICAgKiB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtQcm92aW5nS2V5IHwgdW5kZWZpbmVkfSBwcm92aW5nS2V5IE9wdGlvbmFsIHByb3Zpbmcga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtWZXJpZnlpbmdLZXkgfCB1bmRlZmluZWR9IHZlcmlmeWluZ0tleSBPcHRpb25hbCB2ZXJpZnlpbmcga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5IHwgdW5kZWZpbmVkfSBwcml2YXRlS2V5IE9wdGlvbmFsIHByaXZhdGUga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtPZmZsaW5lUXVlcnkgfCB1bmRlZmluZWR9IG9mZmxpbmVRdWVyeSBPcHRpb25hbCBvZmZsaW5lIHF1ZXJ5IGlmIGNyZWF0aW5nIHRyYW5zYWN0aW9ucyBpbiBhbiBvZmZsaW5lIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgQWNjb3VudCwgUHJvZ3JhbSB9IGZyb20gJ0Bwcm92YWJsZWhxL3Nkayc7XG4gICAgICpcbiAgICAgKiAvLy8gQ3JlYXRlIHRoZSBzb3VyY2UgZm9yIHRoZSBcImhlbGxvd29ybGRcIiBwcm9ncmFtXG4gICAgICogY29uc3QgcHJvZ3JhbSA9IFwicHJvZ3JhbSBoZWxsb3dvcmxkLmFsZW87XFxuXFxuZnVuY3Rpb24gaGVsbG86XFxuICAgIGlucHV0IHIwIGFzIHUzMi5wdWJsaWM7XFxuICAgIGlucHV0IHIxIGFzIHUzMi5wcml2YXRlO1xcbiAgICBhZGQgcjAgcjEgaW50byByMjtcXG4gICAgb3V0cHV0IHIyIGFzIHUzMi5wcml2YXRlO1xcblwiO1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKCk7XG4gICAgICpcbiAgICAgKiAvLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGFjY291bnQgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIHByb2dyYW1cbiAgICAgKiBjb25zdCBhY2NvdW50ID0gbmV3IEFjY291bnQoKTtcbiAgICAgKiBwcm9ncmFtTWFuYWdlci5zZXRBY2NvdW50KGFjY291bnQpO1xuICAgICAqXG4gICAgICogLy8vIEdldCB0aGUgcmVzcG9uc2UgYW5kIGVuc3VyZSB0aGF0IHRoZSBwcm9ncmFtIGV4ZWN1dGVkIGNvcnJlY3RseVxuICAgICAqIGNvbnN0IGV4ZWN1dGlvblJlc3BvbnNlID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIucnVuKHByb2dyYW0sIFwiaGVsbG9cIiwgW1wiNXUzMlwiLCBcIjV1MzJcIl0pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGlvblJlc3BvbnNlLmdldE91dHB1dHMoKTtcbiAgICAgKiBhc3NlcnQocmVzdWx0ID09PSBbXCIxMHUzMlwiXSk7XG4gICAgICovXG4gICAgYXN5bmMgcnVuKHByb2dyYW0sIGZ1bmN0aW9uX25hbWUsIGlucHV0cywgcHJvdmVFeGVjdXRpb24sIGltcG9ydHMsIGtleVNlYXJjaFBhcmFtcywgcHJvdmluZ0tleSwgdmVyaWZ5aW5nS2V5LCBwcml2YXRlS2V5LCBvZmZsaW5lUXVlcnkpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwcml2YXRlIGtleSBmcm9tIHRoZSBhY2NvdW50IGlmIGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgcGFyYW1ldGVyc1xuICAgICAgICBsZXQgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpdmF0ZUtleSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdGhpcy5hY2NvdW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcml2YXRlS2V5ID0gdGhpcy5hY2NvdW50LnByaXZhdGVLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvblByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IChcIk5vIHByaXZhdGUga2V5IHByb3ZpZGVkIGFuZCBubyBwcml2YXRlIGtleSBzZXQgaW4gdGhlIFByb2dyYW1NYW5hZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBhcmUgbm90IHByb3ZpZGVkLCBhdHRlbXB0IHRvIGZpbmQgdGhlbSB1c2luZyB0aGUga2V5IHByb3ZpZGVyXG4gICAgICAgIGlmICghcHJvdmluZ0tleSB8fCAhdmVyaWZ5aW5nS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFtwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXldID0gYXdhaXQgdGhpcy5rZXlQcm92aWRlci5mdW5jdGlvbktleXMoa2V5U2VhcmNoUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZ1bmN0aW9uIGtleXMgbm90IGZvdW5kLiBLZXkgZmluZGVyIHJlc3BvbnNlOiAnJHtlfScuIFRoZSBmdW5jdGlvbiBrZXlzIHdpbGwgYmUgc3ludGhlc2l6ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gdGhlIHByb2dyYW0gb2ZmbGluZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW5uaW5nIHByb2dyYW0gb2ZmbGluZVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJQcm92aW5nIGtleTogXCIsIHByb3ZpbmdLZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZlcmlmeWluZyBrZXk6IFwiLCB2ZXJpZnlpbmdLZXkpO1xuICAgICAgICByZXR1cm4gUHJvZ3JhbU1hbmFnZXIkMS5leGVjdXRlRnVuY3Rpb25PZmZsaW5lKGV4ZWN1dGlvblByaXZhdGVLZXksIHByb2dyYW0sIGZ1bmN0aW9uX25hbWUsIGlucHV0cywgcHJvdmVFeGVjdXRpb24sIGZhbHNlLCBpbXBvcnRzLCBwcm92aW5nS2V5LCB2ZXJpZnlpbmdLZXksIHRoaXMuaG9zdCwgb2ZmbGluZVF1ZXJ5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0d28gY3JlZGl0cyByZWNvcmRzIGludG8gYSBzaW5nbGUgY3JlZGl0cyByZWNvcmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgc3RyaW5nfSByZWNvcmRPbmUgRmlyc3QgY3JlZGl0cyByZWNvcmQgdG8gam9pblxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgc3RyaW5nfSByZWNvcmRUd28gU2Vjb25kIGNyZWRpdHMgcmVjb3JkIHRvIGpvaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlIEZlZSBpbiBjcmVkaXRzIHBheSBmb3IgdGhlIGpvaW4gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByaXZhdGVGZWUgVXNlIGEgcHJpdmF0ZSByZWNvcmQgdG8gcGF5IHRoZSBmZWUuIElmIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGFjY291bnQncyBwdWJsaWMgY3JlZGl0IGJhbGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29yZFNlYXJjaFBhcmFtcyB8IHVuZGVmaW5lZH0gcmVjb3JkU2VhcmNoUGFyYW1zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGZpbmRpbmcgdGhlIGZlZSByZWNvcmQgdG8gdXNlXG4gICAgICogdG8gcGF5IHRoZSBmZWUgZm9yIHRoZSBqb2luIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBzdHJpbmcgfCB1bmRlZmluZWR9IGZlZVJlY29yZCBGZWUgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIGpvaW4gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXkgfCB1bmRlZmluZWR9IHByaXZhdGVLZXkgUHJpdmF0ZSBrZXkgdG8gdXNlIGZvciB0aGUgam9pbiB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgdW5kZWZpbmVkfSBvZmZsaW5lUXVlcnkgT3B0aW9uYWwgb2ZmbGluZSBxdWVyeSBpZiBjcmVhdGluZyB0cmFuc2FjdGlvbnMgaW4gYW4gb2ZmbGluZSBlbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgYXN5bmMgam9pbihyZWNvcmRPbmUsIHJlY29yZFR3bywgZmVlLCBwcml2YXRlRmVlLCByZWNvcmRTZWFyY2hQYXJhbXMsIGZlZVJlY29yZCwgcHJpdmF0ZUtleSwgb2ZmbGluZVF1ZXJ5KSB7XG4gICAgICAgIC8vIEdldCB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgYWNjb3VudCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgbGV0IGV4ZWN1dGlvblByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMuYWNjb3VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHRoaXMuYWNjb3VudC5wcml2YXRlS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25Qcml2YXRlS2V5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyAoXCJObyBwcml2YXRlIGtleSBwcm92aWRlZCBhbmQgbm8gcHJpdmF0ZSBrZXkgc2V0IGluIHRoZSBQcm9ncmFtTWFuYWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZyb20gdGhlIGtleSBwcm92aWRlclxuICAgICAgICBsZXQgZmVlS2V5cztcbiAgICAgICAgbGV0IGpvaW5LZXlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmVlS2V5cyA9IHByaXZhdGVGZWUgPyBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLmZlZVByaXZhdGVLZXlzKCkgOiBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLmZlZVB1YmxpY0tleXMoKTtcbiAgICAgICAgICAgIGpvaW5LZXlzID0gYXdhaXQgdGhpcy5rZXlQcm92aWRlci5qb2luS2V5cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUga2V5cy4gS2V5IGZpbmRlciByZXNwb25zZTogJyR7ZS5tZXNzYWdlfScuIFBsZWFzZSBlbnN1cmUgeW91ciBrZXkgcHJvdmlkZXIgaXMgY29uZmlndXJlZCBjb3JyZWN0bHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2ZlZVByb3ZpbmdLZXksIGZlZVZlcmlmeWluZ0tleV0gPSBmZWVLZXlzO1xuICAgICAgICBjb25zdCBbam9pblByb3ZpbmdLZXksIGpvaW5WZXJpZnlpbmdLZXldID0gam9pbktleXM7XG4gICAgICAgIC8vIEdldCB0aGUgZmVlIHJlY29yZCBmcm9tIHRoZSBhY2NvdW50IGlmIGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgcGFyYW1ldGVyc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmVlUmVjb3JkID0gcHJpdmF0ZUZlZSA/IGF3YWl0IHRoaXMuZ2V0Q3JlZGl0c1JlY29yZChmZWUsIFtdLCBmZWVSZWNvcmQsIHJlY29yZFNlYXJjaFBhcmFtcykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0FuZFRocm93KGBFcnJvciBmaW5kaW5nIGZlZSByZWNvcmQuIFJlY29yZCBmaW5kZXIgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb25uZWN0ZWQgdG8gYSB2YWxpZCBBbGVvIG5ldHdvcmsgYW5kIGEgcmVjb3JkIHdpdGggZW5vdWdoIGJhbGFuY2UgZXhpc3RzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSByZWNvcmRzIHByb3ZpZGVkIGFyZSB2YWxpZCBwbGFpbnRleHQgcmVjb3Jkc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVjb3JkT25lID0gcmVjb3JkT25lIGluc3RhbmNlb2YgUmVjb3JkUGxhaW50ZXh0ID8gcmVjb3JkT25lIDogUmVjb3JkUGxhaW50ZXh0LmZyb21TdHJpbmcocmVjb3JkT25lKTtcbiAgICAgICAgICAgIHJlY29yZFR3byA9IHJlY29yZFR3byBpbnN0YW5jZW9mIFJlY29yZFBsYWludGV4dCA/IHJlY29yZFR3byA6IFJlY29yZFBsYWludGV4dC5mcm9tU3RyaW5nKHJlY29yZFR3byk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0FuZFRocm93KCdSZWNvcmRzIHByb3ZpZGVkIGFyZSBub3QgdmFsaWQuIFBsZWFzZSBlbnN1cmUgdGhleSBhcmUgdmFsaWQgcGxhaW50ZXh0IHJlY29yZHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgYW4gZXhlY3V0aW9uIHRyYW5zYWN0aW9uIGFuZCBzdWJtaXQgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBQcm9ncmFtTWFuYWdlciQxLmJ1aWxkSm9pblRyYW5zYWN0aW9uKGV4ZWN1dGlvblByaXZhdGVLZXksIHJlY29yZE9uZSwgcmVjb3JkVHdvLCBmZWUsIGZlZVJlY29yZCwgdGhpcy5ob3N0LCBqb2luUHJvdmluZ0tleSwgam9pblZlcmlmeWluZ0tleSwgZmVlUHJvdmluZ0tleSwgZmVlVmVyaWZ5aW5nS2V5LCBvZmZsaW5lUXVlcnkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXQgY3JlZGl0cyBpbnRvIHR3byBuZXcgY3JlZGl0cyByZWNvcmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BsaXRBbW91bnQgQW1vdW50IGluIG1pY3JvY3JlZGl0cyB0byBzcGxpdCBmcm9tIHRoZSBvcmlnaW5hbCBjcmVkaXRzIHJlY29yZFxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgc3RyaW5nfSBhbW91bnRSZWNvcmQgQW1vdW50IHJlY29yZCB0byB1c2UgZm9yIHRoZSBzcGxpdCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleSB8IHVuZGVmaW5lZH0gcHJpdmF0ZUtleSBPcHRpb25hbCBwcml2YXRlIGtleSB0byB1c2UgZm9yIHRoZSBzcGxpdCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgdW5kZWZpbmVkfSBvZmZsaW5lUXVlcnkgT3B0aW9uYWwgb2ZmbGluZSBxdWVyeSBpZiBjcmVhdGluZyB0cmFuc2FjdGlvbnMgaW4gYW4gb2ZmbGluZSBlbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBOZXR3b3JrQ2xpZW50LCBLZXlQcm92aWRlciwgYW5kIFJlY29yZFByb3ZpZGVyXG4gICAgICogY29uc3QgbmV0d29ya0NsaWVudCA9IG5ldyBBbGVvTmV0d29ya0NsaWVudChcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiKTtcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBjb25zdCByZWNvcmRQcm92aWRlciA9IG5ldyBOZXR3b3JrUmVjb3JkUHJvdmlkZXIoYWNjb3VudCwgbmV0d29ya0NsaWVudCk7XG4gICAgICpcbiAgICAgKiAvLyBJbml0aWFsaXplIGEgcHJvZ3JhbSBtYW5hZ2VyIHdpdGggdGhlIGtleSBwcm92aWRlciB0byBhdXRvbWF0aWNhbGx5IGZldGNoIGtleXMgZm9yIGV4ZWN1dGlvbnNcbiAgICAgKiBjb25zdCBwcm9ncmFtTmFtZSA9IFwiaGVsbG9faGVsbG8uYWxlb1wiO1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCByZWNvcmRQcm92aWRlcik7XG4gICAgICogY29uc3QgcmVjb3JkID0gXCJ7ICBvd25lcjogYWxlbzE4NHZ1d3I1dTd1MGhhNWY1azQ0MDY3ZGQydWFxZXd4eDZwZTVsdGhhNXB2OTl3dmhmcXhxdjMzOWg0LnByaXZhdGUsICBtaWNyb2NyZWRpdHM6IDQ1MDAwMDAwdTY0LnByaXZhdGUsICBfbm9uY2U6IDQxMDYyMDU3NjI4NjIzMDUzMDg0OTU3MDg5NzE5ODU3NDg1OTIzODAwNjQyMDEyMzAzOTY1NTkzMDc1NTYzODg3MjU5MzYzMDQ5ODRncm91cC5wdWJsaWN9XCJcbiAgICAgKiBjb25zdCB0eF9pZCA9IGF3YWl0IHByb2dyYW1NYW5hZ2VyLnNwbGl0KDI1MDAwMDAwLCByZWNvcmQpO1xuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5nZXRUcmFuc2FjdGlvbih0eF9pZCk7XG4gICAgICovXG4gICAgYXN5bmMgc3BsaXQoc3BsaXRBbW91bnQsIGFtb3VudFJlY29yZCwgcHJpdmF0ZUtleSwgb2ZmbGluZVF1ZXJ5KSB7XG4gICAgICAgIC8vIEdldCB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgYWNjb3VudCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgbGV0IGV4ZWN1dGlvblByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvblByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMuYWNjb3VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHRoaXMuYWNjb3VudC5wcml2YXRlS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25Qcml2YXRlS2V5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyAoXCJObyBwcml2YXRlIGtleSBwcm92aWRlZCBhbmQgbm8gcHJpdmF0ZSBrZXkgc2V0IGluIHRoZSBQcm9ncmFtTWFuYWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNwbGl0IGtleXMgZnJvbSB0aGUga2V5IHByb3ZpZGVyXG4gICAgICAgIGxldCBzcGxpdEtleXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGxpdEtleXMgPSBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLnNwbGl0S2V5cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUga2V5cy4gS2V5IGZpbmRlciByZXNwb25zZTogJyR7ZS5tZXNzYWdlfScuIFBsZWFzZSBlbnN1cmUgeW91ciBrZXkgcHJvdmlkZXIgaXMgY29uZmlndXJlZCBjb3JyZWN0bHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3NwbGl0UHJvdmluZ0tleSwgc3BsaXRWZXJpZnlpbmdLZXldID0gc3BsaXRLZXlzO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcmVjb3JkIHRvIGJlIHNwbGl0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhbW91bnRSZWNvcmQgPSBhbW91bnRSZWNvcmQgaW5zdGFuY2VvZiBSZWNvcmRQbGFpbnRleHQgPyBhbW91bnRSZWNvcmQgOiBSZWNvcmRQbGFpbnRleHQuZnJvbVN0cmluZyhhbW91bnRSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhcIlJlY29yZCBwcm92aWRlZCBpcyBub3QgdmFsaWQuIFBsZWFzZSBlbnN1cmUgaXQgaXMgYSB2YWxpZCBwbGFpbnRleHQgcmVjb3JkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCBhbiBleGVjdXRpb24gdHJhbnNhY3Rpb24gYW5kIHN1Ym1pdCBpdCB0byB0aGUgbmV0d29ya1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IFByb2dyYW1NYW5hZ2VyJDEuYnVpbGRTcGxpdFRyYW5zYWN0aW9uKGV4ZWN1dGlvblByaXZhdGVLZXksIHNwbGl0QW1vdW50LCBhbW91bnRSZWNvcmQsIHRoaXMuaG9zdCwgc3BsaXRQcm92aW5nS2V5LCBzcGxpdFZlcmlmeWluZ0tleSwgb2ZmbGluZVF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubmV0d29ya0NsaWVudC5zdWJtaXRUcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZS1zeW50aGVzaXplIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZvciBhIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9ncmFtIHtzdHJpbmd9IFRoZSBwcm9ncmFtIHNvdXJjZSBjb2RlIHRvIHN5bnRoZXNpemUga2V5cyBmb3JcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25faWQge3N0cmluZ30gVGhlIGZ1bmN0aW9uIGlkIHRvIHN5bnRoZXNpemUga2V5cyBmb3JcbiAgICAgKiBAcGFyYW0gaW5wdXRzIHtBcnJheTxzdHJpbmc+fSAgU2FtcGxlIGlucHV0cyB0byB0aGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSB7UHJpdmF0ZUtleSB8IHVuZGVmaW5lZH0gT3B0aW9uYWwgcHJpdmF0ZSBrZXkgdG8gdXNlIGZvciB0aGUga2V5IHN5bnRoZXNpc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb25LZXlQYWlyPn1cbiAgICAgKi9cbiAgICBhc3luYyBzeW50aGVzaXplS2V5cyhwcm9ncmFtLCBmdW5jdGlvbl9pZCwgaW5wdXRzLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHByb2dyYW0gaW1wb3J0cyBpZiB0aGV5IGV4aXN0XG4gICAgICAgIGxldCBpbXBvcnRzO1xuICAgICAgICBsZXQgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0aW9uUHJpdmF0ZUtleSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFjY291bnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Qcml2YXRlS2V5ID0gdGhpcy5hY2NvdW50LnByaXZhdGVLZXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblByaXZhdGVLZXkgPSBuZXcgUHJpdmF0ZUtleSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcnVuIGFuIG9mZmxpbmUgZXhlY3V0aW9uIG9mIHRoZSBwcm9ncmFtIGFuZCBleHRyYWN0IHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW1wb3J0cyA9IGF3YWl0IHRoaXMubmV0d29ya0NsaWVudC5nZXRQcm9ncmFtSW1wb3J0cyhwcm9ncmFtKTtcbiAgICAgICAgICAgIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBQcm9ncmFtTWFuYWdlciQxLnN5bnRoZXNpemVLZXlQYWlyKGV4ZWN1dGlvblByaXZhdGVLZXksIHByb2dyYW0sIGZ1bmN0aW9uX2lkLCBpbnB1dHMsIGltcG9ydHMpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlQYWlyLnByb3ZpbmdLZXkoKSwga2V5UGFpci52ZXJpZnlpbmdLZXkoKV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0FuZFRocm93KGBDb3VsZCBub3Qgc3ludGhlc2l6ZSBrZXlzIC0gZXJyb3IgJHtlLm1lc3NhZ2V9LiBQbGVhc2UgZW5zdXJlIHRoZSBwcm9ncmFtIGlzIHZhbGlkIGFuZCB0aGUgaW5wdXRzIGFyZSBjb3JyZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgdHJhbnNhY3Rpb24gdG8gdHJhbnNmZXIgY3JlZGl0cyB0byBhbm90aGVyIGFjY291bnQgZm9yIGxhdGVyIHN1Ym1pc3Npb24gdG8gdGhlIEFsZW8gbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjaXBpZW50IFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVyVHlwZSBUaGUgdHlwZSBvZiB0cmFuc2ZlciB0byBwZXJmb3JtIC0gb3B0aW9uczogJ3ByaXZhdGUnLCAncHJpdmF0ZVRvUHVibGljJywgJ3B1YmxpYycsICdwdWJsaWNUb1ByaXZhdGUnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZlZSBUaGUgZmVlIHRvIHBheSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcml2YXRlRmVlIFVzZSBhIHByaXZhdGUgcmVjb3JkIHRvIHBheSB0aGUgZmVlLiBJZiBmYWxzZSB0aGlzIHdpbGwgdXNlIHRoZSBhY2NvdW50J3MgcHVibGljIGNyZWRpdCBiYWxhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvcmRTZWFyY2hQYXJhbXMgfCB1bmRlZmluZWR9IHJlY29yZFNlYXJjaFBhcmFtcyBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBmaW5kaW5nIHRoZSBhbW91bnQgYW5kIGZlZVxuICAgICAqIHJlY29yZHMgZm9yIHRoZSB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgc3RyaW5nfSBhbW91bnRSZWNvcmQgT3B0aW9uYWwgYW1vdW50IHJlY29yZCB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7UmVjb3JkUGxhaW50ZXh0IHwgc3RyaW5nfSBmZWVSZWNvcmQgT3B0aW9uYWwgZmVlIHJlY29yZCB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7UHJpdmF0ZUtleSB8IHVuZGVmaW5lZH0gcHJpdmF0ZUtleSBPcHRpb25hbCBwcml2YXRlIGtleSB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7T2ZmbGluZVF1ZXJ5IHwgdW5kZWZpbmVkfSBvZmZsaW5lUXVlcnkgT3B0aW9uYWwgb2ZmbGluZSBxdWVyeSBpZiBjcmVhdGluZyB0cmFuc2FjdGlvbnMgaW4gYW4gb2ZmbGluZSBlbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSB0cmFuc2FjdGlvbiBpZCBvZiB0aGUgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE5ldHdvcmtDbGllbnQsIEtleVByb3ZpZGVyLCBhbmQgUmVjb3JkUHJvdmlkZXJcbiAgICAgKiBjb25zdCBuZXR3b3JrQ2xpZW50ID0gbmV3IEFsZW9OZXR3b3JrQ2xpZW50KFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIpO1xuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGNvbnN0IHJlY29yZFByb3ZpZGVyID0gbmV3IE5ldHdvcmtSZWNvcmRQcm92aWRlcihhY2NvdW50LCBuZXR3b3JrQ2xpZW50KTtcbiAgICAgKlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBwcm9ncmFtIG1hbmFnZXIgd2l0aCB0aGUga2V5IHByb3ZpZGVyIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2gga2V5cyBmb3IgZXhlY3V0aW9uc1xuICAgICAqIGNvbnN0IHByb2dyYW1OYW1lID0gXCJoZWxsb19oZWxsby5hbGVvXCI7XG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKiBhd2FpdCBwcm9ncmFtTWFuYWdlci5pbml0aWFsaXplKCk7XG4gICAgICogY29uc3QgdHhfaWQgPSBhd2FpdCBwcm9ncmFtTWFuYWdlci50cmFuc2ZlcigxLCBcImFsZW8xcmhnZHU3N2hneXFkM3hqajh1Y3Uzamo5cjJrcnd6Nm1uenlkODBnbmNyNWZ4Y3dsaDVyc3Z6cDlweFwiLCBcInByaXZhdGVcIiwgMC4yKVxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5nZXRUcmFuc2FjdGlvbih0eF9pZCk7XG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRUcmFuc2ZlclRyYW5zYWN0aW9uKGFtb3VudCwgcmVjaXBpZW50LCB0cmFuc2ZlclR5cGUsIGZlZSwgcHJpdmF0ZUZlZSwgcmVjb3JkU2VhcmNoUGFyYW1zLCBhbW91bnRSZWNvcmQsIGZlZVJlY29yZCwgcHJpdmF0ZUtleSwgb2ZmbGluZVF1ZXJ5KSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSB0cmFuc2ZlciB0eXBlXG4gICAgICAgIHRyYW5zZmVyVHlwZSA9IHZhbGlkYXRlVHJhbnNmZXJUeXBlKHRyYW5zZmVyVHlwZSk7XG4gICAgICAgIC8vIEdldCB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUgYWNjb3VudCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgbGV0IGV4ZWN1dGlvblByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvblByaXZhdGVLZXkgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRoaXMuYWNjb3VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZXhlY3V0aW9uUHJpdmF0ZUtleSA9IHRoaXMuYWNjb3VudC5wcml2YXRlS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRpb25Qcml2YXRlS2V5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyAoXCJObyBwcml2YXRlIGtleSBwcm92aWRlZCBhbmQgbm8gcHJpdmF0ZSBrZXkgc2V0IGluIHRoZSBQcm9ncmFtTWFuYWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHByb3ZpbmcgYW5kIHZlcmlmeWluZyBrZXlzIGZyb20gdGhlIGtleSBwcm92aWRlclxuICAgICAgICBsZXQgZmVlS2V5cztcbiAgICAgICAgbGV0IHRyYW5zZmVyS2V5cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZlZUtleXMgPSBwcml2YXRlRmVlID8gYXdhaXQgdGhpcy5rZXlQcm92aWRlci5mZWVQcml2YXRlS2V5cygpIDogYXdhaXQgdGhpcy5rZXlQcm92aWRlci5mZWVQdWJsaWNLZXlzKCk7XG4gICAgICAgICAgICB0cmFuc2ZlcktleXMgPSBhd2FpdCB0aGlzLmtleVByb3ZpZGVyLnRyYW5zZmVyS2V5cyh0cmFuc2ZlclR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUga2V5cy4gS2V5IGZpbmRlciByZXNwb25zZTogJyR7ZS5tZXNzYWdlfScuIFBsZWFzZSBlbnN1cmUgeW91ciBrZXkgcHJvdmlkZXIgaXMgY29uZmlndXJlZCBjb3JyZWN0bHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2ZlZVByb3ZpbmdLZXksIGZlZVZlcmlmeWluZ0tleV0gPSBmZWVLZXlzO1xuICAgICAgICBjb25zdCBbdHJhbnNmZXJQcm92aW5nS2V5LCB0cmFuc2ZlclZlcmlmeWluZ0tleV0gPSB0cmFuc2ZlcktleXM7XG4gICAgICAgIC8vIEdldCB0aGUgYW1vdW50IGFuZCBmZWUgcmVjb3JkIGZyb20gdGhlIGFjY291bnQgaWYgaXQgaXMgbm90IHByb3ZpZGVkIGluIHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcmFjayB0aGUgbm9uY2VzIG9mIHRoZSByZWNvcmRzIGZvdW5kIHNvIG5vIGR1cGxpY2F0ZSByZWNvcmRzIGFyZSB1c2VkXG4gICAgICAgICAgICBjb25zdCBub25jZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlc0Ftb3VudFJlY29yZCh0cmFuc2ZlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zZmVyIHR5cGUgaXMgcHJpdmF0ZSBhbmQgcmVxdWlyZXMgYW4gYW1vdW50IHJlY29yZCwgZ2V0IGl0IGZyb20gdGhlIHJlY29yZCBwcm92aWRlclxuICAgICAgICAgICAgICAgIGFtb3VudFJlY29yZCA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGl0c1JlY29yZChmZWUsIFtdLCBhbW91bnRSZWNvcmQsIHJlY29yZFNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgbm9uY2VzLnB1c2goYW1vdW50UmVjb3JkLm5vbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYW1vdW50UmVjb3JkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVlUmVjb3JkID0gcHJpdmF0ZUZlZSA/IGF3YWl0IHRoaXMuZ2V0Q3JlZGl0c1JlY29yZChmZWUsIG5vbmNlcywgZmVlUmVjb3JkLCByZWNvcmRTZWFyY2hQYXJhbXMpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dBbmRUaHJvdyhgRXJyb3IgZmluZGluZyBmZWUgcmVjb3JkLiBSZWNvcmQgZmluZGVyIHJlc3BvbnNlOiAnJHtlLm1lc3NhZ2V9Jy4gUGxlYXNlIGVuc3VyZSB5b3UncmUgY29ubmVjdGVkIHRvIGEgdmFsaWQgQWxlbyBuZXR3b3JrIGFuZCBhIHJlY29yZCB3aXRoIGVub3VnaCBiYWxhbmNlIGV4aXN0cy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCBhbiBleGVjdXRpb24gdHJhbnNhY3Rpb24gYW5kIHN1Ym1pdCBpdCB0byB0aGUgbmV0d29ya1xuICAgICAgICByZXR1cm4gYXdhaXQgUHJvZ3JhbU1hbmFnZXIkMS5idWlsZFRyYW5zZmVyVHJhbnNhY3Rpb24oZXhlY3V0aW9uUHJpdmF0ZUtleSwgYW1vdW50LCByZWNpcGllbnQsIHRyYW5zZmVyVHlwZSwgYW1vdW50UmVjb3JkLCBmZWUsIGZlZVJlY29yZCwgdGhpcy5ob3N0LCB0cmFuc2ZlclByb3ZpbmdLZXksIHRyYW5zZmVyVmVyaWZ5aW5nS2V5LCBmZWVQcm92aW5nS2V5LCBmZWVWZXJpZnlpbmdLZXksIG9mZmxpbmVRdWVyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgdHJhbnNmZXJfcHVibGljIHRyYW5zYWN0aW9uIHRvIHRyYW5zZmVyIGNyZWRpdHMgdG8gYW5vdGhlciBhY2NvdW50IGZvciBsYXRlciBzdWJtaXNzaW9uIHRvIHRoZSBBbGVvIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiBjcmVkaXRzIHRvIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlY2lwaWVudCBUaGUgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlclR5cGUgVGhlIHR5cGUgb2YgdHJhbnNmZXIgdG8gcGVyZm9ybSAtIG9wdGlvbnM6ICdwcml2YXRlJywgJ3ByaXZhdGVUb1B1YmxpYycsICdwdWJsaWMnLCAncHVibGljVG9Qcml2YXRlJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmZWUgVGhlIGZlZSB0byBwYXkgZm9yIHRoZSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJpdmF0ZUZlZSBVc2UgYSBwcml2YXRlIHJlY29yZCB0byBwYXkgdGhlIGZlZS4gSWYgZmFsc2UgdGhpcyB3aWxsIHVzZSB0aGUgYWNjb3VudCdzIHB1YmxpYyBjcmVkaXQgYmFsYW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb3JkU2VhcmNoUGFyYW1zIHwgdW5kZWZpbmVkfSByZWNvcmRTZWFyY2hQYXJhbXMgT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgZmluZGluZyB0aGUgYW1vdW50IGFuZCBmZWVcbiAgICAgKiByZWNvcmRzIGZvciB0aGUgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dCB8IHN0cmluZ30gYW1vdW50UmVjb3JkIE9wdGlvbmFsIGFtb3VudCByZWNvcmQgdG8gdXNlIGZvciB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge1JlY29yZFBsYWludGV4dCB8IHN0cmluZ30gZmVlUmVjb3JkIE9wdGlvbmFsIGZlZSByZWNvcmQgdG8gdXNlIGZvciB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge1ByaXZhdGVLZXkgfCB1bmRlZmluZWR9IHByaXZhdGVLZXkgT3B0aW9uYWwgcHJpdmF0ZSBrZXkgdG8gdXNlIGZvciB0aGUgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge09mZmxpbmVRdWVyeSB8IHVuZGVmaW5lZH0gb2ZmbGluZVF1ZXJ5IE9wdGlvbmFsIG9mZmxpbmUgcXVlcnkgaWYgY3JlYXRpbmcgdHJhbnNhY3Rpb25zIGluIGFuIG9mZmxpbmUgZW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgdHJhbnNhY3Rpb24gaWQgb2YgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRUcmFuc2ZlclB1YmxpY1RyYW5zYWN0aW9uKGFtb3VudCwgcmVjaXBpZW50LCBmZWUsIHByaXZhdGVLZXksIG9mZmxpbmVRdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRyYW5zZmVyVHJhbnNhY3Rpb24oYW1vdW50LCByZWNpcGllbnQsIFwicHVibGljXCIsIGZlZSwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByaXZhdGVLZXksIG9mZmxpbmVRdWVyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgdHJhbnNmZXJfcHVibGljX2FzX3NpZ25lciB0cmFuc2FjdGlvbiB0byB0cmFuc2ZlciBjcmVkaXRzIHRvIGFub3RoZXIgYWNjb3VudCBmb3IgbGF0ZXIgc3VibWlzc2lvbiB0byB0aGUgQWxlbyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgY3JlZGl0cyB0byB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNpcGllbnQgVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJUeXBlIFRoZSB0eXBlIG9mIHRyYW5zZmVyIHRvIHBlcmZvcm0gLSBvcHRpb25zOiAncHJpdmF0ZScsICdwcml2YXRlVG9QdWJsaWMnLCAncHVibGljJywgJ3B1YmxpY1RvUHJpdmF0ZSdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlIFRoZSBmZWUgdG8gcGF5IGZvciB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByaXZhdGVGZWUgVXNlIGEgcHJpdmF0ZSByZWNvcmQgdG8gcGF5IHRoZSBmZWUuIElmIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGFjY291bnQncyBwdWJsaWMgY3JlZGl0IGJhbGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29yZFNlYXJjaFBhcmFtcyB8IHVuZGVmaW5lZH0gcmVjb3JkU2VhcmNoUGFyYW1zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGZpbmRpbmcgdGhlIGFtb3VudCBhbmQgZmVlXG4gICAgICogcmVjb3JkcyBmb3IgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBzdHJpbmd9IGFtb3VudFJlY29yZCBPcHRpb25hbCBhbW91bnQgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBzdHJpbmd9IGZlZVJlY29yZCBPcHRpb25hbCBmZWUgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5IHwgdW5kZWZpbmVkfSBwcml2YXRlS2V5IE9wdGlvbmFsIHByaXZhdGUga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtPZmZsaW5lUXVlcnkgfCB1bmRlZmluZWR9IG9mZmxpbmVRdWVyeSBPcHRpb25hbCBvZmZsaW5lIHF1ZXJ5IGlmIGNyZWF0aW5nIHRyYW5zYWN0aW9ucyBpbiBhbiBvZmZsaW5lIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHRyYW5zYWN0aW9uIGlkIG9mIHRoZSB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkVHJhbnNmZXJQdWJsaWNBc1NpZ25lclRyYW5zYWN0aW9uKGFtb3VudCwgcmVjaXBpZW50LCBmZWUsIHByaXZhdGVLZXksIG9mZmxpbmVRdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRyYW5zZmVyVHJhbnNhY3Rpb24oYW1vdW50LCByZWNpcGllbnQsIFwicHVibGljXCIsIGZlZSwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByaXZhdGVLZXksIG9mZmxpbmVRdWVyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIGNyZWRpdHMgdG8gYW5vdGhlciBhY2NvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgY3JlZGl0cyB0byB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWNpcGllbnQgVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJUeXBlIFRoZSB0eXBlIG9mIHRyYW5zZmVyIHRvIHBlcmZvcm0gLSBvcHRpb25zOiAncHJpdmF0ZScsICdwcml2YXRlVG9QdWJsaWMnLCAncHVibGljJywgJ3B1YmxpY1RvUHJpdmF0ZSdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmVlIFRoZSBmZWUgdG8gcGF5IGZvciB0aGUgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByaXZhdGVGZWUgVXNlIGEgcHJpdmF0ZSByZWNvcmQgdG8gcGF5IHRoZSBmZWUuIElmIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGFjY291bnQncyBwdWJsaWMgY3JlZGl0IGJhbGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29yZFNlYXJjaFBhcmFtcyB8IHVuZGVmaW5lZH0gcmVjb3JkU2VhcmNoUGFyYW1zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGZpbmRpbmcgdGhlIGFtb3VudCBhbmQgZmVlXG4gICAgICogcmVjb3JkcyBmb3IgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBzdHJpbmd9IGFtb3VudFJlY29yZCBPcHRpb25hbCBhbW91bnQgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtSZWNvcmRQbGFpbnRleHQgfCBzdHJpbmd9IGZlZVJlY29yZCBPcHRpb25hbCBmZWUgcmVjb3JkIHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtQcml2YXRlS2V5IHwgdW5kZWZpbmVkfSBwcml2YXRlS2V5IE9wdGlvbmFsIHByaXZhdGUga2V5IHRvIHVzZSBmb3IgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtPZmZsaW5lUXVlcnkgfCB1bmRlZmluZWR9IG9mZmxpbmVRdWVyeSBPcHRpb25hbCBvZmZsaW5lIHF1ZXJ5IGlmIGNyZWF0aW5nIHRyYW5zYWN0aW9ucyBpbiBhbiBvZmZsaW5lIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHRyYW5zYWN0aW9uIGlkIG9mIHRoZSB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTmV0d29ya0NsaWVudCwgS2V5UHJvdmlkZXIsIGFuZCBSZWNvcmRQcm92aWRlclxuICAgICAqIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBuZXcgQWxlb05ldHdvcmtDbGllbnQoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIik7XG4gICAgICogY29uc3Qga2V5UHJvdmlkZXIgPSBuZXcgQWxlb0tleVByb3ZpZGVyKCk7XG4gICAgICogY29uc3QgcmVjb3JkUHJvdmlkZXIgPSBuZXcgTmV0d29ya1JlY29yZFByb3ZpZGVyKGFjY291bnQsIG5ldHdvcmtDbGllbnQpO1xuICAgICAqXG4gICAgICogLy8gSW5pdGlhbGl6ZSBhIHByb2dyYW0gbWFuYWdlciB3aXRoIHRoZSBrZXkgcHJvdmlkZXIgdG8gYXV0b21hdGljYWxseSBmZXRjaCBrZXlzIGZvciBleGVjdXRpb25zXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHJlY29yZFByb3ZpZGVyKTtcbiAgICAgKiBhd2FpdCBwcm9ncmFtTWFuYWdlci5pbml0aWFsaXplKCk7XG4gICAgICogY29uc3QgdHhfaWQgPSBhd2FpdCBwcm9ncmFtTWFuYWdlci50cmFuc2ZlcigxLCBcImFsZW8xcmhnZHU3N2hneXFkM3hqajh1Y3Uzamo5cjJrcnd6Nm1uenlkODBnbmNyNWZ4Y3dsaDVyc3Z6cDlweFwiLCBcInByaXZhdGVcIiwgMC4yKVxuICAgICAqIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5nZXRUcmFuc2FjdGlvbih0eF9pZCk7XG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmZXIoYW1vdW50LCByZWNpcGllbnQsIHRyYW5zZmVyVHlwZSwgZmVlLCBwcml2YXRlRmVlLCByZWNvcmRTZWFyY2hQYXJhbXMsIGFtb3VudFJlY29yZCwgZmVlUmVjb3JkLCBwcml2YXRlS2V5LCBvZmZsaW5lUXVlcnkpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmJ1aWxkVHJhbnNmZXJUcmFuc2FjdGlvbihhbW91bnQsIHJlY2lwaWVudCwgdHJhbnNmZXJUeXBlLCBmZWUsIHByaXZhdGVGZWUsIHJlY29yZFNlYXJjaFBhcmFtcywgYW1vdW50UmVjb3JkLCBmZWVSZWNvcmQsIHByaXZhdGVLZXksIG9mZmxpbmVRdWVyeSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuc3VibWl0VHJhbnNhY3Rpb24odHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0cmFuc2FjdGlvbiB0byBib25kIGNyZWRpdHMgdG8gYSB2YWxpZGF0b3IgZm9yIGxhdGVyIHN1Ym1pc3Npb24gdG8gdGhlIEFsZW8gTmV0d29ya1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJvbmQgY3JlZGl0c1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnNldEFjY291bnQobmV3IEFjY291bnQoXCJZb3VyUHJpdmF0ZUtleVwiKSk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgdGhlIGJvbmRpbmcgdHJhbnNhY3Rpb24gb2JqZWN0IGZvciBsYXRlciBzdWJtaXNzaW9uXG4gICAgICogY29uc3QgdHggPSBhd2FpdCBwcm9ncmFtTWFuYWdlci5idWlsZEJvbmRQdWJsaWNUcmFuc2FjdGlvbihcImFsZW8xang4czRkdmplcGN1bG55NHdmcnp3eWhzM3RseXY2NXI1OG5zM2c2cTJnbTJlc2g3cHM4c3F5OXM1alwiLCBcImFsZW8xcmhnZHU3N2hneXFkM3hqajh1Y3Uzamo5cjJrcnd6Nm1uenlkODBnbmNyNWZ4Y3dsaDVyc3Z6cDlweFwiLCBcImFsZW8xZmV5YThzank5azJ6Zmx2bDJkeDM5cGRzcTV0anUyOGVsbnAyZWt0bm41ODh1dTlnaHY4czg0bXN2OVwiLCAyMDAwMDAwKTtcbiAgICAgKiBjb25zb2xlLmxvZyh0eCk7XG4gICAgICpcbiAgICAgKiAvLyBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIGxhdGVyIHN1Ym1pdHRlZCB0byB0aGUgbmV0d29yayB1c2luZyB0aGUgbmV0d29yayBjbGllbnQuXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5zdWJtaXRUcmFuc2FjdGlvbih0eCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yX2FkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdmFsaWRhdG9yIHRvIGJvbmQgdG8sIGlmIHRoaXMgYWRkcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgc3Rha2VyIChpLmUuIHRoZVxuICAgICAqIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24pLCBpdCB3aWxsIGF0dGVtcHQgdG8gYm9uZCB0aGUgY3JlZGl0cyBhcyBhIHZhbGlkYXRvci4gQm9uZGluZyBhcyBhIHZhbGlkYXRvciBjdXJyZW50bHlcbiAgICAgKiByZXF1aXJlcyBhIG1pbmltdW0gb2YgMTAsMDAwLDAwMCBjcmVkaXRzIHRvIGJvbmQgKHN1YmplY3QgdG8gY2hhbmdlKS4gSWYgdGhlIGFkZHJlc3MgaXMgc3BlY2lmaWVkIGlzIGFuIGV4aXN0aW5nXG4gICAgICogdmFsaWRhdG9yIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWRkcmVzcyBvZiB0aGUgZXhlY3V0b3Igb2YgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBib25kIHRoZSBjcmVkaXRzIHRvIHRoYXRcbiAgICAgKiB2YWxpZGF0b3IncyBzdGFraW5nIGNvbW1pdHRlZSBhcyBhIGRlbGVnYXRvci4gQSBtaW5pbXVtIG9mIDEwIGNyZWRpdHMgaXMgcmVxdWlyZWQgdG8gYm9uZCBhcyBhIGRlbGVnYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2l0aGRyYXdhbF9hZGRyZXNzIEFkZHJlc3MgdG8gd2l0aGRyYXcgdGhlIHN0YWtlZCBjcmVkaXRzIHRvIHdoZW4gdW5ib25kX3B1YmxpYyBpcyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gYm9uZFxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxFeGVjdXRlT3B0aW9ucz59IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkQm9uZFB1YmxpY1RyYW5zYWN0aW9uKHZhbGlkYXRvcl9hZGRyZXNzLCB3aXRoZHJhd2FsX2FkZHJlc3MsIGFtb3VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHNjYWxlZEFtb3VudCA9IE1hdGgudHJ1bmMoYW1vdW50ICogMTAwMDAwMCk7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3JhbU5hbWUgPSBcImNyZWRpdHMuYWxlb1wiLCBmdW5jdGlvbk5hbWUgPSBcImJvbmRfcHVibGljXCIsIGZlZSA9IG9wdGlvbnMuZmVlIHx8IDAuODYsIHByaXZhdGVGZWUgPSBmYWxzZSwgaW5wdXRzID0gW3ZhbGlkYXRvcl9hZGRyZXNzLCB3aXRoZHJhd2FsX2FkZHJlc3MsIGAke3NjYWxlZEFtb3VudC50b1N0cmluZygpfXU2NGBdLCBrZXlTZWFyY2hQYXJhbXMgPSBuZXcgQWxlb0tleVByb3ZpZGVyUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZlclVyaTogQ1JFRElUU19QUk9HUkFNX0tFWVMuYm9uZF9wdWJsaWMucHJvdmVyLFxuICAgICAgICAgICAgdmVyaWZpZXJVcmk6IENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfcHVibGljLnZlcmlmaWVyLFxuICAgICAgICAgICAgY2FjaGVLZXk6IFwiY3JlZGl0cy5hbGVvL2JvbmRfcHVibGljXCJcbiAgICAgICAgfSksIHByb2dyYW0gPSB0aGlzLmNyZWRpdHNQcm9ncmFtKCksIC4uLmFkZGl0aW9uYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBleGVjdXRlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmVlLFxuICAgICAgICAgICAgcHJpdmF0ZUZlZSxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGtleVNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmJ1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24oZXhlY3V0ZU9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCb25kIGNyZWRpdHMgdG8gdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJvbmQgY3JlZGl0c1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnNldEFjY291bnQobmV3IEFjY291bnQoXCJZb3VyUHJpdmF0ZUtleVwiKSk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgdGhlIGJvbmRpbmcgdHJhbnNhY3Rpb25cbiAgICAgKiBjb25zdCB0eF9pZCA9IGF3YWl0IHByb2dyYW1NYW5hZ2VyLmJvbmRQdWJsaWMoXCJhbGVvMWp4OHM0ZHZqZXBjdWxueTR3ZnJ6d3loczN0bHl2NjVyNThuczNnNnEyZ20yZXNoN3BzOHNxeTlzNWpcIiwgXCJhbGVvMXJoZ2R1NzdoZ3lxZDN4amo4dWN1M2pqOXIya3J3ejZtbnp5ZDgwZ25jcjVmeGN3bGg1cnN2enA5cHhcIiwgXCJhbGVvMWZleWE4c2p5OWsyemZsdmwyZHgzOXBkc3E1dGp1MjhlbG5wMmVrdG5uNTg4dXU5Z2h2OHM4NG1zdjlcIiwgMjAwMDAwMCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yX2FkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdmFsaWRhdG9yIHRvIGJvbmQgdG8sIGlmIHRoaXMgYWRkcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgc2lnbmVyIChpLmUuIHRoZVxuICAgICAqIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24pLCBpdCB3aWxsIGF0dGVtcHQgdG8gYm9uZCB0aGUgY3JlZGl0cyBhcyBhIHZhbGlkYXRvci4gQm9uZGluZyBhcyBhIHZhbGlkYXRvciBjdXJyZW50bHlcbiAgICAgKiByZXF1aXJlcyBhIG1pbmltdW0gb2YgMSwwMDAsMDAwIGNyZWRpdHMgdG8gYm9uZCAoc3ViamVjdCB0byBjaGFuZ2UpLiBJZiB0aGUgYWRkcmVzcyBpcyBzcGVjaWZpZWQgaXMgYW4gZXhpc3RpbmdcbiAgICAgKiB2YWxpZGF0b3IgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhZGRyZXNzIG9mIHRoZSBleGVjdXRvciBvZiB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJvbmQgdGhlIGNyZWRpdHMgdG8gdGhhdFxuICAgICAqIHZhbGlkYXRvcidzIHN0YWtpbmcgY29tbWl0dGVlIGFzIGEgZGVsZWdhdG9yLiBBIG1pbmltdW0gb2YgMTAgY3JlZGl0cyBpcyByZXF1aXJlZCB0byBib25kIGFzIGEgZGVsZWdhdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aXRoZHJhd2FsX2FkZHJlc3MgQWRkcmVzcyB0byB3aXRoZHJhdyB0aGUgc3Rha2VkIGNyZWRpdHMgdG8gd2hlbiB1bmJvbmRfcHVibGljIGlzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgY3JlZGl0cyB0byBib25kXG4gICAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBleGVjdXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBib25kUHVibGljKHZhbGlkYXRvcl9hZGRyZXNzLCB3aXRoZHJhd2FsX2FkZHJlc3MsIGFtb3VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5idWlsZEJvbmRQdWJsaWNUcmFuc2FjdGlvbih2YWxpZGF0b3JfYWRkcmVzcywgd2l0aGRyYXdhbF9hZGRyZXNzLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSBib25kX3ZhbGlkYXRvciB0cmFuc2FjdGlvbiBmb3IgbGF0ZXIgc3VibWlzc2lvbiB0byB0aGUgQWxlbyBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJvbmQgY3JlZGl0c1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnNldEFjY291bnQobmV3IEFjY291bnQoXCJZb3VyUHJpdmF0ZUtleVwiKSk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgdGhlIGJvbmQgdmFsaWRhdG9yIHRyYW5zYWN0aW9uIG9iamVjdCBmb3IgbGF0ZXIgdXNlLlxuICAgICAqIGNvbnN0IHR4ID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuYnVpbGRCb25kVmFsaWRhdG9yVHJhbnNhY3Rpb24oXCJhbGVvMXJoZ2R1NzdoZ3lxZDN4amo4dWN1M2pqOXIya3J3ejZtbnp5ZDgwZ25jcjVmeGN3bGg1cnN2enA5cHhcIiwgXCJhbGVvMWZleWE4c2p5OWsyemZsdmwyZHgzOXBkc3E1dGp1MjhlbG5wMmVrdG5uNTg4dXU5Z2h2OHM4NG1zdjlcIiwgMjAwMDAwMCk7XG4gICAgICogY29uc29sZS5sb2codHgpO1xuICAgICAqXG4gICAgICogLy8gVGhlIHRyYW5zYWN0aW9uIGNhbiBsYXRlciBiZSBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmsgdXNpbmcgdGhlIG5ldHdvcmsgY2xpZW50LlxuICAgICAqIGNvbnN0IHR4X2lkID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5zdWJtaXRUcmFuc2FjdGlvbih0eCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yX2FkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdmFsaWRhdG9yIHRvIGJvbmQgdG8sIGlmIHRoaXMgYWRkcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgc3Rha2VyIChpLmUuIHRoZVxuICAgICAqIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24pLCBpdCB3aWxsIGF0dGVtcHQgdG8gYm9uZCB0aGUgY3JlZGl0cyBhcyBhIHZhbGlkYXRvci4gQm9uZGluZyBhcyBhIHZhbGlkYXRvciBjdXJyZW50bHlcbiAgICAgKiByZXF1aXJlcyBhIG1pbmltdW0gb2YgMTAsMDAwLDAwMCBjcmVkaXRzIHRvIGJvbmQgKHN1YmplY3QgdG8gY2hhbmdlKS4gSWYgdGhlIGFkZHJlc3MgaXMgc3BlY2lmaWVkIGlzIGFuIGV4aXN0aW5nXG4gICAgICogdmFsaWRhdG9yIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWRkcmVzcyBvZiB0aGUgZXhlY3V0b3Igb2YgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBib25kIHRoZSBjcmVkaXRzIHRvIHRoYXRcbiAgICAgKiB2YWxpZGF0b3IncyBzdGFraW5nIGNvbW1pdHRlZSBhcyBhIGRlbGVnYXRvci4gQSBtaW5pbXVtIG9mIDEwIGNyZWRpdHMgaXMgcmVxdWlyZWQgdG8gYm9uZCBhcyBhIGRlbGVnYXRvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2l0aGRyYXdhbF9hZGRyZXNzIEFkZHJlc3MgdG8gd2l0aGRyYXcgdGhlIHN0YWtlZCBjcmVkaXRzIHRvIHdoZW4gdW5ib25kX3B1YmxpYyBpcyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIGNyZWRpdHMgdG8gYm9uZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb21taXNzaW9uIFRoZSBjb21taXNzaW9uIHJhdGUgZm9yIHRoZSB2YWxpZGF0b3IgKG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAgLSBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBpdCBpcyBub3QpXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPEV4ZWN1dGVPcHRpb25zPn0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRCb25kVmFsaWRhdG9yVHJhbnNhY3Rpb24odmFsaWRhdG9yX2FkZHJlc3MsIHdpdGhkcmF3YWxfYWRkcmVzcywgYW1vdW50LCBjb21taXNzaW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc2NhbGVkQW1vdW50ID0gTWF0aC50cnVuYyhhbW91bnQgKiAxMDAwMDAwKTtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRDb21taXNzaW9uID0gTWF0aC50cnVuYyhjb21taXNzaW9uKTtcbiAgICAgICAgY29uc3QgeyBwcm9ncmFtTmFtZSA9IFwiY3JlZGl0cy5hbGVvXCIsIGZ1bmN0aW9uTmFtZSA9IFwiYm9uZF92YWxpZGF0b3JcIiwgZmVlID0gb3B0aW9ucy5mZWUgfHwgMC44NiwgcHJpdmF0ZUZlZSA9IGZhbHNlLCBpbnB1dHMgPSBbdmFsaWRhdG9yX2FkZHJlc3MsIHdpdGhkcmF3YWxfYWRkcmVzcywgYCR7c2NhbGVkQW1vdW50LnRvU3RyaW5nKCl9dTY0YCwgYCR7YWRqdXN0ZWRDb21taXNzaW9uLnRvU3RyaW5nKCl9dThgXSwga2V5U2VhcmNoUGFyYW1zID0gbmV3IEFsZW9LZXlQcm92aWRlclBhcmFtcyh7XG4gICAgICAgICAgICBwcm92ZXJVcmk6IENSRURJVFNfUFJPR1JBTV9LRVlTLmJvbmRfdmFsaWRhdG9yLnByb3ZlcixcbiAgICAgICAgICAgIHZlcmlmaWVyVXJpOiBDUkVESVRTX1BST0dSQU1fS0VZUy5ib25kX3ZhbGlkYXRvci52ZXJpZmllcixcbiAgICAgICAgICAgIGNhY2hlS2V5OiBcImNyZWRpdHMuYWxlby9ib25kX3ZhbGlkYXRvclwiXG4gICAgICAgIH0pLCBwcm9ncmFtID0gdGhpcy5jcmVkaXRzUHJvZ3JhbSgpLCAuLi5hZGRpdGlvbmFsT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZXhlY3V0ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm9ncmFtTmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZlZSxcbiAgICAgICAgICAgIHByaXZhdGVGZWUsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBrZXlTZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5idWlsZEV4ZWN1dGlvblRyYW5zYWN0aW9uKGV4ZWN1dGVPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgdHJhbnNhY3Rpb24gdG8gYm9uZCBhIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEga2V5UHJvdmlkZXIgdG8gaGFuZGxlIGtleSBtYW5hZ2VtZW50XG4gICAgICogY29uc3Qga2V5UHJvdmlkZXIgPSBuZXcgQWxlb0tleVByb3ZpZGVyKCk7XG4gICAgICoga2V5UHJvdmlkZXIudXNlQ2FjaGUgPSB0cnVlO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IFByb2dyYW1NYW5hZ2VyIHdpdGggdGhlIGtleSB0aGF0IHdpbGwgYmUgdXNlZCB0byBib25kIGNyZWRpdHNcbiAgICAgKiBjb25zdCBwcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcihcImh0dHBzOi8vYXBpLmV4cGxvcmVyLnByb3ZhYmxlLmNvbS92MVwiLCBrZXlQcm92aWRlciwgdW5kZWZpbmVkKTtcbiAgICAgKiBwcm9ncmFtTWFuYWdlci5zZXRBY2NvdW50KG5ldyBBY2NvdW50KFwiWW91clByaXZhdGVLZXlcIikpO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIHRoZSBib25kaW5nIHRyYW5zYWN0aW9uXG4gICAgICogY29uc3QgdHhfaWQgPSBhd2FpdCBwcm9ncmFtTWFuYWdlci5ib25kVmFsaWRhdG9yKFwiYWxlbzFyaGdkdTc3aGd5cWQzeGpqOHVjdTNqajlyMmtyd3o2bW56eWQ4MGduY3I1Znhjd2xoNXJzdnpwOXB4XCIsIFwiYWxlbzFmZXlhOHNqeTlrMnpmbHZsMmR4MzlwZHNxNXRqdTI4ZWxucDJla3RubjU4OHV1OWdodjhzODRtc3Y5XCIsIDIwMDAwMDApO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvcl9hZGRyZXNzIEFkZHJlc3Mgb2YgdGhlIHZhbGlkYXRvciB0byBib25kIHRvLCBpZiB0aGlzIGFkZHJlc3MgaXMgdGhlIHNhbWUgYXMgdGhlIHN0YWtlciAoaS5lLiB0aGVcbiAgICAgKiBleGVjdXRvciBvZiB0aGlzIGZ1bmN0aW9uKSwgaXQgd2lsbCBhdHRlbXB0IHRvIGJvbmQgdGhlIGNyZWRpdHMgYXMgYSB2YWxpZGF0b3IuIEJvbmRpbmcgYXMgYSB2YWxpZGF0b3IgY3VycmVudGx5XG4gICAgICogcmVxdWlyZXMgYSBtaW5pbXVtIG9mIDEwLDAwMCwwMDAgY3JlZGl0cyB0byBib25kIChzdWJqZWN0IHRvIGNoYW5nZSkuIElmIHRoZSBhZGRyZXNzIGlzIHNwZWNpZmllZCBpcyBhbiBleGlzdGluZ1xuICAgICAqIHZhbGlkYXRvciBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGFkZHJlc3Mgb2YgdGhlIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYm9uZCB0aGUgY3JlZGl0cyB0byB0aGF0XG4gICAgICogdmFsaWRhdG9yJ3Mgc3Rha2luZyBjb21taXR0ZWUgYXMgYSBkZWxlZ2F0b3IuIEEgbWluaW11bSBvZiAxMCBjcmVkaXRzIGlzIHJlcXVpcmVkIHRvIGJvbmQgYXMgYSBkZWxlZ2F0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdpdGhkcmF3YWxfYWRkcmVzcyBBZGRyZXNzIHRvIHdpdGhkcmF3IHRoZSBzdGFrZWQgY3JlZGl0cyB0byB3aGVuIHVuYm9uZF9wdWJsaWMgaXMgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiBjcmVkaXRzIHRvIGJvbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29tbWlzc2lvbiBUaGUgY29tbWlzc2lvbiByYXRlIGZvciB0aGUgdmFsaWRhdG9yIChtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwIC0gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgaXQgaXMgbm90KVxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxFeGVjdXRlT3B0aW9ucz59IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGJvbmRWYWxpZGF0b3IodmFsaWRhdG9yX2FkZHJlc3MsIHdpdGhkcmF3YWxfYWRkcmVzcywgYW1vdW50LCBjb21taXNzaW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmJ1aWxkQm9uZFZhbGlkYXRvclRyYW5zYWN0aW9uKHZhbGlkYXRvcl9hZGRyZXNzLCB3aXRoZHJhd2FsX2FkZHJlc3MsIGFtb3VudCwgY29tbWlzc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm5ldHdvcmtDbGllbnQuc3VibWl0VHJhbnNhY3Rpb24odHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHRyYW5zYWN0aW9uIHRvIHVuYm9uZCBwdWJsaWMgY3JlZGl0cyBmcm9tIGEgdmFsaWRhdG9yIGluIHRoZSBBbGVvIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2VyX2FkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc3Rha2VyIHdobyBpcyB1bmJvbmRpbmcgdGhlIGNyZWRpdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBhbW91bnQgb2YgY3JlZGl0cyB0byB1bmJvbmQgKHNjYWxlZCBieSAxLDAwMCwwMDApLlxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxFeGVjdXRlT3B0aW9ucz59IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEga2V5UHJvdmlkZXIgdG8gaGFuZGxlIGtleSBtYW5hZ2VtZW50LlxuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGtleVByb3ZpZGVyLnVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBQcm9ncmFtTWFuYWdlciB3aXRoIHRoZSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdW5ib25kIGNyZWRpdHMuXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHVuZGVmaW5lZCk7XG4gICAgICogY29uc3QgdHggPSBhd2FpdCBwcm9ncmFtTWFuYWdlci5idWlsZFVuYm9uZFB1YmxpY1RyYW5zYWN0aW9uKFwiYWxlbzFqeDhzNGR2amVwY3Vsbnk0d2Zyend5aHMzdGx5djY1cjU4bnMzZzZxMmdtMmVzaDdwczhzcXk5czVqXCIsIDIwMDAwMDApO1xuICAgICAqIGNvbnNvbGUubG9nKHR4KTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgc3VibWl0dGVkIGxhdGVyIHRvIHRoZSBuZXR3b3JrIHVzaW5nIHRoZSBuZXR3b3JrIGNsaWVudC5cbiAgICAgKiBwcm9ncmFtTWFuYWdlci5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgKi9cbiAgICBhc3luYyBidWlsZFVuYm9uZFB1YmxpY1RyYW5zYWN0aW9uKHN0YWtlcl9hZGRyZXNzLCBhbW91bnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzY2FsZWRBbW91bnQgPSBNYXRoLnRydW5jKGFtb3VudCAqIDEwMDAwMDApO1xuICAgICAgICBjb25zdCB7IHByb2dyYW1OYW1lID0gXCJjcmVkaXRzLmFsZW9cIiwgZnVuY3Rpb25OYW1lID0gXCJ1bmJvbmRfcHVibGljXCIsIGZlZSA9IG9wdGlvbnMuZmVlIHx8IDEuMywgcHJpdmF0ZUZlZSA9IGZhbHNlLCBpbnB1dHMgPSBbc3Rha2VyX2FkZHJlc3MsIGAke3NjYWxlZEFtb3VudC50b1N0cmluZygpfXU2NGBdLCBrZXlTZWFyY2hQYXJhbXMgPSBuZXcgQWxlb0tleVByb3ZpZGVyUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZlclVyaTogQ1JFRElUU19QUk9HUkFNX0tFWVMudW5ib25kX3B1YmxpYy5wcm92ZXIsXG4gICAgICAgICAgICB2ZXJpZmllclVyaTogQ1JFRElUU19QUk9HUkFNX0tFWVMudW5ib25kX3B1YmxpYy52ZXJpZmllcixcbiAgICAgICAgICAgIGNhY2hlS2V5OiBcImNyZWRpdHMuYWxlby91bmJvbmRfcHVibGljXCJcbiAgICAgICAgfSksIHByb2dyYW0gPSB0aGlzLmNyZWRpdHNQcm9ncmFtKCksIC4uLmFkZGl0aW9uYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBleGVjdXRlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmVlLFxuICAgICAgICAgICAgcHJpdmF0ZUZlZSxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGtleVNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRXhlY3V0aW9uVHJhbnNhY3Rpb24oZXhlY3V0ZU9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJvbmQgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHN0YWtlZCBjcmVkaXRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJvbmQgY3JlZGl0c1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnNldEFjY291bnQobmV3IEFjY291bnQoXCJZb3VyUHJpdmF0ZUtleVwiKSk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgdGhlIGJvbmRpbmcgdHJhbnNhY3Rpb24gYW5kIHNlbmQgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICAgKiBjb25zdCB0eF9pZCA9IGF3YWl0IHByb2dyYW1NYW5hZ2VyLnVuYm9uZFB1YmxpYyhcImFsZW8xang4czRkdmplcGN1bG55NHdmcnp3eWhzM3RseXY2NXI1OG5zM2c2cTJnbTJlc2g3cHM4c3F5OXM1alwiLCAxMCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2VyX2FkZHJlc3MgQWRkcmVzcyBvZiB0aGUgc3Rha2VyIHdobyBpcyB1bmJvbmRpbmcgdGhlIGNyZWRpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IEFtb3VudCBvZiBjcmVkaXRzIHRvIHVuYm9uZC4gSWYgdGhlIGFkZHJlc3Mgb2YgdGhlIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24gaXMgYW5cbiAgICAgKiBleGlzdGluZyB2YWxpZGF0b3IsIGl0IHdpbGwgc3VidHJhY3QgdGhpcyBhbW91bnQgb2YgY3JlZGl0cyBmcm9tIHRoZSB2YWxpZGF0b3IncyBzdGFrZWQgY3JlZGl0cy4gSWYgdGhlcmUgYXJlXG4gICAgICogbGVzcyB0aGFuIDEsMDAwLDAwMCBjcmVkaXRzIHN0YWtlZCBwb29sIGFmdGVyIHRoZSB1bmJvbmQsIHRoZSB2YWxpZGF0b3Igd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHZhbGlkYXRvciBzZXQuXG4gICAgICogSWYgdGhlIGFkZHJlc3Mgb2YgdGhlIGV4ZWN1dG9yIG9mIHRoaXMgZnVuY3Rpb24gaXMgbm90IGEgdmFsaWRhdG9yIGFuZCBoYXMgY3JlZGl0cyBib25kZWQgYXMgYSBkZWxlZ2F0b3IsIGl0IHdpbGxcbiAgICAgKiBzdWJ0cmFjdCB0aGlzIGFtb3VudCBvZiBjcmVkaXRzIGZyb20gdGhlIGRlbGVnYXRvcidzIHN0YWtlZCBjcmVkaXRzLiBJZiB0aGVyZSBhcmUgbGVzcyB0aGFuIDEwIGNyZWRpdHMgYm9uZGVkXG4gICAgICogYWZ0ZXIgdGhlIHVuYm9uZCBvcGVyYXRpb24sIHRoZSBkZWxlZ2F0b3Igd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHZhbGlkYXRvcidzIHN0YWtpbmcgcG9vbC5cbiAgICAgKiBAcGFyYW0ge0V4ZWN1dGVPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBleGVjdXRpb25cbiAgICAgKi9cbiAgICBhc3luYyB1bmJvbmRQdWJsaWMoc3Rha2VyX2FkZHJlc3MsIGFtb3VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5idWlsZFVuYm9uZFB1YmxpY1RyYW5zYWN0aW9uKHN0YWtlcl9hZGRyZXNzLCBhbW91bnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSB0cmFuc2FjdGlvbiB0byBjbGFpbSB1bmJvbmRlZCBwdWJsaWMgY3JlZGl0cyBpbiB0aGUgQWxlbyBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtlcl9hZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHN0YWtlciB3aG8gaXMgY2xhaW1pbmcgdGhlIGNyZWRpdHMuXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPEV4ZWN1dGVPcHRpb25zPn0gb3B0aW9ucyAtIE92ZXJyaWRlIGRlZmF1bHQgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNsYWltIHVuYm9uZGVkIGNyZWRpdHMuXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHVuZGVmaW5lZCk7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgdGhlIGNsYWltIHVuYm9uZGVkIHRyYW5zYWN0aW9uIG9iamVjdCBmb3IgbGF0ZXIgdXNlLlxuICAgICAqIGNvbnN0IHR4ID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuYnVpbGRDbGFpbVVuYm9uZFB1YmxpY1RyYW5zYWN0aW9uKFwiYWxlbzFqeDhzNGR2amVwY3Vsbnk0d2Zyend5aHMzdGx5djY1cjU4bnMzZzZxMmdtMmVzaDdwczhzcXk5czVqXCIpO1xuICAgICAqIGNvbnNvbGUubG9nKHR4KTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgc3VibWl0dGVkIGxhdGVyIHRvIHRoZSBuZXR3b3JrIHVzaW5nIHRoZSBuZXR3b3JrIGNsaWVudC5cbiAgICAgKiBwcm9ncmFtTWFuYWdlci5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgKi9cbiAgICBhc3luYyBidWlsZENsYWltVW5ib25kUHVibGljVHJhbnNhY3Rpb24oc3Rha2VyX2FkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHByb2dyYW1OYW1lID0gXCJjcmVkaXRzLmFsZW9cIiwgZnVuY3Rpb25OYW1lID0gXCJjbGFpbV91bmJvbmRfcHVibGljXCIsIGZlZSA9IG9wdGlvbnMuZmVlIHx8IDIsIHByaXZhdGVGZWUgPSBmYWxzZSwgaW5wdXRzID0gW3N0YWtlcl9hZGRyZXNzXSwga2V5U2VhcmNoUGFyYW1zID0gbmV3IEFsZW9LZXlQcm92aWRlclBhcmFtcyh7XG4gICAgICAgICAgICBwcm92ZXJVcmk6IENSRURJVFNfUFJPR1JBTV9LRVlTLmNsYWltX3VuYm9uZF9wdWJsaWMucHJvdmVyLFxuICAgICAgICAgICAgdmVyaWZpZXJVcmk6IENSRURJVFNfUFJPR1JBTV9LRVlTLmNsYWltX3VuYm9uZF9wdWJsaWMudmVyaWZpZXIsXG4gICAgICAgICAgICBjYWNoZUtleTogXCJjcmVkaXRzLmFsZW8vY2xhaW1fdW5ib25kX3B1YmxpY1wiXG4gICAgICAgIH0pLCBwcm9ncmFtID0gdGhpcy5jcmVkaXRzUHJvZ3JhbSgpLCAuLi5hZGRpdGlvbmFsT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZXhlY3V0ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm9ncmFtTmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZlZSxcbiAgICAgICAgICAgIHByaXZhdGVGZWUsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBrZXlTZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5idWlsZEV4ZWN1dGlvblRyYW5zYWN0aW9uKGV4ZWN1dGVPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhaW0gdW5ib25kZWQgY3JlZGl0cy4gSWYgY3JlZGl0cyBoYXZlIGJlZW4gdW5ib25kZWQgYnkgdGhlIGFjY291bnQgZXhlY3V0aW5nIHRoaXMgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHdpbGxcbiAgICAgKiBjbGFpbSB0aGVtIGFuZCBhZGQgdGhlbSB0byB0aGUgcHVibGljIGJhbGFuY2Ugb2YgdGhlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIGtleVByb3ZpZGVyIHRvIGhhbmRsZSBrZXkgbWFuYWdlbWVudFxuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGtleVByb3ZpZGVyLnVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBQcm9ncmFtTWFuYWdlciB3aXRoIHRoZSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYm9uZCBjcmVkaXRzXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHVuZGVmaW5lZCk7XG4gICAgICogcHJvZ3JhbU1hbmFnZXIuc2V0QWNjb3VudChuZXcgQWNjb3VudChcIllvdXJQcml2YXRlS2V5XCIpKTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSB0aGUgYm9uZGluZyB0cmFuc2FjdGlvblxuICAgICAqIGNvbnN0IHR4X2lkID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuY2xhaW1VbmJvbmRQdWJsaWMoXCJhbGVvMWp4OHM0ZHZqZXBjdWxueTR3ZnJ6d3loczN0bHl2NjVyNThuczNnNnEyZ20yZXNoN3BzOHNxeTlzNWpcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2VyX2FkZHJlc3MgQWRkcmVzcyBvZiB0aGUgc3Rha2VyIHdobyBpcyBjbGFpbWluZyB0aGUgY3JlZGl0c1xuICAgICAqIEBwYXJhbSB7RXhlY3V0ZU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBjbGFpbVVuYm9uZFB1YmxpYyhzdGFrZXJfYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5idWlsZENsYWltVW5ib25kUHVibGljVHJhbnNhY3Rpb24oc3Rha2VyX2FkZHJlc3MsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSBzZXRfdmFsaWRhdG9yX3N0YXRlIHRyYW5zYWN0aW9uIGZvciBsYXRlciB1c2FnZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIGEgdmFsaWRhdG9yIHRvIHNldCB0aGVpciBzdGF0ZSB0byBiZSBlaXRoZXIgb3BlbmVkIG9yIGNsb3NlZCB0byBuZXcgc3Rha2Vycy5cbiAgICAgKiBXaGVuIHRoZSB2YWxpZGF0b3IgaXMgb3BlbiB0byBuZXcgc3Rha2VycywgYW55IHN0YWtlciAoaW5jbHVkaW5nIHRoZSB2YWxpZGF0b3IpIGNhbiBib25kIG9yIHVuYm9uZCBmcm9tIHRoZSB2YWxpZGF0b3IuXG4gICAgICogV2hlbiB0aGUgdmFsaWRhdG9yIGlzIGNsb3NlZCB0byBuZXcgc3Rha2VycywgZXhpc3Rpbmcgc3Rha2VycyBjYW4gc3RpbGwgYm9uZCBvciB1bmJvbmQgZnJvbSB0aGUgdmFsaWRhdG9yLCBidXQgbmV3IHN0YWtlcnMgY2Fubm90IGJvbmQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyB0d28gcHJpbWFyeSBwdXJwb3NlczpcbiAgICAgKiAxLiBBbGxvdyBhIHZhbGlkYXRvciB0byBsZWF2ZSB0aGUgY29tbWl0dGVlLCBieSBjbG9zaW5nIHRoZW1zZWx2ZXMgdG8gc3Rha2VycyBhbmQgdGhlbiB1bmJvbmRpbmcgYWxsIG9mIHRoZWlyIHN0YWtlcnMuXG4gICAgICogMi4gQWxsb3cgYSB2YWxpZGF0b3IgdG8gbWFpbnRhaW4gdGhlaXIgJSBvZiBzdGFrZSwgYnkgY2xvc2luZyB0aGVtc2VsdmVzIHRvIGFsbG93aW5nIG1vcmUgc3Rha2VycyB0byBib25kIHRvIHRoZW0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIGtleVByb3ZpZGVyIHRvIGhhbmRsZSBrZXkgbWFuYWdlbWVudFxuICAgICAqIGNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuICAgICAqIGtleVByb3ZpZGVyLnVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBQcm9ncmFtTWFuYWdlciB3aXRoIHRoZSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYm9uZCBjcmVkaXRzXG4gICAgICogY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIiwga2V5UHJvdmlkZXIsIHVuZGVmaW5lZCk7XG4gICAgICogcHJvZ3JhbU1hbmFnZXIuc2V0QWNjb3VudChuZXcgQWNjb3VudChcIlZhbGlkYXRvclByaXZhdGVLZXlcIikpO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIHRoZSBib25kaW5nIHRyYW5zYWN0aW9uXG4gICAgICogY29uc3QgdHggPSBhd2FpdCBwcm9ncmFtTWFuYWdlci5idWlsZFNldFZhbGlkYXRvclN0YXRlVHJhbnNhY3Rpb24odHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIHN1Ym1pdHRlZCBsYXRlciB0byB0aGUgbmV0d29yayB1c2luZyB0aGUgbmV0d29yayBjbGllbnQuXG4gICAgICogcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5zdWJtaXRUcmFuc2FjdGlvbih0eCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkYXRvcl9zdGF0ZVxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxFeGVjdXRlT3B0aW9ucz59IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGV4ZWN1dGlvbiBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRTZXRWYWxpZGF0b3JTdGF0ZVRyYW5zYWN0aW9uKHZhbGlkYXRvcl9zdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3JhbU5hbWUgPSBcImNyZWRpdHMuYWxlb1wiLCBmdW5jdGlvbk5hbWUgPSBcInNldF92YWxpZGF0b3Jfc3RhdGVcIiwgZmVlID0gMSwgcHJpdmF0ZUZlZSA9IGZhbHNlLCBpbnB1dHMgPSBbdmFsaWRhdG9yX3N0YXRlLnRvU3RyaW5nKCldLCBrZXlTZWFyY2hQYXJhbXMgPSBuZXcgQWxlb0tleVByb3ZpZGVyUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZlclVyaTogQ1JFRElUU19QUk9HUkFNX0tFWVMuc2V0X3ZhbGlkYXRvcl9zdGF0ZS5wcm92ZXIsXG4gICAgICAgICAgICB2ZXJpZmllclVyaTogQ1JFRElUU19QUk9HUkFNX0tFWVMuc2V0X3ZhbGlkYXRvcl9zdGF0ZS52ZXJpZmllcixcbiAgICAgICAgICAgIGNhY2hlS2V5OiBcImNyZWRpdHMuYWxlby9zZXRfdmFsaWRhdG9yX3N0YXRlXCJcbiAgICAgICAgfSksIC4uLmFkZGl0aW9uYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBleGVjdXRlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmVlLFxuICAgICAgICAgICAgcHJpdmF0ZUZlZSxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGtleVNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGUoZXhlY3V0ZU9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgYSBzZXRfdmFsaWRhdG9yX3N0YXRlIHRyYW5zYWN0aW9uIHRvIHRoZSBBbGVvIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBhIHZhbGlkYXRvciB0byBzZXQgdGhlaXIgc3RhdGUgdG8gYmUgZWl0aGVyIG9wZW5lZCBvciBjbG9zZWQgdG8gbmV3IHN0YWtlcnMuXG4gICAgICogV2hlbiB0aGUgdmFsaWRhdG9yIGlzIG9wZW4gdG8gbmV3IHN0YWtlcnMsIGFueSBzdGFrZXIgKGluY2x1ZGluZyB0aGUgdmFsaWRhdG9yKSBjYW4gYm9uZCBvciB1bmJvbmQgZnJvbSB0aGUgdmFsaWRhdG9yLlxuICAgICAqIFdoZW4gdGhlIHZhbGlkYXRvciBpcyBjbG9zZWQgdG8gbmV3IHN0YWtlcnMsIGV4aXN0aW5nIHN0YWtlcnMgY2FuIHN0aWxsIGJvbmQgb3IgdW5ib25kIGZyb20gdGhlIHZhbGlkYXRvciwgYnV0IG5ldyBzdGFrZXJzIGNhbm5vdCBib25kLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzZXJ2ZXMgdHdvIHByaW1hcnkgcHVycG9zZXM6XG4gICAgICogMS4gQWxsb3cgYSB2YWxpZGF0b3IgdG8gbGVhdmUgdGhlIGNvbW1pdHRlZSwgYnkgY2xvc2luZyB0aGVtc2VsdmVzIHRvIHN0YWtlcnMgYW5kIHRoZW4gdW5ib25kaW5nIGFsbCBvZiB0aGVpciBzdGFrZXJzLlxuICAgICAqIDIuIEFsbG93IGEgdmFsaWRhdG9yIHRvIG1haW50YWluIHRoZWlyICUgb2Ygc3Rha2UsIGJ5IGNsb3NpbmcgdGhlbXNlbHZlcyB0byBhbGxvd2luZyBtb3JlIHN0YWtlcnMgdG8gYm9uZCB0byB0aGVtLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBrZXlQcm92aWRlciB0byBoYW5kbGUga2V5IG1hbmFnZW1lbnRcbiAgICAgKiBjb25zdCBrZXlQcm92aWRlciA9IG5ldyBBbGVvS2V5UHJvdmlkZXIoKTtcbiAgICAgKiBrZXlQcm92aWRlci51c2VDYWNoZSA9IHRydWU7XG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgUHJvZ3JhbU1hbmFnZXIgd2l0aCB0aGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJvbmQgY3JlZGl0c1xuICAgICAqIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKFwiaHR0cHM6Ly9hcGkuZXhwbG9yZXIucHJvdmFibGUuY29tL3YxXCIsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xuICAgICAqIHByb2dyYW1NYW5hZ2VyLnNldEFjY291bnQobmV3IEFjY291bnQoXCJWYWxpZGF0b3JQcml2YXRlS2V5XCIpKTtcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSB0aGUgYm9uZGluZyB0cmFuc2FjdGlvblxuICAgICAqIGNvbnN0IHR4X2lkID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuc2V0VmFsaWRhdG9yU3RhdGUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkYXRvcl9zdGF0ZVxuICAgICAqIEBwYXJhbSB7UGFydGlhbDxFeGVjdXRlT3B0aW9ucz59IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IGV4ZWN1dGlvbiBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgc2V0VmFsaWRhdG9yU3RhdGUodmFsaWRhdG9yX3N0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmJ1aWxkU2V0VmFsaWRhdG9yU3RhdGVUcmFuc2FjdGlvbih2YWxpZGF0b3Jfc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrQ2xpZW50LnN1Ym1pdFRyYW5zYWN0aW9uKHR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGEgcHJvb2Ygb2YgZXhlY3V0aW9uIGZyb20gYW4gb2ZmbGluZSBleGVjdXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXhlY3V0aW9uUmVzcG9uc2V9IGV4ZWN1dGlvblJlc3BvbnNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb29mIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB2ZXJpZnlFeGVjdXRpb24oZXhlY3V0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGlvbiA9IGV4ZWN1dGlvblJlc3BvbnNlLmdldEV4ZWN1dGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25faWQgPSBleGVjdXRpb25SZXNwb25zZS5nZXRGdW5jdGlvbklkKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmFtID0gZXhlY3V0aW9uUmVzcG9uc2UuZ2V0UHJvZ3JhbSgpO1xuICAgICAgICAgICAgY29uc3QgdmVyaWZ5aW5nS2V5ID0gZXhlY3V0aW9uUmVzcG9uc2UuZ2V0VmVyaWZ5aW5nS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gdmVyaWZ5RnVuY3Rpb25FeGVjdXRpb24oZXhlY3V0aW9uLCB2ZXJpZnlpbmdLZXksIHByb2dyYW0sIGZ1bmN0aW9uX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGV4ZWN1dGlvbiB3YXMgbm90IGZvdW5kIGluIHRoZSByZXNwb25zZSwgY2Fubm90IHZlcmlmeSB0aGUgZXhlY3V0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHByb2dyYW0gb2JqZWN0IGZyb20gYSBwcm9ncmFtJ3Mgc291cmNlIGNvZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9ncmFtIFByb2dyYW0gc291cmNlIGNvZGVcbiAgICAgKiBAcmV0dXJucyB7UHJvZ3JhbX0gVGhlIHByb2dyYW0gb2JqZWN0XG4gICAgICovXG4gICAgY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UocHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gUHJvZ3JhbS5mcm9tU3RyaW5nKHByb2dyYW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyZWRpdHMgcHJvZ3JhbSBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9ncmFtfSBUaGUgY3JlZGl0cyBwcm9ncmFtIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWRpdHNQcm9ncmFtKCkge1xuICAgICAgICByZXR1cm4gUHJvZ3JhbS5nZXRDcmVkaXRzUHJvZ3JhbSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgYSBwcm9ncmFtIGlzIHZhbGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvZ3JhbSBUaGUgcHJvZ3JhbSBzb3VyY2UgY29kZVxuICAgICAqL1xuICAgIHZlcmlmeVByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUHJvZ3JhbS5mcm9tU3RyaW5nKHByb2dyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgY3JlZGl0cy5hbGVvIHJlY29yZFxuICAgIGFzeW5jIGdldENyZWRpdHNSZWNvcmQoYW1vdW50LCBub25jZXMsIHJlY29yZCwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkIGluc3RhbmNlb2YgUmVjb3JkUGxhaW50ZXh0ID8gcmVjb3JkIDogUmVjb3JkUGxhaW50ZXh0LmZyb21TdHJpbmcocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRQcm92aWRlciA9IHRoaXMucmVjb3JkUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCByZWNvcmRQcm92aWRlci5maW5kQ3JlZGl0c1JlY29yZChhbW91bnQsIHRydWUsIG5vbmNlcywgcGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0FuZFRocm93KGBFcnJvciBmaW5kaW5nIGZlZSByZWNvcmQuIFJlY29yZCBmaW5kZXIgcmVzcG9uc2U6ICcke2UubWVzc2FnZX0nLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb25uZWN0ZWQgdG8gYSB2YWxpZCBBbGVvIG5ldHdvcmsgYW5kIGEgcmVjb3JkIHdpdGggZW5vdWdoIGJhbGFuY2UgZXhpc3RzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRW5zdXJlIHRoZSB0cmFuc2ZlciB0eXBlIHJlcXVpcmVzIGFuIGFtb3VudCByZWNvcmRcbmZ1bmN0aW9uIHJlcXVpcmVzQW1vdW50UmVjb3JkKHRyYW5zZmVyVHlwZSkge1xuICAgIHJldHVybiBQUklWQVRFX1RSQU5TRkVSX1RZUEVTLmhhcyh0cmFuc2ZlclR5cGUpO1xufVxuLy8gVmFsaWRhdGUgdGhlIHRyYW5zZmVyIHR5cGVcbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNmZXJUeXBlKHRyYW5zZmVyVHlwZSkge1xuICAgIHJldHVybiBWQUxJRF9UUkFOU0ZFUl9UWVBFUy5oYXModHJhbnNmZXJUeXBlKSA/IHRyYW5zZmVyVHlwZSA6XG4gICAgICAgIGxvZ0FuZFRocm93KGBJbnZhbGlkIHRyYW5zZmVyIHR5cGUgJyR7dHJhbnNmZXJUeXBlfScuIFZhbGlkIHRyYW5zZmVyIHR5cGVzIGFyZSAncHJpdmF0ZScsICdwcml2YXRlVG9QdWJsaWMnLCAncHVibGljJywgYW5kICdwdWJsaWNUb1ByaXZhdGUnLmApO1xufVxuXG5leHBvcnQgeyBBbGVvS2V5UHJvdmlkZXIgYXMgQSwgQ1JFRElUU19QUk9HUkFNX0tFWVMgYXMgQywgS0VZX1NUT1JFIGFzIEssIFByb2dyYW1NYW5hZ2VyIGFzIFAsIFZBTElEX1RSQU5TRkVSX1RZUEVTIGFzIFYsIEFsZW9LZXlQcm92aWRlclBhcmFtcyBhcyBhLCBBbGVvTmV0d29ya0NsaWVudCBhcyBiLCBQUklWQVRFX1RSQU5TRkVSIGFzIGMsIFBSSVZBVEVfVE9fUFVCTElDX1RSQU5TRkVSIGFzIGQsIFBSSVZBVEVfVFJBTlNGRVJfVFlQRVMgYXMgZSwgUFVCTElDX1RSQU5TRkVSIGFzIGYsIFBVQkxJQ19UUkFOU0ZFUl9BU19TSUdORVIgYXMgZywgUFVCTElDX1RPX1BSSVZBVEVfVFJBTlNGRVIgYXMgaCwgbG9nQW5kVGhyb3cgYXMgbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3JhbS1tYW5hZ2VyLUNqdm5PeWZuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/worker.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/worker.js ***!
  \******************************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_proposals_json_parse_with_source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/proposals/json-parse-with-source.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/proposals/json-parse-with-source.js\");\n/* harmony import */ var _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @provablehq/wasm/testnet.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+wasm@0.8.6/node_modules/@provablehq/wasm/dist/testnet/index.js\");\n/* harmony import */ var _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./program-manager-CjvnOyfn.js */ \"(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/program-manager-CjvnOyfn.js\");\n/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! comlink */ \"(ssr)/./node_modules/.pnpm/comlink@4.4.2/node_modules/comlink/dist/esm/comlink.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__]);\n([_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__, _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nawait (0,_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.initThreadPool)();\nconst defaultHost = \"https://api.explorer.provable.com/v1\";\nconst keyProvider = new _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.A();\nconst programManager = new _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.P(defaultHost, keyProvider, undefined);\nkeyProvider.useCache(true);\nlet lastLocalProgram = \"\";\nasync function run(localProgram, aleoFunction, inputs, privateKey, proveExecution = false) {\n    console.log(\"Web worker: Executing function locally...\");\n    const startTime = performance.now();\n    // Ensure the program is valid and that it contains the function specified\n    let program;\n    try {\n        program = programManager.createProgramFromSource(localProgram);\n    }\n    catch (e) {\n        throw new Error(\"Error creating program from source\");\n    }\n    const program_id = program.id();\n    if (!program.hasFunction(aleoFunction)) {\n        throw new Error(`Program ${program_id} does not contain function ${aleoFunction}`);\n    }\n    const cacheKey = `${program_id}:${aleoFunction}`;\n    // Get the program imports\n    let imports;\n    try {\n        imports = await programManager.networkClient.getProgramImports(localProgram);\n    }\n    catch (e) {\n        throw new Error(\"Error getting program imports\");\n    }\n    // Get the proving and verifying keys for the function\n    if (lastLocalProgram !== localProgram) {\n        const keys = await programManager.synthesizeKeys(localProgram, aleoFunction, inputs, _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_string(privateKey));\n        programManager.keyProvider.cacheKeys(cacheKey, keys);\n        lastLocalProgram = localProgram;\n    }\n    // Pass the cache key to the execute function\n    const keyParams = new _program_manager_CjvnOyfn_js__WEBPACK_IMPORTED_MODULE_2__.a({\n        cacheKey: cacheKey,\n    });\n    // Execute the function locally\n    const response = await programManager.run(localProgram, aleoFunction, inputs, proveExecution, imports, keyParams, undefined, undefined, _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_string(privateKey));\n    // Return the outputs to the main thread\n    console.log(`Web worker: Local execution completed in ${performance.now() - startTime} ms`);\n    const outputs = response.getOutputs();\n    const execution = response.getExecution();\n    let executionString = \"\";\n    let keys;\n    try {\n        keys = keyProvider.getKeys(cacheKey);\n    }\n    catch (e) {\n        throw new Error(\"Could not get verifying key\");\n    }\n    const verifyingKey = keys[1];\n    if (execution) {\n        (0,_provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.verifyFunctionExecution)(execution, verifyingKey, program, \"hello\");\n        executionString = execution.toString();\n        console.log(\"Execution verified successfully: \" + execution);\n    }\n    else {\n        executionString = \"\";\n    }\n    console.log(`Function execution response: ${outputs}`);\n    return { outputs: outputs, execution: executionString };\n}\nasync function getPrivateKey() {\n    const privateKey = new _provablehq_wasm_testnet_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey();\n    return privateKey.to_string();\n}\nconst workerAPI = { run, getPrivateKey };\n(0,comlink__WEBPACK_IMPORTED_MODULE_3__.expose)(workerAPI);\n//# sourceMappingURL=worker.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3ZhYmxlaHErc2RrQDAuOC42L25vZGVfbW9kdWxlcy9AcHJvdmFibGVocS9zZGsvZGlzdC90ZXN0bmV0L3dvcmtlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRDtBQUM2QztBQUNvQjtBQUNyRjs7QUFFakMsTUFBTSwyRUFBYztBQUNwQjtBQUNBLHdCQUF3QiwyREFBZTtBQUN2QywyQkFBMkIsMkRBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksNEJBQTRCLGFBQWE7QUFDeEY7QUFDQSx3QkFBd0IsV0FBVyxHQUFHLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsbUVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQXFCO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNElBQTRJLG1FQUFVO0FBQ3RKO0FBQ0EsNERBQTRELCtCQUErQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9GQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQixtRUFBVTtBQUNyQztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLCtDQUFNO0FBQ04iLCJzb3VyY2VzIjpbIi9ob21lL3VzZXJuYW1lL2FsZW8vcmF0ZS1saW1pdGluZy1udWxsaWZpZXIvcmxuLW1lc3NhZ2UtYm9hcmQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm92YWJsZWhxK3Nka0AwLjguNi9ub2RlX21vZHVsZXMvQHByb3ZhYmxlaHEvc2RrL2Rpc3QvdGVzdG5ldC93b3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb3JlLWpzL3Byb3Bvc2Fscy9qc29uLXBhcnNlLXdpdGgtc291cmNlLmpzJztcbmltcG9ydCB7IGluaXRUaHJlYWRQb29sLCBQcml2YXRlS2V5LCB2ZXJpZnlGdW5jdGlvbkV4ZWN1dGlvbiB9IGZyb20gJ0Bwcm92YWJsZWhxL3dhc20vdGVzdG5ldC5qcyc7XG5pbXBvcnQgeyBBIGFzIEFsZW9LZXlQcm92aWRlciwgUCBhcyBQcm9ncmFtTWFuYWdlciwgYSBhcyBBbGVvS2V5UHJvdmlkZXJQYXJhbXMgfSBmcm9tICcuL3Byb2dyYW0tbWFuYWdlci1DanZuT3lmbi5qcyc7XG5pbXBvcnQgeyBleHBvc2UgfSBmcm9tICdjb21saW5rJztcblxuYXdhaXQgaW5pdFRocmVhZFBvb2woKTtcbmNvbnN0IGRlZmF1bHRIb3N0ID0gXCJodHRwczovL2FwaS5leHBsb3Jlci5wcm92YWJsZS5jb20vdjFcIjtcbmNvbnN0IGtleVByb3ZpZGVyID0gbmV3IEFsZW9LZXlQcm92aWRlcigpO1xuY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIoZGVmYXVsdEhvc3QsIGtleVByb3ZpZGVyLCB1bmRlZmluZWQpO1xua2V5UHJvdmlkZXIudXNlQ2FjaGUodHJ1ZSk7XG5sZXQgbGFzdExvY2FsUHJvZ3JhbSA9IFwiXCI7XG5hc3luYyBmdW5jdGlvbiBydW4obG9jYWxQcm9ncmFtLCBhbGVvRnVuY3Rpb24sIGlucHV0cywgcHJpdmF0ZUtleSwgcHJvdmVFeGVjdXRpb24gPSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKFwiV2ViIHdvcmtlcjogRXhlY3V0aW5nIGZ1bmN0aW9uIGxvY2FsbHkuLi5cIik7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gRW5zdXJlIHRoZSBwcm9ncmFtIGlzIHZhbGlkIGFuZCB0aGF0IGl0IGNvbnRhaW5zIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWRcbiAgICBsZXQgcHJvZ3JhbTtcbiAgICB0cnkge1xuICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbU1hbmFnZXIuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UobG9jYWxQcm9ncmFtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgcHJvZ3JhbSBmcm9tIHNvdXJjZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbV9pZCA9IHByb2dyYW0uaWQoKTtcbiAgICBpZiAoIXByb2dyYW0uaGFzRnVuY3Rpb24oYWxlb0Z1bmN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gJHtwcm9ncmFtX2lkfSBkb2VzIG5vdCBjb250YWluIGZ1bmN0aW9uICR7YWxlb0Z1bmN0aW9ufWApO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleSA9IGAke3Byb2dyYW1faWR9OiR7YWxlb0Z1bmN0aW9ufWA7XG4gICAgLy8gR2V0IHRoZSBwcm9ncmFtIGltcG9ydHNcbiAgICBsZXQgaW1wb3J0cztcbiAgICB0cnkge1xuICAgICAgICBpbXBvcnRzID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIubmV0d29ya0NsaWVudC5nZXRQcm9ncmFtSW1wb3J0cyhsb2NhbFByb2dyYW0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBnZXR0aW5nIHByb2dyYW0gaW1wb3J0c1wiKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBwcm92aW5nIGFuZCB2ZXJpZnlpbmcga2V5cyBmb3IgdGhlIGZ1bmN0aW9uXG4gICAgaWYgKGxhc3RMb2NhbFByb2dyYW0gIT09IGxvY2FsUHJvZ3JhbSkge1xuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIuc3ludGhlc2l6ZUtleXMobG9jYWxQcm9ncmFtLCBhbGVvRnVuY3Rpb24sIGlucHV0cywgUHJpdmF0ZUtleS5mcm9tX3N0cmluZyhwcml2YXRlS2V5KSk7XG4gICAgICAgIHByb2dyYW1NYW5hZ2VyLmtleVByb3ZpZGVyLmNhY2hlS2V5cyhjYWNoZUtleSwga2V5cyk7XG4gICAgICAgIGxhc3RMb2NhbFByb2dyYW0gPSBsb2NhbFByb2dyYW07XG4gICAgfVxuICAgIC8vIFBhc3MgdGhlIGNhY2hlIGtleSB0byB0aGUgZXhlY3V0ZSBmdW5jdGlvblxuICAgIGNvbnN0IGtleVBhcmFtcyA9IG5ldyBBbGVvS2V5UHJvdmlkZXJQYXJhbXMoe1xuICAgICAgICBjYWNoZUtleTogY2FjaGVLZXksXG4gICAgfSk7XG4gICAgLy8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24gbG9jYWxseVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZ3JhbU1hbmFnZXIucnVuKGxvY2FsUHJvZ3JhbSwgYWxlb0Z1bmN0aW9uLCBpbnB1dHMsIHByb3ZlRXhlY3V0aW9uLCBpbXBvcnRzLCBrZXlQYXJhbXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBQcml2YXRlS2V5LmZyb21fc3RyaW5nKHByaXZhdGVLZXkpKTtcbiAgICAvLyBSZXR1cm4gdGhlIG91dHB1dHMgdG8gdGhlIG1haW4gdGhyZWFkXG4gICAgY29uc29sZS5sb2coYFdlYiB3b3JrZXI6IExvY2FsIGV4ZWN1dGlvbiBjb21wbGV0ZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZX0gbXNgKTtcbiAgICBjb25zdCBvdXRwdXRzID0gcmVzcG9uc2UuZ2V0T3V0cHV0cygpO1xuICAgIGNvbnN0IGV4ZWN1dGlvbiA9IHJlc3BvbnNlLmdldEV4ZWN1dGlvbigpO1xuICAgIGxldCBleGVjdXRpb25TdHJpbmcgPSBcIlwiO1xuICAgIGxldCBrZXlzO1xuICAgIHRyeSB7XG4gICAgICAgIGtleXMgPSBrZXlQcm92aWRlci5nZXRLZXlzKGNhY2hlS2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCB2ZXJpZnlpbmcga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlpbmdLZXkgPSBrZXlzWzFdO1xuICAgIGlmIChleGVjdXRpb24pIHtcbiAgICAgICAgdmVyaWZ5RnVuY3Rpb25FeGVjdXRpb24oZXhlY3V0aW9uLCB2ZXJpZnlpbmdLZXksIHByb2dyYW0sIFwiaGVsbG9cIik7XG4gICAgICAgIGV4ZWN1dGlvblN0cmluZyA9IGV4ZWN1dGlvbi50b1N0cmluZygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV4ZWN1dGlvbiB2ZXJpZmllZCBzdWNjZXNzZnVsbHk6IFwiICsgZXhlY3V0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4ZWN1dGlvblN0cmluZyA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBGdW5jdGlvbiBleGVjdXRpb24gcmVzcG9uc2U6ICR7b3V0cHV0c31gKTtcbiAgICByZXR1cm4geyBvdXRwdXRzOiBvdXRwdXRzLCBleGVjdXRpb246IGV4ZWN1dGlvblN0cmluZyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJpdmF0ZUtleSgpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IFByaXZhdGVLZXkoKTtcbiAgICByZXR1cm4gcHJpdmF0ZUtleS50b19zdHJpbmcoKTtcbn1cbmNvbnN0IHdvcmtlckFQSSA9IHsgcnVuLCBnZXRQcml2YXRlS2V5IH07XG5leHBvc2Uod29ya2VyQVBJKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@provablehq+sdk@0.8.6/node_modules/@provablehq/sdk/dist/testnet/worker.js\n");

/***/ })

};
;